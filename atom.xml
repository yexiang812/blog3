<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yeye 想变强</title>
  
  <subtitle>技术&amp;生活blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-12-27T07:58:11.823Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yeyeyefirst</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码随想录-day11</title>
    <link href="http://example.com/2025/12/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day11/"/>
    <id>http://example.com/2025/12/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day11/</id>
    <published>2025-12-27T04:33:10.000Z</published>
    <updated>2025-12-27T07:58:11.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h1><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">题目链接</a><br>根据 逆波兰表示法，求表达式的值。<br>有效的运算符包括 + ,  - ,  * ,  &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：<br>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><ul><li>示例 1：<br>输入: [“2”, “1”, “+”, “3”, “ * “]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</li><li>示例 2：<br>输入: [“4”, “13”, “5”, “&#x2F;“, “+”]<br>输出: 6<br>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</li><li>示例 3：<br>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “ * “, “&#x2F;“, “ * “, “17”, “+”, “5”, “+”]<br>输出: 22<br>解释:该算式转化为常见的中缀算术表达式为：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((10 * (6 / ((9 + 3) * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5     </span><br><span class="line">= ((10 * 0) + 17) + 5     </span><br><span class="line">= (0 + 17) + 5    </span><br><span class="line">= 17 + 5    </span><br><span class="line">= 22    </span><br></pre></td></tr></table></figure><blockquote><p>逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。<br> 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br> 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。（是一种二叉数树的后续遍历）<br> 逆波兰表达式主要有以下两个优点：<br> 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br> 适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。<hr></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&quot;+&quot;</span> <span class="keyword">or</span> i == <span class="string">&#x27;-&#x27;</span> <span class="keyword">or</span> i == <span class="string">&#x27;*&#x27;</span> <span class="keyword">or</span> i == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                a = stack.pop()</span><br><span class="line">                b = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    stack.append(a+b)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    stack.append(b-a)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    stack.append(a*b)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(b/a)) <span class="comment"># 向零取整用int（b/a）直接截断小数部分</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                stack.append(<span class="built_in">int</span>(i))</span><br><span class="line">        <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure><p>使用栈来保存数字，遇到运算符就弹出栈顶的两个数字进行计算，然后把结果压回栈中。最后栈中剩下的数字就是结果。</p><h1 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">题目链接</a><br>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回滑动窗口中的最大值。</p><ul><li>示例 1：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> :</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (<span class="variable language_">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.que = deque()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self,value</span>): <span class="comment">#这里啥时候队列可能为空呢</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.que <span class="keyword">and</span> value == <span class="variable language_">self</span>.que[<span class="number">0</span>]:<span class="comment">#队列不为空且遍历的值等于队口</span></span><br><span class="line">            <span class="variable language_">self</span>.que.popleft()   <span class="comment">#弹的是最大（对头在左）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.que <span class="keyword">and</span> value &gt; <span class="variable language_">self</span>.que[-<span class="number">1</span>]:</span><br><span class="line">            <span class="variable language_">self</span>.que.pop()</span><br><span class="line">        <span class="variable language_">self</span>.que.append(value)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        que = Queue()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            que.push(nums[i])</span><br><span class="line">        result.append(que.get())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,<span class="built_in">len</span>(nums)):</span><br><span class="line">            que.pop(nums[i-k]) <span class="comment">#例如加入第四个元素前要移除第一个</span></span><br><span class="line">            que.push(nums[i])</span><br><span class="line">            result.append(que.get())</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>下面是ai的带注释的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonotonicQueue</span>:  <span class="comment"># 改名：明确是单调递减队列，避免语义混淆</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.que = deque()  <span class="comment"># 存储 nums 的元素（也可存索引，更灵活）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_left</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        滑动窗口移动时，移除窗口左边界的元素（仅当该元素是队首时，因为队首是最大值）</span></span><br><span class="line"><span class="string">        此时队列可能为空：必须先判断 self.que 非空</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.que <span class="keyword">and</span> value == <span class="variable language_">self</span>.que[<span class="number">0</span>]:  <span class="comment"># 队列非空 + 左边界元素是队首（最大值）</span></span><br><span class="line">            <span class="variable language_">self</span>.que.popleft()  <span class="comment"># 弹出队首（移除窗口外的最大值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        加入当前元素，维持队列单调递减：</span></span><br><span class="line"><span class="string">        移除队列中所有比当前元素小的元素（这些元素不可能成为后续窗口的最大值）</span></span><br><span class="line"><span class="string">        此时队列可能为空：空队列直接 append 即可</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.que <span class="keyword">and</span> <span class="variable language_">self</span>.que[-<span class="number">1</span>] &lt; value:  <span class="comment"># 队列非空 + 队尾元素 &lt; 当前元素</span></span><br><span class="line">            <span class="variable language_">self</span>.que.pop()  <span class="comment"># 移除队尾（从右弹出，deque.pop() 是O(1)）</span></span><br><span class="line">        <span class="variable language_">self</span>.que.append(value)  <span class="comment"># 加入当前元素，队列仍保持递减</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_max</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取当前窗口最大值（队首），必须保证调用前队列非空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        <span class="comment"># 边界情况处理（避免队列空时调用 get_max）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k == <span class="number">0</span> <span class="keyword">or</span> k &gt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        que = MonotonicQueue()</span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第一步：初始化第一个窗口（前 k 个元素）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            que.push(nums[i])</span><br><span class="line">        <span class="comment"># 第一个窗口的最大值加入结果（此时队列非空，因为 k&lt;=len(nums) 且 nums 非空）</span></span><br><span class="line">        result.append(que.get_max())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二步：滑动窗口（从第 k 个元素开始，到最后一个元素）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 1. 移除窗口左边界的元素（i-k 是当前窗口的左边界索引）</span></span><br><span class="line">            left_value = nums[i - k]  <span class="comment"># 窗口要移除的左边界元素</span></span><br><span class="line">            que.remove_left(left_value)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 2. 加入当前窗口的右边界元素（第 i 个元素）</span></span><br><span class="line">            que.push(nums[i])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 3. 记录当前窗口的最大值（队列非空）</span></span><br><span class="line">            result.append(que.get_max())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试案例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="built_in">print</span>(s.maxSlidingWindow([<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="number">3</span>))  <span class="comment"># 输出 [3,3,5,5,6,7]（正确）</span></span><br><span class="line">    <span class="built_in">print</span>(s.maxSlidingWindow([], <span class="number">3</span>))  <span class="comment"># 输出 []（边界处理）</span></span><br><span class="line">    <span class="built_in">print</span>(s.maxSlidingWindow([<span class="number">1</span>], <span class="number">1</span>))  <span class="comment"># 输出 [1]（边界处理）</span></span><br><span class="line">    <span class="built_in">print</span>(s.maxSlidingWindow([<span class="number">1</span>,-<span class="number">1</span>], <span class="number">2</span>))  <span class="comment"># 输出 [1]（边界处理）</span></span><br></pre></td></tr></table></figure><p>这道题是用单调队列来解决的，单调队列是指队列中的元素是单调递增或递减的。<br>那如何保证队列中的元素是单调递减的呢？<br>当有新元素加入时，我们将队列中所有比新元素小的元素都弹出，直到队列为空或者队列尾部的元素大于等于新元素为止。这样就保证了队列中的元素是单调递减的。</p><ul><li>关于我在视频弹幕上遇到的一个情况5231，其实解决这个的方式是在push方法中加入一个判断，当队列非空且队尾元素小于等于新元素时，弹出队尾元素，直到队列为空或者队列尾部的元素大于等于新元素为止。（这样3进去的之前2就被弹出了）<hr></li><li>为啥要判断队列非空？<br><br>初始阶段：刚实例化 Queue 时（<strong>init</strong> 后），self.que &#x3D; deque() 是空的，此时调用 pop&#x2F;get 都会操作空队列。<br><br>窗口滑动时移除元素后：比如窗口内所有元素都被 pop 方法移除（例如滑动窗口移动时，队首元素是前一个窗口的最大值，被弹出后队列无其他元素）。<br><br>nums 数组本身为空或 k&#x3D;0：当输入 nums &#x3D; [] 或 k&#x3D;0 时，循环不执行 push，队列始终为空。<hr></li></ul><h1 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h1><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">题目链接</a></p><blockquote><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p></blockquote><p>示例 1:</p><ul><li>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</li><li>输出: [1,2]<br></li></ul><p>示例 2:</p><ul><li>输入: nums &#x3D; [1], k &#x3D; 1</li><li>输出: [1]<br></li></ul><p>提示：</p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 $O(n \log n)$ , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="built_in">dir</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">dir</span>[nums[i]] = <span class="built_in">dir</span>.get(nums[i],<span class="number">0</span>) + <span class="number">1</span> <span class="comment">#key不存在就设为0，存在就加1</span></span><br><span class="line">        que = []</span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">dir</span>.items():</span><br><span class="line">            heapq.heappush(que,(value,key)) <span class="comment">#注意value在前，因为按照value排序的</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(que) &gt; k:</span><br><span class="line">                heapq.heappop(que)</span><br><span class="line">        result = [<span class="number">0</span>] * k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>): <span class="comment">#第一个-1取不到所以就是0开始</span></span><br><span class="line">            result[i] = heapq.heappop(que)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>使用哈希表统计每个元素的频率，然后使用小顶堆维护前 k 个高频元素。<br>小顶堆的大小为 k，每次加入一个元素后，如果堆的大小超过 k，就弹出堆顶元素。<br>解释一下堆，就是完全二叉树，每个节点的左右子树都是堆，且根节点是堆顶。<br>小顶堆的性质是，堆顶元素是堆中最小的元素。<br>大顶堆的性质是，堆顶元素是堆中最大的元素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逆波兰表达式求值&quot;&gt;&lt;a href=&quot;#逆波兰表达式求值&quot; class=&quot;headerlink&quot; title=&quot;逆波兰表达式求值&quot;&gt;&lt;/a&gt;逆波兰表达式求值&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/evaluate</summary>
      
    
    
    
    <category term="算法学习——栈和队列" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day10</title>
    <link href="http://example.com/2025/12/26/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day10/"/>
    <id>http://example.com/2025/12/26/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day10/</id>
    <published>2025-12-26T13:25:17.000Z</published>
    <updated>2025-12-26T15:01:16.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">题目链接</a></p><blockquote><p>使用栈实现队列的下列操作：<br>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。<br>示例:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);</span><br><span class="line">queue.peek();  // 返回 1</span><br><span class="line">queue.pop();   // 返回 1</span><br><span class="line">queue.empty(); // 返回 false</span><br></pre></td></tr></table></figure><p>说明:<br>你只能使用标准的栈操作 – 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack_in = []</span><br><span class="line">        <span class="variable language_">self</span>.stack_out = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.stack_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stack_out :</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stack_out.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.stack_in)):</span><br><span class="line">                <span class="variable language_">self</span>.stack_out.append(<span class="variable language_">self</span>.stack_in.pop())</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stack_out.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = <span class="variable language_">self</span>.pop()</span><br><span class="line">        <span class="variable language_">self</span>.stack_out.append(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span>  (<span class="variable language_">self</span>.stack_in <span class="keyword">or</span> <span class="variable language_">self</span>.stack_out)</span><br></pre></td></tr></table></figure><p>由于栈是先进后出，队列是先进先出，所以需要两个栈来实现队列的功能。实现负负得正。<br>然后查看头节点可以用出队列的代码复用，得到后记得再入栈</p><h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">题目链接</a></p><blockquote><p>使用队列实现栈的下列操作：</p></blockquote><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p>注意:</p><ul><li>你只能使用队列的基本操作– 也就是 push to back, peek&#x2F;pop from front, size, 和 is empty 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.deq = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.deq.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.deq)-<span class="number">1</span>):</span><br><span class="line">                <span class="variable language_">self</span>.deq.append(<span class="variable language_">self</span>.deq.popleft())</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.deq.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.deq[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.deq</span><br></pre></td></tr></table></figure><p>使用一个队列来实现栈的功能。入栈直接入队列即可。出栈需要将队列中的元素依次出队列再入队列，直到只剩下最后一个元素，这个元素就是栈顶元素，直接出队列即可。</p><h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">题目链接</a></p><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：</p></blockquote><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。<br>示例 1：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) %<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                stack.append(<span class="string">&quot;)&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                stack.append(<span class="string">&quot;]&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                stack.append(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> i != stack[-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>这道题是用栈来实现的，遍历字符串，遇到左括号就入栈，遇到右括号就出栈，判断是否匹配。提前为空、栈顶元素不匹配、字符串遍历完成后栈不为空，这三种情况都是无效的。<br>我遇到了一个很有意思的错误<code>elif not stack or i != stack.pop():</code><br>原先我的代码是这样的，但是报错确实在十六行告诉我空栈不能pop，我原本以为是因为python的判断条件是左右会都判断，哪怕左边已经为真了，但其实问题是我在判断栈顶元素是否匹配时，直接用了pop方法，提前把最后一元素出栈这会导致栈为空后续没法pop。</p><h1 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h1><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">题目链接</a></p><blockquote><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p></blockquote><ul><li><p>示例：</p></li><li><p>输入：”abbaca”</p></li><li><p>输出：”ca”</p></li><li><p>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。<br>之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。<br>提示：</p></li><li><p>1 &lt;&#x3D; S.length &lt;&#x3D; 20000</p></li><li><p>S 仅由小写英文字母组成。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> i == stack[-<span class="number">1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure><p>这道题是用栈来实现的，遍历字符串，遇到字符就入栈，遇到和栈顶元素相同的字符就出栈。最后栈中的元素就是没有重复项的字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用栈实现队列&quot;&gt;&lt;a href=&quot;#用栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;用栈实现队列&quot;&gt;&lt;/a&gt;用栈实现队列&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/implement-queue-</summary>
      
    
    
    
    <category term="算法学习——栈和队列" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>一些关于编程语言的知识</title>
    <link href="http://example.com/2025/12/26/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2025/12/26/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%9F%A5%E8%AF%86/</id>
    <published>2025-12-26T12:40:16.000Z</published>
    <updated>2025-12-27T05:12:30.938Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容来自ai（豆包），为了我自己的学习，我把它记录下来。</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="一、STL-到底是什么？"><a href="#一、STL-到底是什么？" class="headerlink" title="一、STL 到底是什么？"></a>一、STL 到底是什么？</h3><p>STL 是 <strong>Standard Template Library（标准模板库）</strong> 的缩写，是 C++ 标准库的核心组成部分，本质是一套 <strong>通用、可复用的模板类&#x2F;函数库</strong>。</p><p>简单说：</p><ul><li>它是 C++ 官方提供的“工具集”，不用自己写基础数据结构（比如栈、队列、数组、链表）和算法（比如排序、查找、遍历），直接调用就行；</li><li>核心优势是 <strong>模板化</strong>（跨数据类型通用，比如一个 <code>vector</code> 既可以存 <code>int</code>，也能存 <code>string</code>）、<strong>高效</strong>（底层用最优算法实现）、<strong>标准化</strong>（所有符合 C++ 标准的编译器都支持，比如 GCC、Clang、MSVC）。</li></ul><p>STL 主要包含 6 大组件，日常开发最常用的是前 4 个：</p><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td>容器（Container）</td><td>存储数据的“容器”（比如 <code>vector</code> 动态数组、<code>list</code> 链表、<code>stack</code> 栈、<code>map</code> 字典）</td></tr><tr><td>算法（Algorithm）</td><td>操作容器数据的算法（比如 <code>sort</code> 排序、<code>find</code> 查找、<code>reverse</code> 反转）</td></tr><tr><td>迭代器（Iterator）</td><td>连接容器和算法的“桥梁”（类似指针，遍历容器数据）</td></tr><tr><td>适配器（Adaptor）</td><td>对现有容器“包装改造”，改变其接口（比如 <code>stack</code> 就是对其他容器的适配器）</td></tr><tr><td>函数对象（Functor）</td><td>行为类似函数的对象（配合算法使用，比如自定义排序规则）</td></tr><tr><td>分配器（Allocator）</td><td>负责容器的内存分配&#x2F;释放（底层细节，用户一般不用关心）</td></tr></tbody></table><h3 id="二、STL-中-stack-的实现原理"><a href="#二、STL-中-stack-的实现原理" class="headerlink" title="二、STL 中 stack 的实现原理"></a>二、STL 中 <code>stack</code> 的实现原理</h3><p><code>stack</code>（栈）的核心特性是 <strong>LIFO（后进先出）</strong>：只能从“栈顶”插入（<code>push</code>）、删除（<code>pop</code>）和访问（<code>top</code>）数据，不能随机访问中间元素。</p><h4 id="关键结论：stack-不是独立的容器，而是「容器适配器」"><a href="#关键结论：stack-不是独立的容器，而是「容器适配器」" class="headerlink" title="关键结论：stack 不是独立的容器，而是「容器适配器」"></a>关键结论：<code>stack</code> 不是独立的容器，而是「容器适配器」</h4><p>STL 的 <code>stack</code> 本身不存储数据，它是对一个 <strong>底层容器（Underlying Container）</strong> 进行“包装”，限制了其接口（只暴露栈需要的 <code>push/pop/top</code> 等），底层数据的存储、内存管理全靠这个“被包装的容器”。</p><h4 id="1-默认底层容器是什么？"><a href="#1-默认底层容器是什么？" class="headerlink" title="1. 默认底层容器是什么？"></a>1. 默认底层容器是什么？</h4><p>C++ 标准规定，<code>stack</code> 的 <strong>默认底层容器是 <code>deque</code></strong>（双端队列）。<br>选择 <code>deque</code> 的原因很简单：<code>deque</code> 支持 <strong>两端高效插入&#x2F;删除</strong>（时间复杂度 O(1)），而栈只需要操作“一端”（栈顶），用 <code>deque</code> 刚好匹配，且 <code>deque</code> 没有 <code>vector</code> 扩容时的拷贝开销，效率更高。</p><h4 id="2-可以自定义底层容器吗？"><a href="#2-可以自定义底层容器吗？" class="headerlink" title="2. 可以自定义底层容器吗？"></a>2. 可以自定义底层容器吗？</h4><p>可以！<code>stack</code> 是模板类，允许用户指定底层容器，只要这个容器支持以下 3 个核心操作即可：</p><ul><li><code>push_back()</code>：在尾部插入元素（栈顶对应容器尾部）；</li><li><code>pop_back()</code>：删除尾部元素；</li><li><code>back()</code>：访问尾部元素。</li></ul><p>满足条件的容器有 <code>vector</code>、<code>list</code>、<code>deque</code>，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 默认底层容器：deque</span></span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; st1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 自定义底层容器为 vector</span></span><br><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;&gt; st2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 自定义底层容器为 list</span></span><br><span class="line">std::stack&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; st3;</span><br></pre></td></tr></table></figure><h4 id="3-stack-的核心接口实现（伪代码）"><a href="#3-stack-的核心接口实现（伪代码）" class="headerlink" title="3. stack 的核心接口实现（伪代码）"></a>3. <code>stack</code> 的核心接口实现（伪代码）</h4><p><code>stack</code> 的接口非常简单，本质就是“转发”到底层容器的对应操作，伪代码能直观体现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = std::deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container c;  <span class="comment">// 底层容器（被包装的对象）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 入栈：调用底层容器的 push_back()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出栈：调用底层容器的 pop_back()（注意：不返回元素）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问栈顶：调用底层容器的 back()</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 栈是否为空：调用底层容器的 empty()</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 栈的大小：调用底层容器的 size()</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从伪代码能看出来：<code>stack</code> 没有自己的“数据存储逻辑”，所有操作都依赖底层容器，它只做了一件事——<strong>隐藏底层容器的其他接口（比如 <code>vector</code> 的 <code>operator[]</code> 随机访问），只暴露栈需要的 LIFO 接口</strong>。</p><h3 id="三、补充：stack-为什么不叫“容器”而叫“适配器”？"><a href="#三、补充：stack-为什么不叫“容器”而叫“适配器”？" class="headerlink" title="三、补充：stack 为什么不叫“容器”而叫“适配器”？"></a>三、补充：<code>stack</code> 为什么不叫“容器”而叫“适配器”？</h3><ul><li>容器（比如 <code>vector</code>、<code>list</code>）：是“原始存储容器”，支持完整的元素访问&#x2F;操作（比如 <code>vector</code> 可以随机访问、<code>list</code> 可以双向遍历）；</li><li>适配器（比如 <code>stack</code>、<code>queue</code>）：是“包装器”，不提供原始存储，而是基于现有容器，通过“限制接口”来实现特定的数据结构行为（栈的 LIFO、队列的 FIFO）。</li></ul><p>简单说：适配器是“改造现有容器”，而容器是“原生存储数据”。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>STL 是 C++ 标准库的核心，是通用的模板工具集，包含容器、算法、迭代器等组件；</li><li>STL 的 <code>stack</code> 是 <strong>容器适配器</strong>，底层不存数据，依赖其他容器实现；</li><li>默认底层容器是 <code>deque</code>，也可指定 <code>vector</code> 或 <code>list</code>（需支持 <code>push_back/pop_back/back</code>）；</li><li><code>stack</code> 的所有接口（<code>push/pop/top</code>）都是转发到底层容器的对应操作，核心是实现 LIFO 特性。</li></ol><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p><code>from collections import deque</code> 是 Python 中导入内置容器类 <code>deque</code> 的标准语法，以下是关于 <code>deque</code> 的详细解析、用法和场景说明：</p><h3 id="一、核心基础：什么是-deque？"><a href="#一、核心基础：什么是-deque？" class="headerlink" title="一、核心基础：什么是 deque？"></a>一、核心基础：什么是 deque？</h3><ul><li><strong>全称</strong>：Double-Ended Queue（双端队列）</li><li><strong>本质</strong>：Python 标准库 <code>collections</code> 模块提供的高效双端队列数据结构，支持<strong>两端（队首&#x2F;队尾）的快速插入和删除操作</strong>。</li><li><strong>与 list 的区别</strong>：<ul><li><code>list</code> 基于数组实现，队首插入&#x2F;删除（如 <code>list.insert(0, x)</code>、<code>list.pop(0)</code>）时间复杂度为 <code>O(n)</code>（需移动所有元素）；</li><li><code>deque</code> 基于双向链表（或类似优化结构）实现，两端操作时间复杂度均为 <code>O(1)</code>，效率远超 <code>list</code>。</li></ul></li></ul><h3 id="二、基本用法（需先导入-deque）"><a href="#二、基本用法（需先导入-deque）" class="headerlink" title="二、基本用法（需先导入 deque）"></a>二、基本用法（需先导入 <code>deque</code>）</h3><h4 id="1-初始化-deque"><a href="#1-初始化-deque" class="headerlink" title="1. 初始化 deque"></a>1. 初始化 deque</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 空队列</span></span><br><span class="line">dq = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 从可迭代对象（列表、字符串、元组等）初始化</span></span><br><span class="line">dq1 = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])       <span class="comment"># deque([1, 2, 3])</span></span><br><span class="line">dq2 = deque(<span class="string">&quot;abc&quot;</span>)           <span class="comment"># deque([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span></span><br><span class="line">dq3 = deque((<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), maxlen=<span class="number">5</span>)  <span class="comment"># 限制最大长度为5（超出会自动丢弃另一端元素）</span></span><br></pre></td></tr></table></figure><h4 id="2-两端插入操作（核心优势）"><a href="#2-两端插入操作（核心优势）" class="headerlink" title="2. 两端插入操作（核心优势）"></a>2. 两端插入操作（核心优势）</h4><table><thead><tr><th>方法</th><th>功能</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>append(x)</code></td><td>队尾添加元素 x</td><td><code>dq1.append(4)</code></td><td><code>deque([1, 2, 3, 4])</code></td></tr><tr><td><code>appendleft(x)</code></td><td>队首添加元素 x</td><td><code>dq1.appendleft(0)</code></td><td><code>deque([0, 1, 2, 3, 4])</code></td></tr><tr><td><code>extend(iterable)</code></td><td>队尾批量添加可迭代对象</td><td><code>dq1.extend([5, 6])</code></td><td><code>deque([0,1,2,3,4,5,6])</code></td></tr><tr><td><code>extendleft(iterable)</code></td><td>队首批量添加（逆序插入）</td><td><code>dq1.extendleft([-2, -1])</code></td><td><code>deque([-1, -2, 0,1,2,3,4,5,6])</code></td></tr></tbody></table><blockquote><p>注意 <code>extendleft</code>：会将可迭代对象的元素<strong>逆序</strong>插入队首（如 <code>extendleft([a,b])</code> 等价于 <code>appendleft(b)</code> 后 <code>appendleft(a)</code>）。</p></blockquote><h4 id="3-两端删除操作"><a href="#3-两端删除操作" class="headerlink" title="3. 两端删除操作"></a>3. 两端删除操作</h4><table><thead><tr><th>方法</th><th>功能</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>pop()</code></td><td>队尾删除并返回元素</td><td><code>dq1.pop()</code></td><td>返回 <code>6</code>，队列变为 <code>deque([-1,-2,0,1,2,3,4,5])</code></td></tr><tr><td><code>popleft()</code></td><td>队首删除并返回元素</td><td><code>dq1.popleft()</code></td><td>返回 <code>-1</code>，队列变为 <code>deque([-2,0,1,2,3,4,5])</code></td></tr><tr><td><code>clear()</code></td><td>清空队列</td><td><code>dq1.clear()</code></td><td><code>deque([])</code></td></tr></tbody></table><h4 id="4-其他常用方法"><a href="#4-其他常用方法" class="headerlink" title="4. 其他常用方法"></a>4. 其他常用方法</h4><ul><li><p><strong><code>maxlen</code> 属性</strong>：获取队列最大长度（初始化时指定，不可修改）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dq = deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(dq.maxlen)  <span class="comment"># 3</span></span><br><span class="line">dq.append(<span class="number">4</span>)      <span class="comment"># 超出maxlen，队首元素1被自动丢弃</span></span><br><span class="line"><span class="built_in">print</span>(dq)         <span class="comment"># deque([2, 3, 4])</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>rotate(n)</code></strong>：队列旋转（默认 <code>n=1</code>，队尾元素移到队首；<code>n=-1</code> 则队首元素移到队尾）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dq = deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">dq.rotate(<span class="number">1</span>)   <span class="comment"># 右旋转1位：4→队首</span></span><br><span class="line"><span class="built_in">print</span>(dq)      <span class="comment"># deque([4, 1, 2, 3])</span></span><br><span class="line">dq.rotate(-<span class="number">2</span>)  <span class="comment"># 左旋转2位：4、1→队尾</span></span><br><span class="line"><span class="built_in">print</span>(dq)      <span class="comment"># deque([2, 3, 4, 1])</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>count(x)</code></strong>：统计元素 x 的出现次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]).count(<span class="number">2</span>)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>remove(x)</code></strong>：删除第一个出现的元素 x（不存在则抛 <code>ValueError</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dq = deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line">dq.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(dq)  <span class="comment"># deque([1, 3, 2])</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="三、典型应用场景"><a href="#三、典型应用场景" class="headerlink" title="三、典型应用场景"></a>三、典型应用场景</h3><h4 id="1-实现队列（FIFO：先进先出）"><a href="#1-实现队列（FIFO：先进先出）" class="headerlink" title="1. 实现队列（FIFO：先进先出）"></a>1. 实现队列（FIFO：先进先出）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">queue = deque()</span><br><span class="line"><span class="comment"># 入队（队尾添加）</span></span><br><span class="line">queue.append(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">queue.append(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="comment"># 出队（队首删除）</span></span><br><span class="line"><span class="built_in">print</span>(queue.popleft())  <span class="comment"># &quot;a&quot;</span></span><br><span class="line"><span class="built_in">print</span>(queue.popleft())  <span class="comment"># &quot;b&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-实现栈（LIFO：后进先出）"><a href="#2-实现栈（LIFO：后进先出）" class="headerlink" title="2. 实现栈（LIFO：后进先出）"></a>2. 实现栈（LIFO：后进先出）</h4><p>（直接用 <code>append()</code> 和 <code>pop()</code>，等价于栈的压栈&#x2F;出栈）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack = deque()</span><br><span class="line">stack.append(<span class="number">1</span>)</span><br><span class="line">stack.append(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(stack.pop())  <span class="comment"># 2（后进先出）</span></span><br><span class="line"><span class="built_in">print</span>(stack.pop())  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h4 id="3-滑动窗口问题（利用-maxlen-自动维护窗口大小）"><a href="#3-滑动窗口问题（利用-maxlen-自动维护窗口大小）" class="headerlink" title="3. 滑动窗口问题（利用 maxlen 自动维护窗口大小）"></a>3. 滑动窗口问题（利用 <code>maxlen</code> 自动维护窗口大小）</h4><p>例如：求数组中每个位置的前 k 个元素的平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_average</span>(<span class="params">nums, k</span>):</span><br><span class="line">    dq = deque(maxlen=k)</span><br><span class="line">    averages = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        dq.append(num)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(dq) == k:  <span class="comment"># 窗口满了才计算平均值</span></span><br><span class="line">            averages.append(<span class="built_in">sum</span>(dq)/k)</span><br><span class="line">    <span class="keyword">return</span> averages</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sliding_average([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">3</span>))  <span class="comment"># [2.0, 3.0, 4.0, 5.0]</span></span><br></pre></td></tr></table></figure><h4 id="4-广度优先搜索（BFS）"><a href="#4-广度优先搜索（BFS）" class="headerlink" title="4. 广度优先搜索（BFS）"></a>4. 广度优先搜索（BFS）</h4><p>BFS 算法的核心是用队列存储待访问节点，<code>deque</code> 的 <code>popleft()</code> 效率远高于 <code>list.pop(0)</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    queue = deque([root])</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()  <span class="comment"># 队首出队</span></span><br><span class="line">        result.append(node.val)</span><br><span class="line">        <span class="comment"># 子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><ul><li><code>deque</code> 是 Python 中<strong>高效双端队列</strong>，核心优势是两端插入&#x2F;删除 <code>O(1)</code> 时间复杂度；</li><li>功能覆盖队列、栈、滑动窗口等场景，比 <code>list</code> 更适合频繁操作两端的场景；</li><li>需通过 <code>from collections import deque</code> 导入，支持 <code>maxlen</code>、<code>rotate</code> 等实用功能，是 Python 开发中高频使用的容器类。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下内容来自ai（豆包），为了我自己的学习，我把它记录下来。&lt;/p&gt;
&lt;h2 id=&quot;STL&quot;&gt;&lt;a href=&quot;#STL&quot; class=&quot;headerlink&quot; title=&quot;STL&quot;&gt;&lt;/a&gt;STL&lt;/h2&gt;&lt;h3 id=&quot;一、STL-到底是什么？&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day9</title>
    <link href="http://example.com/2025/12/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day9/"/>
    <id>http://example.com/2025/12/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day9/</id>
    <published>2025-12-25T14:22:45.000Z</published>
    <updated>2025-12-25T14:48:31.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h1><blockquote><p>给定一个字符串，逐个翻转字符串中的每个单词。</p></blockquote><ul><li>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</li><li>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>示例 3：<br>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br>方法一：split()分割加列表反转</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s_list = s.split()</span><br><span class="line">        s_list = s_list[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(s_list)</span><br></pre></td></tr></table></figure><p>方法二：双指针法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = s.split()</span><br><span class="line">        left,right = <span class="number">0</span>,<span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left],s[right]=s[right],s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(s)</span><br></pre></td></tr></table></figure><p>视频的方法今天有点来不及</p><h1 id="右旋字符串"><a href="#右旋字符串" class="headerlink" title="右旋字符串"></a>右旋字符串</h1><blockquote><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。<br>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。<br>输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。<br>输出：输出共一行，为进行了右旋转操作后的字符串。</p></blockquote><ul><li>样例输入：<br>2<br>abcdefg<br>样例输出：<br>fgabcde</li></ul><p>数据范围：1 &lt;&#x3D; k &lt; 10000, 1 &lt;&#x3D; s.length &lt; 10000</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s=<span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(s[-n:]+s[:-n])</span><br></pre></td></tr></table></figure><p>额，今天考马原上午都在看马原，额，但是不得不说，python真的太刁了，字符串切片操作真的是太方便了，但是我还是要提醒一下，字符串是不可变的，所以切片操作不会改变原字符串，而是返回一个新的字符串。</p><h1 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h1><p>感觉马原要挂科。明明我背那么久了，结果全背错了，张冠李戴给我玩明白了，我服了。一想到考研要考政治我就绝望</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;翻转字符串里的单词&quot;&gt;&lt;a href=&quot;#翻转字符串里的单词&quot; class=&quot;headerlink&quot; title=&quot;翻转字符串里的单词&quot;&gt;&lt;/a&gt;翻转字符串里的单词&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    <category term="算法学习——字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day8</title>
    <link href="http://example.com/2025/12/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day8/"/>
    <id>http://example.com/2025/12/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day8/</id>
    <published>2025-12-24T11:33:56.000Z</published>
    <updated>2025-12-24T13:04:56.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p></blockquote><ul><li>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</li><li>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        j=<span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)//<span class="number">2</span>):</span><br><span class="line">            s[i],s[j] = s[j],s[i]</span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这道题的思路是用双指针的方式，分别指向头尾，然后交换位置，循环判断条件就到中间位置（比长度的一半小）。</p><h1 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/">leetcode链接</a></p><blockquote><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。<br>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p></blockquote><ul><li>示例:<br>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “bacdfeg”</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">c_r</span>(<span class="params">s_</span>):</span><br><span class="line">            left,right = <span class="number">0</span>,<span class="built_in">len</span>(s_)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                s_[left],s_[right]=s_[right],s_[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s_</span><br><span class="line"></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        s_list=<span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            s_list[i:i+k] = c_r(s_list[i:i+k])</span><br><span class="line">            i += <span class="number">2</span> * k</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s_list)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s), <span class="number">2</span>*k):</span><br><span class="line">            s[i:i+k] = s[i:i+k][::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure><p>这道题的主要特点是切片的方式是以2k为步长，每次取k个字符进行反转。<br>并且python的切片操作是可以超出索引范围的，会自动截断为有效范围。（Python 切片的容错特性：无需判断剩余字符长度，i:i+k 自动截断为有效范围，让 “反转前 k 个 &#x2F; 反转全部剩余” 的要求自然满足），i相当于一个指针，每次移动2k个位置，只要能移动在下一次循环就进行切片。</p><h1 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h1><blockquote><p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。</p></blockquote><ul><li>例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。<br>对于输入字符串 “a5b”，函数应该将其转换为 “anumberb”<br>输入：一个字符串 s,s 仅包含小写字母和数字字符。<br>输出：打印一个新的字符串，其中每个数字字符都被替换为了number<br>样例输入：a1b2c3<br>样例输出：anumberbnumbercnumber<br>数据范围：1 &lt;&#x3D; s.length &lt; 10000。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">input</span>()</span><br><span class="line">count_num = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> n <span class="keyword">if</span> i.isdigit())</span><br><span class="line">count = count_num * <span class="number">5</span> + <span class="built_in">len</span>(n) <span class="comment">#记得count_num是数字字符的个数，每个数字字符替换为number后会增加5个字符，所以是*5</span></span><br><span class="line">n_list = [<span class="string">&#x27;&#x27;</span>] * count</span><br><span class="line">o_p = <span class="built_in">len</span>(n)- <span class="number">1</span></span><br><span class="line">n_p = count - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> o_p &gt;= <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> n[o_p].isdigit():</span><br><span class="line">        n_list[n_p-<span class="number">5</span>:n_p+<span class="number">1</span>] = <span class="string">&quot;number&quot;</span> <span class="comment">#注意切片是位置到位置，不能直接[n_p-5:6]这种操作</span></span><br><span class="line">        n_p -= <span class="number">6</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        n_list[n_p]=n[o_p]</span><br><span class="line">        n_p -= <span class="number">1</span></span><br><span class="line">    o_p -= <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(n_list))</span><br></pre></td></tr></table></figure><p>这道题还是用双指针的方式，一个指向原字符串的尾，一个指向新字符串的尾，根据是否为数字字符来判断是否需要替换。<br>如果是c语言从后向前可以避免每次替换后需要移动后面的字符的问题。python因为字符串是不可变的，所以需要先将字符串转换为列表，修改后再转换为字符串。<br>然后就是要两个指针一一对应，一个指向原字符串的当前字符，一个指向新字符串的当前位置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反转字符串&quot;&gt;&lt;a href=&quot;#反转字符串&quot; class=&quot;headerlink&quot; title=&quot;反转字符串&quot;&gt;&lt;/a&gt;反转字符串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给</summary>
      
    
    
    
    <category term="算法学习——字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day7</title>
    <link href="http://example.com/2025/12/23/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day7/"/>
    <id>http://example.com/2025/12/23/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day7/</id>
    <published>2025-12-23T12:08:42.000Z</published>
    <updated>2025-12-23T15:16:20.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四数相加II"><a href="#四数相加II" class="headerlink" title="四数相加II"></a>四数相加II</h1><blockquote><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。<br>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p></blockquote><ul><li>例如:<br>输入:<br>A &#x3D; [ 1, 2]<br>B &#x3D; [-2,-1]<br>C &#x3D; [-1, 2]<br>D &#x3D; [ 0, 2]<br>输出:<br>2<br>解释:<br>两个元组如下:<br>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0<br>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        t_set = &#123;&#125;</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                t_set[i+j] = t_set.get(i+j,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums3:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums4:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>-(i+j) <span class="keyword">in</span> t_set.keys():</span><br><span class="line">                    count += t_set[<span class="number">0</span>-(i+j)]</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>这道题就是将四个数分成两组前两个数一组，并把他们的和作为key，出现的次数作为value，存到一个哈希表中。<br>然后遍历后两个数的组合，判断0-(i+j)是否在哈希表中，如果在，就把出现的次数加到count中（注意加的是value的值不是一，原因是不用去重）。</p><h1 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h1><blockquote><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。<br>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p></blockquote><ul><li>例如:<br>输入: ransomNote &#x3D; “a”, magazine &#x3D; “b”<br>输出: false<br>输入: ransomNote &#x3D; “aa”, magazine &#x3D; “ab”<br>输出: false<br>输入: ransomNote &#x3D; “aa”, magazine &#x3D; “aab”<br>输出: true</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        a_hash = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            a_hash[<span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ransomNote:</span><br><span class="line">            <span class="keyword">if</span> a_hash[<span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                a_hash[<span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这道题就是用一个哈希表来记录 magazine 中的字符出现的次数，然后遍历 ransomNote 中的字符，判断是否在哈希表中，如果在，就把哈希表中对应的值减一。<br>直到遇到了0，就说明 magazine 中的字符不能构成 ransomNote 中的字符，返回 False。跟昨天第一题很像</p><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><blockquote><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。<br>注意： 答案中不可以包含重复的三元组。</p></blockquote><ul><li>示例：<br>给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result.append([nums[i],nums[left],nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>用了双指针的思路<br>首先先对数组排序，然后for循环用i作为第一个数，left作为第二个数，right作为第三个数，三个数求和判断是否等于0，如果等于0，就把这三个数加入到结果中。<br>如果大于0，就把right减一，如果小于0，就把left加一。<br>直到left大于等于right，就说明这个数组合完了，就可以继续下一个数了。<br>注意点<strong>去重操作是i和i-1比较，left和left+1比较，right和right-1比较</strong>，为啥这样的，因为i是基准，如果i和i+1判断，把下一个i跳了，i就像边界一样，left就指不到被跳的i的那个位置了，比如-2 -1 -1 0 2，但是i继续加一以后，发现和之前的i一样，这个i就可去掉了，这里不会重复是上一组的i已经用过这个顺序了，例如-1 -1 0 0 1 2，然后left和right就是和自己的下一个数比较即可，而且不会遗漏，哪怕有连续的left挑掉，right也会移动过去，不像i是基准</p><h1 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h1><blockquote><p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。<br>注意：<br>答案中不可以包含重复的四元组。</p></blockquote><ul><li>示例： 给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] &gt; target//<span class="number">4</span> :</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">#这里不能return result</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] &gt; target <span class="keyword">and</span> target &gt; <span class="number">0</span>: </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left,right = j+<span class="number">1</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    sum_=nums[i]+nums[j]+nums[left]+nums[right]</span><br><span class="line">                    <span class="keyword">if</span> sum_ == target:</span><br><span class="line">                        result.append([nums[i],nums[j],nums[left],nums[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right-<span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> sum_ &gt; target    :</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span> :</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>就是在i的基础上加了一个j也作为基准，然后在i和j的基础上用双指针的思路，left和right作为第三个数和第四个数，判断是否等于target，如果等于0，就把这四个数加入到结果中。<br>我再思考一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四数相加II&quot;&gt;&lt;a href=&quot;#四数相加II&quot; class=&quot;headerlink&quot; title=&quot;四数相加II&quot;&gt;&lt;/a&gt;四数相加II&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i,</summary>
      
    
    
    
    <category term="算法学习——哈希表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>python中我遇到的语法问题</title>
    <link href="http://example.com/2025/12/23/python%E4%B8%AD%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/12/23/python%E4%B8%AD%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98/</id>
    <published>2025-12-23T11:57:37.000Z</published>
    <updated>2025-12-26T13:58:57.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>1.python中查询key是否存在直接用<code>key in dict</code>，并且时间复杂度为O(1)因为字典底层是哈希表实现的。<br>2.字典的get方法可以设置默认值，比如<code>dict.get(key, default_value)</code>，如果key不存在则返回default_value。<br>3.分别使用<code>dict.keys()</code>、<code>dict.values()</code>、<code>dict.items()</code>可以获取字典的所有key、value、key-value对。<strong>注意</strong>，这三个都是方法，括号别忘了写。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>1.空数组的创建可以用<code>[]</code>或者<code>list()</code>，比如<code>a = []</code>或者<code>a = list()</code>。如果设置初值可以用<code>a = [0]*n</code>或者<code>a = list([0]*n)</code>。<br>2. 数组的切片可以用<code>array[start:end:step]</code>，比如<code>a[1:3]</code>表示获取数组a中索引从1到2的元素（不包括3），<code>a[::-1]</code>表示将数组a反转。<br>3. Python 中切片赋值时，右侧的赋值对象必须是可迭代对象，字符串 “number” 会被自动拆解为单个字符的可迭代序列，再逐个赋值到切片对应的位置(res[new_index-5:new_index+1] &#x3D; “number”)</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ol><li>python中排序可以用<code>list.sort()</code>或者<code>sorted(list)</code>，前者是在原数组上排序，后者是返回一个新的排序后的数组。</li><li>排序默认是升序排序，如果要降序排序可以用<code>list.sort(reverse=True)</code>或者<code>sorted(list, reverse=True)</code>。</li></ol><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ol><li>python中字符串是不可变的，所以如果要修改字符串中的某个字符，只能先将字符串转换为列表，修改后再转换为字符串。</li><li>字符串的拼接可以用<code>+</code>号，也可以用<code>join()</code>方法，比如<code>&#39;a&#39;+&#39;b&#39;</code>或者<code>&#39;a&#39;.join([&#39;b&#39;, &#39;c&#39;])</code>。</li><li>判断字符串是否只包含数字可以用<code>str.isdigit()</code>方法，比如<code>&#39;123&#39;.isdigit()</code>返回True，<code>&#39;123a&#39;.isdigit()</code>返回False。</li></ol><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><ol><li>生成器表达式是一种简洁的创建生成器的方式，它的语法和列表推导式类似，但是用圆括号括起来，比如<code>(x for x in range(5))</code>。</li></ol><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ol><li><p>deque（发音：deck），它是 Python 标准库 collections 中的「双端队列」，实现了在队列两端高效插入和删除元素的功能。相比于列表，deque 在头尾操作时具有更好的性能表现，时间复杂度为 O(1)。</p></li><li><p>deque 提供了 append()、appendleft()、pop()、popleft() 等方法，分别用于在队列的右端插入元素、左端插入元素、从右端删除元素、从左端删除元素。</p></li><li><p>deque 支持索引访问，比如<code>deque[0]</code>表示获取队列的队头元素，<code>deque[-1]</code>表示获取队列的队尾元素。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h1&gt;&lt;p&gt;1.python中查询key是否存在直接用&lt;code&gt;key in dict&lt;/code&gt;，并且时间复杂度为O(1)因为字典底层是哈希表实现</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day6</title>
    <link href="http://example.com/2025/12/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day6/"/>
    <id>http://example.com/2025/12/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day6/</id>
    <published>2025-12-22T12:53:47.000Z</published>
    <updated>2025-12-22T15:01:21.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1><blockquote><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br>-示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true<br>-示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false<br>说明: 你可以假设字符串只包含小写字母。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="built_in">hash</span> = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="built_in">hash</span>[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> t_ <span class="keyword">in</span> t:</span><br><span class="line">            <span class="built_in">hash</span>[<span class="built_in">ord</span>(t_) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">hash</span>:</span><br><span class="line">            <span class="keyword">if</span> h != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这道题的思路是：用一个长度为26的数组来存储每个字母出现的次数，遍历字符串s时，对应字母的位置加1，遍历字符串t时，对应字母的位置减1。最后遍历数组，<br>如果数组里面的元素都为0，说明两个字符串是字母异位词，返回True，否则返回False。<br>讲一下我觉得比较有意思的地方就是这个下标转化的方式，通过减去a的ascll值得到一个在0-25之间的下标，对应数组的位置，这样就可以统计每个字母出现的次数。（有点像凯撒密码，也算是一种哈希函数的实现）</p><h1 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h1><p>题意：给定两个数组，编写一个函数来计算它们的交集。<br><img src="/images/codecrazy/dsy6-T2.png" alt="T2题目案例"><br>说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_set = <span class="built_in">set</span>()</span><br><span class="line">        hash_list = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            hash_set.add(i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> hash_set:</span><br><span class="line">                hash_list.add(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(hash_list)</span><br></pre></td></tr></table></figure><p>也是用哈希表来存储数组里面的元素，然后存放在集合里面，因为集合里面要求元素是唯一的，再把数组1里集合元素和数组2里元素进行对比，如果存在就放到另一个集合里面，<br>最后返回集合转换为列表即可。</p><h1 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h1><blockquote><p>编写一个算法来判断一个数 n 是不是快乐数。<br> 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。<br> 如果 n 是快乐数就返回 True ；不是，则返回 False 。</p></blockquote><ul><li>示例：<br>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 &#x3D; 82<br>8^2 + 2^2 &#x3D; 68<br>6^2 + 8^2 &#x3D; 100<br>1^2 + 0^2 + 0^2 &#x3D; 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        set_=<span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            n = <span class="variable language_">self</span>.self_sum(n)</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> set_:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                set_.add(n)         </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">self_sum</span>(<span class="params">self,n</span>):   </span><br><span class="line">        new_n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n :</span><br><span class="line">            n1 = n % <span class="number">10</span></span><br><span class="line">            n = n // <span class="number">10</span></span><br><span class="line">            new_n += n1 ** <span class="number">2</span> </span><br><span class="line">        <span class="keyword">return</span> new_n</span><br></pre></td></tr></table></figure><p>这道题的思路是：用一个集合来存储每次计算得到的结果，如果结果重复出现，说明进入了循环，不是快乐数。如果结果为1，说明是快乐数。<br>利用哈希表来存储每次计算的结果，一旦出现重复的结果，说明进入了循环，不是快乐数。</p><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p></blockquote><ul><li>示例:<br>给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9<br>因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9<br>所以返回 [0, 1]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>=&#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)): <span class="comment">#遍历数组</span></span><br><span class="line">          <span class="keyword">if</span> target-nums[i] <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dir</span>: <span class="comment">#如果目标值减去当前值不在字典中</span></span><br><span class="line">              <span class="built_in">dir</span>[nums[i]] = i</span><br><span class="line">          <span class="keyword">else</span> :</span><br><span class="line">              <span class="keyword">return</span> [<span class="built_in">dir</span>[target-nums[i]],i]</span><br></pre></td></tr></table></figure><p>这道题在我的第一篇blog有，感兴趣的可以去看看，这道题是哈希表里面map的应用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有效的字母异位词&quot;&gt;&lt;a href=&quot;#有效的字母异位词&quot; class=&quot;headerlink&quot; title=&quot;有效的字母异位词&quot;&gt;&lt;/a&gt;有效的字母异位词&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s </summary>
      
    
    
    
    <category term="算法学习——哈希表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>week1_复盘</title>
    <link href="http://example.com/2025/12/21/week1-%E5%A4%8D%E7%9B%98/"/>
    <id>http://example.com/2025/12/21/week1-%E5%A4%8D%E7%9B%98/</id>
    <published>2025-12-21T14:28:51.000Z</published>
    <updated>2025-12-21T15:06:18.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="week1-复盘"><a href="#week1-复盘" class="headerlink" title="week1_复盘"></a>week1_复盘</h1><h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="第一道题"><a href="#第一道题" class="headerlink" title="第一道题"></a>第一道题</h3><p> 第一道题是二分搜索，几个关键点是，二分搜索得是有序数组，通过数学的二分法实现。<br>代码细节，一个是左闭右开，目标值小于mid，调整右指针到mid，注意右边是开的，因此mid&#x3D;right，如果目标值大于mid，调整左指针到mid+1，注意左边是闭的，因此left&#x3D;mid+1。<br>当然如果是左闭右闭，代码细节就会有一些变化，目标值小于mid，调整右指针到mid-1，注意右边是闭的，因此right&#x3D;mid-1，如果目标值大于mid，调整左指针到mid+1，注意左边是闭的，因此left&#x3D;mid+1。</p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>是移除元素，设置快慢指针，快指针用来遍历数组，慢指针用来指向新数组的位置。然后和目标值比较，如果不相等，慢指针加一，然后赋值为快指针的值。如果相等，快指针加一，继续遍历。</p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>然后是有序数组的平方，因为数组是有序的，所以平方后的最大值一定在数组的两端，所以可以设置双指针，一个指向数组的头，一个指向数组的尾。然后比较两个指针指向的元素的平方，将较大的那个放到新数组的末尾，然后对应的指针向中间移动。<br>当然也可以用python的推导式加上sort函数，实现有序数组的平方。</p><h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><h3 id="第一题长度最小的子数组"><a href="#第一题长度最小的子数组" class="headerlink" title="第一题长度最小的子数组"></a>第一题长度最小的子数组</h3><p>这道题是滑动窗口，设置左右指针，初始都指向数组的头，然后右指针向右移动，直到窗口内的元素和大于等于目标值，然后记录下窗口的长度，然后左指针向右移动，直到窗口内的元素和小于目标值，然后继续移动右指针满足条件后继续记录下窗口的长度，直到右指针到达数组的尾。</p><h3 id="第二题螺旋矩阵II"><a href="#第二题螺旋矩阵II" class="headerlink" title="第二题螺旋矩阵II"></a>第二题螺旋矩阵II</h3><p>这道题的关键是边界判定，四条边都用左闭右开的方式，最后一个点给下一条边，还有是循环条件是n&#x2F;&#x2F;2，转一圈掉两层，然后是偏移量，最开始是0 0 然后每次循环偏移量加一，然后是n为奇数时，最后一个点单独处理等于n。</p><p>你看看果然不能托现在才想起来附加题没做</p><h2 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h2><h3 id="第一题-移除链表元素"><a href="#第一题-移除链表元素" class="headerlink" title="第一题 移除链表元素"></a>第一题 移除链表元素</h3><p>这道题主要是考虑头节点被删除的情况，所以可以设置一个虚拟头节点，指向头节点，然后设置一个指针指向虚拟头节点，然后遍历链表，如果下一个节点的值等于目标值，就删除下一个节点，否则指针后移。最后返回虚拟头节点的下一个节点。</p><h3 id="第二题-设计链表"><a href="#第二题-设计链表" class="headerlink" title="第二题 设计链表"></a>第二题 设计链表</h3><p>这道题主要是考虑链表的基本操作，比如添加节点，删除节点，获取节点的值等。主要是index的处理，哦对链表没法用下标的方式来访问节点，所以需要遍历链表来找到目标节点。</p><h3 id="第三题-反转链表"><a href="#第三题-反转链表" class="headerlink" title="第三题 反转链表"></a>第三题 反转链表</h3><p>这道题是双指针一个cur节点加一个pre节点以及临时节点temp，初始时pre指向None，cur指向头节点，然后遍历链表，每次将cur的next指向pre，然后pre移动到cur，cur移动到temp，最后返回pre。<br>然后递归，还是不会写</p><h2 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h2><h3 id="第一题-两两交换链表中的节点"><a href="#第一题-两两交换链表中的节点" class="headerlink" title="第一题 两两交换链表中的节点"></a>第一题 两两交换链表中的节点</h3><p>这道题主要是找到前置节点，然后交换两个节点，然后移动指针到下一个位置，注意判断条件的先后，防止空指针异常。设置了两个temp节点，一个用来保存下一个节点，一个用来保存下下下一个节点。可以用画图帮助理解。</p><h3 id="第二题-删除链表的倒数第N个节点"><a href="#第二题-删除链表的倒数第N个节点" class="headerlink" title="第二题 删除链表的倒数第N个节点"></a>第二题 删除链表的倒数第N个节点</h3><p>这道题是快慢指针，先让快指针移动n+1步，然后快慢指针同时移动，直到快指针到达链表尾部，然后删除慢指针的下一个节点。</p><h3 id="第三题-链表相交"><a href="#第三题-链表相交" class="headerlink" title="第三题 链表相交"></a>第三题 链表相交</h3><p>这道题是双指针法，设置两个指针分别指向两个链表的头节点，然后同时移动两个指针，当一个指针到达链表尾部时，移动到另一个链表的头节点，继续移动，直到两个指针相等或者都为None。这样就能找到链表的交点。然后我自己想的是用梯形的感觉。</p><h3 id="第四题-环形链表II"><a href="#第四题-环形链表II" class="headerlink" title="第四题 环形链表II"></a>第四题 环形链表II</h3><p>这道题是快慢指针，快指针每次移动两步，慢指针每次移动一步，直到快指针追上慢指针，或者快指针到达链表尾部。如果追上了，说明链表有环，然后快指针从链表头开始，慢指针从相遇点开始，每次移动一步，直到再次相遇，相遇点就是环的入口。如果快指针到达链表尾部，说明链表没有环。<br>然后在起点的相遇的位置两个快慢节点改成速度相同，再次相遇的位置就是环的入口。</p><h1 id="我自己的杂谈"><a href="#我自己的杂谈" class="headerlink" title="我自己的杂谈"></a>我自己的杂谈</h1><p>这一周要准备期末考，又要坚持学代码，压力挺大的其实。虽然感觉期末成绩对我没啥用，但是总害怕大家觉得我天天不在宿舍一定天天读书的那种压力，尽管生活没有那么多的观众就是了，但是这种自我暗示也算是让我进行期末准备了，其实我还有很多自己想做的是，想看鱼书，想学数学，当然ctf也是落下好久了，确实娱乐比以前少了，但是效率总是很低，欸，可能也是天赋的缘故吧。其实我本来有很多想说的，但是这个blog公开了，也是怪不好意思的，那就这样吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;week1-复盘&quot;&gt;&lt;a href=&quot;#week1-复盘&quot; class=&quot;headerlink&quot; title=&quot;week1_复盘&quot;&gt;&lt;/a&gt;week1_复盘&lt;/h1&gt;&lt;h2 id=&quot;day1&quot;&gt;&lt;a href=&quot;#day1&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="杂谈" scheme="http://example.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈——复盘" scheme="http://example.com/tags/%E6%9D%82%E8%B0%88%E2%80%94%E2%80%94%E5%A4%8D%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录day-4</title>
    <link href="http://example.com/2025/12/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day4/"/>
    <id>http://example.com/2025/12/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day4/</id>
    <published>2025-12-20T10:25:32.000Z</published>
    <updated>2025-12-21T14:27:54.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><img src="/images/codecrazy/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg" alt="T1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        current = dummy_head</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span> <span class="keyword">and</span> current.<span class="built_in">next</span>.<span class="built_in">next</span>: <span class="comment">#注意先后顺序防止空指针异常</span></span><br><span class="line">            temp1 = current.<span class="built_in">next</span></span><br><span class="line">            temp2 = temp1.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span>.<span class="built_in">next</span> = temp1</span><br><span class="line">            temp1.<span class="built_in">next</span> = temp2</span><br><span class="line">            current = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>有点像昨天的反转列表，也采用了temp指针来保存数据，这道题核心在与两两交换前需要先找到前置节点，并且在循环判断的条件中要注意先后顺序防止空指针异常，当然指针确实有点绕，画个图还是很有帮助的。</p><h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br>进阶：你能尝试使用一趟扫描实现吗？<br><img src="/images/codecrazy/day4-T2.png" alt="T2"></p><blockquote><p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2 输出：[1,2,3,5]<br>  示例 2：<br>  输入：head &#x3D; [1], n &#x3D; 1 输出：[]<br>  示例 3：<br>  输入：head &#x3D; [1,2], n &#x3D; 1 输出：[1]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        slow = dummy_head</span><br><span class="line">        fast = dummy_head</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">and</span> fast :</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>这道题就是快慢指针，要想找到倒数第二个n，那就先让fast指针移动n+1步，然后再让slow指针和fast指针同时移动，直到fast指针指向None，这时候slow指针就指向了倒数第二个n前一个的位置。只有找到倒二的前一个位置，才能进行删除操作。</p><h1 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h1><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。<br>图示两个链表在节点 c1 开始相交：<br><img src="/images/codecrazy/day4-T3-1.png" alt="T3-1"><br>题目数据 保证 整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须 保持其原始结构<br><img src="/images/codecrazy/day4-T3-2.png" alt="T3-2"><br><img src="/images/codecrazy/day4-T3-3.png" alt="T3-3"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        count1 = <span class="number">0</span></span><br><span class="line">        count2 = <span class="number">0</span></span><br><span class="line">        cur1 = headA</span><br><span class="line">        cur2 = headB</span><br><span class="line">        <span class="keyword">while</span> cur1 :</span><br><span class="line">            count1 += <span class="number">1</span></span><br><span class="line">            cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">        cur1 = headA</span><br><span class="line">        <span class="keyword">while</span> cur2:</span><br><span class="line">            count2 += <span class="number">1</span></span><br><span class="line">            cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">        cur2 = headB</span><br><span class="line">        less = count1 - count2</span><br><span class="line">        <span class="keyword">if</span> less &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(less):</span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> cur1 != cur2:</span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur1</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            less = -less</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(less):</span><br><span class="line">                cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> cur1 != cur2:</span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur2</span><br></pre></td></tr></table></figure><p>这是我一开始的想法，先找到两个链表的长度，然后让长的链表先移动长度差的步数，然后再让两个链表同时移动，直到找到相交的节点。<br>实际上我找了非常有意思的解法，就是让两个链表同时移动，当其中一个链表到达末尾时，让它指向另一个链表的头节点，然后继续移动，当两个链表相交时，它们会在相交点相遇。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        cura = headA</span><br><span class="line">        curb = headB</span><br><span class="line">        <span class="keyword">while</span> cura != curb:</span><br><span class="line">            cura = cura.<span class="built_in">next</span> <span class="keyword">if</span> cura <span class="keyword">else</span> headB</span><br><span class="line">            curb = curb.<span class="built_in">next</span> <span class="keyword">if</span> curb <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> cura</span><br></pre></td></tr></table></figure><p>一种类似算梯形面积的方法，把短的和长的拼在一起，简单来说，就是我让两条链表同时移动，当其中一个链表到达末尾时，让它指向另一个链表的头节点，然后继续移动，当两个链表相交时，它们会在相交点相遇。（感觉这么说有点抽象），那就假设相同部分长度c，不相同部分长的a，短的b。第一条先走a+c，第二条走b+c，此时让一再走b，二再走a，这时候两条都是a+b+c，欸刚好到相同长度，并且接下来走的是相同的部分<br><img src="/images/codecrazy/day4-T3-4.jpg" alt="别笑我"></p><h1 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h1><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>说明：不允许修改给定的链表<br><img src="/images/codecrazy/day4-T4.png" alt="T4"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                index = slow</span><br><span class="line">                index_s = head</span><br><span class="line">                <span class="keyword">while</span> index != index_s:</span><br><span class="line">                    index = index.<span class="built_in">next</span></span><br><span class="line">                    index_s = index_s.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>还是快慢指针，快指针每次移动两步，慢指针每次移动一步，当它们相遇时，说明链表有环。（因为不是环肯定不会相遇，快指针早就跑远了）<br>这时候就是判断环的入口了，让一个指针从相遇点开始移动，另一个指针从链表头开始移动，当它们相遇时，就是环的入口。（数学：假设head到环入口是a，环入口到相遇点是b，相遇点到环入口是c，那么快指针走的距离是a+b+n（b+c），慢指针走的距离是a+b，因为快指针每次移动两步，慢指针每次移动一步，所以快指针走的距离是慢指针的两倍，即2(a+b) &#x3D; a+b+n（b+c），所以a &#x3D; （n-1）（b+c）+c，b+c就是一圈，转一圈也会回到起点，所以两个指针再次出发就会在入口相遇）<br>但，实际上不需要index，在python里面直接让慢指针回到起点，然后快指针再相遇的位置继续走，速度和慢指针相同，当它们再次相遇时，就是环的入口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                fast = head</span><br><span class="line">                <span class="keyword">while</span> slow != fast:</span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> fast</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;两两交换链表中的节点&quot;&gt;&lt;/a&gt;两两交换链表中的节点&lt;/h1&gt;&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;br&gt;你不能只是</summary>
      
    
    
    
    <category term="算法学习——链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day3</title>
    <link href="http://example.com/2025/12/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day3/"/>
    <id>http://example.com/2025/12/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day3/</id>
    <published>2025-12-19T14:46:40.000Z</published>
    <updated>2025-12-19T15:14:35.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><blockquote><p>题意：删除链表中等于给定值 val 的所有节点。</p></blockquote><ul><li>示例 1： 输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6 输出：[1,2,3,4,5]</li><li>示例 2： 输入：head &#x3D; [], val &#x3D; 1 输出：[]</li><li>示例 3： 输入：head &#x3D; [7,7,7,7], val &#x3D; 7 输出：[]</li></ul><p>解法一：<strong>虚拟头节点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        cur_node = dummy_head</span><br><span class="line">        <span class="keyword">while</span> cur_node.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> cur_node.<span class="built_in">next</span>.val == val:</span><br><span class="line">                cur_node.<span class="built_in">next</span> = cur_node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span> <span class="comment">#关于为啥要.next,因为这个节点是我们创建的虚拟的，它指向的才是头节点</span></span><br></pre></td></tr></table></figure><p>首先，在删除值为val的节点的时候我们要考虑头节点的情况，而且如果连续的多个节点等于val且在头节点的后面的时候，我们要用循环删去，总而言之，这种分类讨论的方法比较麻烦，为了解决这个问题我们可以采用虚拟头结点的方式。<br>创建虚拟头节点dummy_head，指向头节点head。<br>然后设置一个指针current，指向dummy_head。<br>遍历链表，当current.next的值等于val时，删除current.next节点，否则current指针后移。（循环条件用current.next，到达尾端的时候指向None，循环结束）<br>最后返回dummy_head.next，因为dummy_head本身是我们创造的虚拟的，而dummy_head.next才是真正的头节点。<br>解法二：<strong>不使用虚拟头节点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head.val == val :</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">and</span> current.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">while</span> current.<span class="built_in">next</span> <span class="keyword">and</span> current.<span class="built_in">next</span>.val == val:</span><br><span class="line">                current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>我只说我最开始没考虑的情况，例如111123，假设val&#x3D;1，连续的1，当时我是用if的情况，条件满足头节点指向下一个，但是如果连续的val在头节点的后面，就会出错。<br>后面1233244441111232，我又用if，还是没删干净，我粘一下我的错误的代码，大家以此为戒，也可以看看我的错误代码思考我的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">and</span> current.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> current.val == val:</span><br><span class="line">                head = current.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> current.<span class="built_in">next</span>.val == val:</span><br><span class="line">                current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head     </span><br></pre></td></tr></table></figure><h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><blockquote><p>题意：<br>  在链表类中实现这些功能：</p></blockquote><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。<br><img src="/images/codecrazy/day3-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-T2png.png" alt="T2样例"></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val=<span class="number">0</span>,<span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):   </span><br><span class="line">        <span class="variable language_">self</span>.dummy_node = ListNode()</span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="variable language_">self</span>.size <span class="keyword">or</span> index &lt; <span class="number">0</span>:   <span class="comment">#为啥不能取等，类似数组下标从零开始</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        current = <span class="variable language_">self</span>.dummy_node.<span class="built_in">next</span> <span class="comment"># 有效节点从虚拟节点下一个开始</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):<span class="comment">#这里循环用来找目标，链表的查找是要遍历的，不像数组用下标就行</span></span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> current.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.dummy_node.<span class="built_in">next</span> = ListNode(val,<span class="variable language_">self</span>.dummy_node.<span class="built_in">next</span>) <span class="comment">#从右往左，先创建新的节点，且新节点的下个节点指向原来虚拟头的next，然后再让虚拟头指向新节点</span></span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        current = <span class="variable language_">self</span>.dummy_node</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = ListNode(val)</span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt; <span class="variable language_">self</span>.size:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">        current = <span class="variable language_">self</span>.dummy_node</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = ListNode(val,current.<span class="built_in">next</span>)</span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= <span class="variable language_">self</span>.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        current = <span class="variable language_">self</span>.dummy_node</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我做过卡码网的链表的基本操作，期末考完我把卡码网我做过的题也记录到这个blog里<br>额，就是index合法性检查，然后增加删除的基本操作</p><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>题意：反转一个单链表。</p><blockquote><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>方法一：<strong>双指针法</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            temp = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = current</span><br><span class="line">            current = temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><p>通过设置当前指针，pre指针来实现，每次循环都让当前指针指向前一个节点，然后pre指针移动到当前指针，当前指针移动到下一个节点，直到当前指针为空，返回pre指针。但是只是这样会丢失current.next的节点，因此需要temp指针来暂存current.next的节点，然后让current指针指向前一个节点，pre指针移动到current指针，current指针移动到temp指针，直到current指针为空，返回pre指针。</p><p>方法二：<strong>递归法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.reverse(head,<span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self,current,pre</span>) :</span><br><span class="line">        <span class="keyword">if</span> current == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line">        temp = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = pre</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.reverse(temp,current)</span><br></pre></td></tr></table></figure><p>实话实话，让我再写一遍我写不出递归，我再捣鼓捣鼓吧，视频看懂了但又好像没看懂</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;移除链表元素&quot;&gt;&lt;a href=&quot;#移除链表元素&quot; class=&quot;headerlink&quot; title=&quot;移除链表元素&quot;&gt;&lt;/a&gt;移除链表元素&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题意：删除链表中等于给定值 val 的所有节点。&lt;/p&gt;
&lt;/blockquote</summary>
      
    
    
    
    <category term="算法学习——链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day2</title>
    <link href="http://example.com/2025/12/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day2/"/>
    <id>http://example.com/2025/12/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day2/</id>
    <published>2025-12-18T09:42:23.000Z</published>
    <updated>2025-12-18T10:13:03.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p></blockquote><p>示例：</p><ul><li>输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</li><li>输出：2</li><li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; target &lt;&#x3D; 10^9</li><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span>  <span class="comment">#左闭右闭</span></span><br><span class="line">        min_nums = length + <span class="number">1</span></span><br><span class="line">        sum_n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; length:</span><br><span class="line">            sum_n += nums[right]</span><br><span class="line">            <span class="keyword">while</span> sum_n &gt;= target:</span><br><span class="line">                min_nums = <span class="built_in">min</span>(right - left + <span class="number">1</span>,min_nums)</span><br><span class="line">                sum_n -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min_nums <span class="keyword">if</span> min_nums != length + <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这道题可以用<strong>滑动窗口</strong>的方式来实现<br>设置两个指针left和right，分别指向子数组的左右边界。<br>初始的时候设置两个指针都是0，即指向数组的第一个元素。<br>然后通过移动右指针来扩大子数组的大小直到子数组的和大于等于target。<br>这个时候我们得到的就是在起点为0条件下获得的最小子数组长度。<br>因此我们可以移动左指针的位置，一方面可以缩小子数组的长度，另一方面也是调整子数组的起点。<br>如果减去初始的左指针指向的元素后子数组的和仍然大于等于target，那么我们就可以继续移动左指针，直到子数组的和小于target，当然在这过程中要更新最小数组长度。<br>如果子数组的和小于target了那我们就继续移动右指针，扩大子数组的大小。重复这个过程到循环结束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        min_nums = length + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            sum_n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,length):</span><br><span class="line">                sum_n += nums[j]</span><br><span class="line">                <span class="keyword">if</span> sum_n &gt;= target:</span><br><span class="line">                    min_nums = <span class="built_in">min</span>(min_nums,j-i+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> min_nums <span class="keyword">if</span> min_nums != length + <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>暴力解法就是用两个for循环，一个for循环遍历数组的每个元素，另一个for循环遍历从当前元素开始的所有子数组，计算子数组的和是否大于等于target。超时了就是了</p><h1 id="螺旋矩阵II"><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h1><blockquote><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p></blockquote><p>示例:</p><ul><li>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]<br><img src="/images/day2_code/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day2-T2.png" alt="题目示例"></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums=[[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment"># 创建一个n*n的空列表</span></span><br><span class="line">        start_x,start_y = <span class="number">0</span>,<span class="number">0</span> <span class="comment">#每一圈的起始位置，注意是每一圈的，因此转完一圈后起始位置的x、y都要加一 ,x表示行数，y表示列数</span></span><br><span class="line">        count = <span class="number">1</span> <span class="comment">#表示转到哪个数字</span></span><br><span class="line">        offset = <span class="number">1</span> <span class="comment">#偏移量，其实我觉得也是圈数</span></span><br><span class="line">        <span class="keyword">while</span> n // <span class="number">2</span> &gt; offset-<span class="number">1</span>: <span class="comment">#转一圈消耗两层啦</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(start_y,n-offset):</span><br><span class="line">                nums[start_x][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_x,n-offset):</span><br><span class="line">                nums[i][n-offset] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-offset,start_y,-<span class="number">1</span>):</span><br><span class="line">                nums[n-offset][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-offset,start_x,-<span class="number">1</span>):</span><br><span class="line">                nums[i][start_y] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            start_x += <span class="number">1</span></span><br><span class="line">            start_y += <span class="number">1</span></span><br><span class="line">            offset += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n %<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            nums[n//<span class="number">2</span>][n//<span class="number">2</span>] = count</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>这道题目的核心在处理边界问题，特别在顶点的取否上，这里我们采用左闭右开的方式，然后明白转一圈消耗两层，然后每一圈更新起始位置和偏移量。</p><p>扩展题看了思路，但是我自己还没憋出来，等晚上再试试</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;长度最小的子数组&quot;&gt;&lt;a href=&quot;#长度最小的子数组&quot; class=&quot;headerlink&quot; title=&quot;长度最小的子数组&quot;&gt;&lt;/a&gt;长度最小的子数组&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满</summary>
      
    
    
    
    <category term="算法学习——数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录_day1</title>
    <link href="http://example.com/2025/12/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day1/"/>
    <id>http://example.com/2025/12/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day1/</id>
    <published>2025-12-17T15:02:58.000Z</published>
    <updated>2025-12-18T10:17:27.758Z</updated>
    
    <content type="html"><![CDATA[<p>可恶，今天有点拖拖拉拉的，博客只能水一点了</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><ul><li>示例 1:<br> 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9<br> 输出: 4<br> 解释: 9 出现在 nums 中并且下标为 4<br> 示例 2:</li></ul><p> 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2<br> 输出: -1<br> 解释: 2 不存在 nums 中因此返回 -1<br> 提示：</p><p> 你可以假设 nums 中的所有元素是不重复的。<br> n 将在 [1, 10000]之间。<br> nums 的每个元素都将在 [-9999, 9999]之间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">right=<span class="built_in">len</span>(nums)</span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[middle]:</span><br><span class="line">                right = middle</span><br><span class="line">            <span class="keyword">elif</span> target &gt; nums[middle]:</span><br><span class="line">                left  = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>二分查找有点类似数学的二分法，来简化查找的次数，一个是左闭右闭，right就是指向真实的下标，然后更新的左右都不取到中间值，另一个是<br>左闭右开，right指向数组的数量（实际加一），更新的右边都取到中间值。</p><h1 id="移除数组"><a href="#移除数组" class="headerlink" title="移除数组"></a>移除数组</h1><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><ul><li>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</li></ul><p>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length=<span class="built_in">len</span>(nums)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; length:</span><br><span class="line">            <span class="keyword">if</span> nums[i]  == val:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,length-<span class="number">1</span>):</span><br><span class="line">                    nums[j]=nums[j+<span class="number">1</span>]</span><br><span class="line">                length -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure><p>这个是暴力解法，双层循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span>  nums[fast] != val:</span><br><span class="line">                nums[slow]=nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><p>这个是快慢指针<br>讲一下思路，简单来说就是，设置两个指针，快的指针用来遍历原来的数组，慢的就用来表示新的数组的下标，然后比较快指针对应的和val一不一样，留下不一样的，一样的就跳过，最后返回慢指针的下标就是新数组的长度</p><h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><ul><li>示例 1：<br> 输入：nums &#x3D; [-4,-1,0,3,10]<br> 输出：[0,1,9,16,100]<br> 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</li></ul><p> 示例 2：<br> 输入：nums &#x3D; [-7,-3,2,3,11]<br> 输出：[4,9,9,49,121]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s1 = <span class="number">0</span></span><br><span class="line">        k= s2 = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        nums_list=[<span class="number">0</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> s1 &lt;= s2:</span><br><span class="line">            <span class="keyword">if</span> nums[s1]**<span class="number">2</span> &gt; nums[s2]**<span class="number">2</span>:</span><br><span class="line">                nums_list[k] = nums[s1]**<span class="number">2</span></span><br><span class="line">                s1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                nums_list[k] = nums[s2]**<span class="number">2</span> </span><br><span class="line">                s2 -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums_list</span><br></pre></td></tr></table></figure><p>这个是双指针的方法，设置两个指针，一个指向数组的头，一个指向数组的尾，然后比较两个指针指向的元素的平方，把大的那个放到新数组的最后面，然后相应的指针向中间移动，最后返回新数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">sorted</span>(x*x <span class="keyword">for</span> x <span class="keyword">in</span> nums)</span><br></pre></td></tr></table></figure><p>无需多言，排序加推导式</p><p>来不及了，要回宿舍了，下次不能拖拖拉拉了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可恶，今天有点拖拖拉拉的，博客只能水一点了&lt;/p&gt;
&lt;h1 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h1&gt;&lt;p&gt;给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值</summary>
      
    
    
    
    <category term="算法学习——数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>python_入门练习</title>
    <link href="http://example.com/2025/12/09/python-%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0/"/>
    <id>http://example.com/2025/12/09/python-%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0/</id>
    <published>2025-12-09T13:26:24.000Z</published>
    <updated>2025-12-09T15:07:00.025Z</updated>
    
    <content type="html"><![CDATA[<p>  不得不说我的代码能力太弱了，只能先从简单的开始了。</p><h1 id="1-A-B问题I"><a href="#1-A-B问题I" class="headerlink" title="1.A+B问题I"></a>1.A+B问题I</h1><p>题目描述</p><blockquote><p>你的任务是计算a+b。<br>输入描述<br>输入包含一系列的a和b对，通过空格隔开。一对a和b占一行。<br>输出描述<br>如对于输入中的第二对a和b，<br>  在输出中它们的和应该也在第二行。<br>输入示例<br>1 2<br>  3 4<br>输出示例<br>3<br>  7</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a,b = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">        <span class="built_in">print</span>(a+b)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>好吧我承认我的代码能力是极差的。<br>第一个问题如何保证一直接受用户输入，首先就要用一个一直循环的while语句，直到没有输入后跳出循环。可以用if判断啥时候输入为空，也可以用try except保证输入的合法性。<br>然后就是map函数，这个函数的核心是对序列里面的每一个元素批量应用同一个处理规则，这里是将输入的字符串转换为整数。<br>这里的.split()函数是将输入的字符串按照空格隔开，返回一个列表。<br>哦，补充一下input函数输入的内容是字符串。</p><h1 id="2-A-B问题II"><a href="#2-A-B问题II" class="headerlink" title="2.A+B问题II"></a>2.A+B问题II</h1><p>题目描述</p><blockquote><p>计算a+b，但输入方式有所改变。<br>输入描述<br>第一行是一个整数N，表示后面会有N行a和b，通过空格隔开。<br>输出描述<br>对于输入的每对a和b，你需要在相应的行输出a、b的和。<br>  如第二对a和b，对应的和也输出在第二行。<br>输入示例<br>2<br>  2 4<br>  9 21<br>输出示例<br>6<br>  30<br>提示信息<br>注意，测试数据不仅仅一组。也就是说，会持续输入N以及后面的a和b</p></blockquote><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>这道题和上一道题的区别在于，上一道题是一直接受用户输入，直到没有输入为止。<br>这道题是先接受一个整数N，然后接受N行a和b，输出N行a+b。而且分组输入导致每一块都有组数N，就不能像上一道题一样无脑接收输入了。<br>补充知识：<br>.strip()函数是去掉字符串首尾的空格，包括换行符、制表符等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        N = <span class="built_in">int</span>(<span class="built_in">input</span>().strip())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            a,b = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">            <span class="built_in">print</span>(a+b)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    N=<span class="built_in">int</span>(line.strip())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        a,b=<span class="built_in">map</span>(<span class="built_in">int</span>,sys.stdin.readline().strip().split())</span><br><span class="line">        <span class="built_in">print</span>(a+b)</span><br></pre></td></tr></table></figure><blockquote><p>导入sys模块后，通过<code>for line in sys.stdin</code>启动外层循环——这个循环的作用是<strong>逐个读取输入中“每组数据的开头行（即N所在的行）”</strong>。每次外层循环执行时：</p></blockquote><ol><li><p>首先处理当前读取到的<code>line</code>：这行内容是当前组的分组信息（整数N），通过<code>int(line.strip())</code>转成整数后，明确“这一组需要处理N对a和b”。</p></li><li><p>接着启动内层循环<code>for _ in range(N)</code>：这个循环的作用是<strong>主动读取当前组内的N行a和b数据</strong>。<br>每次内层循环会通过<code>sys.stdin.readline()</code>读取一行新的输入（这行是a和b，用空格分隔），经过<code>strip()</code>清理空白、<code>split()</code>拆分、<code>map(int, ...)</code>转整数后，得到a和b的值，计算并输出它们的和。<br>内层循环会严格执行N次，确保当前组的N对a和b全部被处理。</p></li><li><p>内层循环结束后，外层循环才会继续执行：此时外层循环会自动读取下一行输入，而这一行恰好是“下一组数据的N”（因为内层循环已经主动读完了上一组的N行a和b，不会让外层循环误读这些行）。</p></li></ol><p>整个过程中，外层循环负责“按组拆分输入”（找到每一组的N），内层循环负责“按组内数量处理数据”（读完N对a和b），两层循环分工配合，既不会漏读数据，也不会错把a和b的行当成N处理，最终完美实现“持续处理多组N及对应a+b”的题目要求。<br>sys.stdin():内置的标准输入流对象，用于从控制台或其他输入源读取数据。<br>sys.stdin.readline()：读取输入的一行,从stdin中读取一行数据,包括换行符。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  不得不说我的代码能力太弱了，只能先从简单的开始了。&lt;/p&gt;
&lt;h1 id=&quot;1-A-B问题I&quot;&gt;&lt;a href=&quot;#1-A-B问题I&quot; class=&quot;headerlink&quot; title=&quot;1.A+B问题I&quot;&gt;&lt;/a&gt;1.A+B问题I&lt;/h1&gt;&lt;p&gt;题目描述&lt;/p&gt;
&lt;b</summary>
      
    
    
    
    
    <category term="入门算法" scheme="http://example.com/tags/%E5%85%A5%E9%97%A8%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_1</title>
    <link href="http://example.com/2025/12/01/hello-world/"/>
    <id>http://example.com/2025/12/01/hello-world/</id>
    <published>2025-12-01T03:32:38.765Z</published>
    <updated>2025-12-21T14:27:06.074Z</updated>
    
    <content type="html"><![CDATA[<p>  从这篇文章开始，我将会将我在算法练习中的所想和收获记录下来。</p><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br> 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br> 你可以按任意顺序返回答案。<br><img src="/images/post1/1.png" alt="题目输出案例"></p><h2 id="1-1-思路1"><a href="#1-1-思路1" class="headerlink" title="1.1 思路1"></a>1.1 思路1</h2><p>  思路1是最简单的思路，就是遍历数组，对于每个元素，都去数组中查找是否有目标值减去当前值的元素。<br>  时间复杂度为O(n^2)，空间复杂度为O(1)。<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">          j = target - i</span><br><span class="line">          start_index = nums.index(i)</span><br><span class="line">          next_index = start_index + <span class="number">1</span> </span><br><span class="line">          nums_new = nums[next_index:]<span class="comment">#对原数组进行切片，去掉当前元素之前的元素</span></span><br><span class="line">          <span class="keyword">if</span> j <span class="keyword">in</span> nums_new:</span><br><span class="line">              <span class="keyword">return</span> [start_index,next_index+nums_new.index(j)]</span><br></pre></td></tr></table></figure></p><h2 id="1-2-思路2-哈希表"><a href="#1-2-思路2-哈希表" class="headerlink" title="1.2 思路2(哈希表)"></a>1.2 思路2(哈希表)</h2><p>  思路2是利用哈希表来解决问题。我们遍历数组，对于每个元素，都去哈希表中查找是否有目标值减去当前值的元素。<br>  如果有，就返回当前元素的下标和哈希表中目标值减去当前值的元素的下标。<br>  如果没有，就将当前元素和下标加入哈希表中。<br>  时间复杂度为O(n)，空间复杂度为O(n)。<em><strong>用空间换时间</strong></em><br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">      <span class="built_in">dir</span>=&#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)): <span class="comment">#遍历数组</span></span><br><span class="line">          <span class="keyword">if</span> target-nums[i] <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dir</span>: <span class="comment">#如果目标值减去当前值不在字典中</span></span><br><span class="line">              <span class="built_in">dir</span>[nums[i]] = i</span><br><span class="line">          <span class="keyword">else</span> :</span><br><span class="line">              <span class="keyword">return</span> [<span class="built_in">dir</span>[target-nums[i]],i]</span><br></pre></td></tr></table></figure></p><h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h1><p>  给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>  回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>  例如，121 是回文，而 123 不是。(负数不是回文数)</p><h1 id="9-1-思路1"><a href="#9-1-思路1" class="headerlink" title="9.1 思路1"></a>9.1 思路1</h1><p>  思路1是将整数%10，得到最后一位数，然后将整数&#x2F;&#x2F;10，去掉最后一位数，重复这个过程，直到整数变成0。<br>  每次得到的数都乘以10，最后得到的数就是整数的倒序。<br>  时间复杂度为O(logn)，空间复杂度为O(1)。<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x&lt;<span class="number">0</span>):</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">      <span class="keyword">else</span> :</span><br><span class="line">          a = x</span><br><span class="line">          num = <span class="number">0</span></span><br><span class="line">          <span class="keyword">while</span>(a!=<span class="number">0</span>):</span><br><span class="line">              num =<span class="number">10</span> * num + a % <span class="number">10</span></span><br><span class="line">              a = a // <span class="number">10</span></span><br><span class="line">          <span class="keyword">if</span> (x == num):</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  从这篇文章开始，我将会将我在算法练习中的所想和收获记录下来。&lt;/p&gt;
&lt;h1 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;1. 两数之和&lt;/h1&gt;&lt;p&gt; 给定一个整数数组 nu</summary>
      
    
    
    
    <category term="算法学习——哈希" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
