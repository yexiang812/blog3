<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yeye 想变强</title>
  
  <subtitle>技术&amp;生活blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-12-20T11:24:17.796Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yeyeyefirst</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码随想录day-4</title>
    <link href="http://example.com/2025/12/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day4/"/>
    <id>http://example.com/2025/12/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day4/</id>
    <published>2025-12-20T10:25:32.000Z</published>
    <updated>2025-12-20T11:24:17.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><img src="/images/codecrazy/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg" alt="T1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        current = dummy_head</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span> <span class="keyword">and</span> current.<span class="built_in">next</span>.<span class="built_in">next</span>: <span class="comment">#注意先后顺序防止空指针异常</span></span><br><span class="line">            temp1 = current.<span class="built_in">next</span></span><br><span class="line">            temp2 = temp1.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span>.<span class="built_in">next</span> = temp1</span><br><span class="line">            temp1.<span class="built_in">next</span> = temp2</span><br><span class="line">            current = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>有点像昨天的反转列表，也采用了temp指针来保存数据，这道题核心在与两两交换前需要先找到前置节点，并且在循环判断的条件中要注意先后顺序防止空指针异常，当然指针确实有点绕，画个图还是很有帮助的。</p><h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br>进阶：你能尝试使用一趟扫描实现吗？<br><img src="/images/codecrazy/day4-T2.png" alt="T2"></p><blockquote><p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2 输出：[1,2,3,5]<br>  示例 2：<br>  输入：head &#x3D; [1], n &#x3D; 1 输出：[]<br>  示例 3：<br>  输入：head &#x3D; [1,2], n &#x3D; 1 输出：[1]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        slow = dummy_head</span><br><span class="line">        fast = dummy_head</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">and</span> fast :</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>这道题就是快慢指针，要想找到倒数第二个n，那就先让fast指针移动n+1步，然后再让slow指针和fast指针同时移动，直到fast指针指向None，这时候slow指针就指向了倒数第二个n前一个的位置。只有找到倒二的前一个位置，才能进行删除操作。</p><h1 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h1><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。<br>图示两个链表在节点 c1 开始相交：<br><img src="/images/codecrazy/day4-T3-1.png" alt="T3-1"><br>题目数据 保证 整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须 保持其原始结构<br><img src="/images/codecrazy/day4-T3-2.png" alt="T3-2"><br><img src="/images/codecrazy/day4-T3-3.jpg" alt="T3-3"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        count1 = <span class="number">0</span></span><br><span class="line">        count2 = <span class="number">0</span></span><br><span class="line">        cur1 = headA</span><br><span class="line">        cur2 = headB</span><br><span class="line">        <span class="keyword">while</span> cur1 :</span><br><span class="line">            count1 += <span class="number">1</span></span><br><span class="line">            cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">        cur1 = headA</span><br><span class="line">        <span class="keyword">while</span> cur2:</span><br><span class="line">            count2 += <span class="number">1</span></span><br><span class="line">            cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">        cur2 = headB</span><br><span class="line">        less = count1 - count2</span><br><span class="line">        <span class="keyword">if</span> less &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(less):</span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> cur1 != cur2:</span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur1</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            less = -less</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(less):</span><br><span class="line">                cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> cur1 != cur2:</span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> cur2</span><br></pre></td></tr></table></figure><p>这是我一开始的想法，先找到两个链表的长度，然后让长的链表先移动长度差的步数，然后再让两个链表同时移动，直到找到相交的节点。<br>实际上我找了非常有意思的解法，就是让两个链表同时移动，当其中一个链表到达末尾时，让它指向另一个链表的头节点，然后继续移动，当两个链表相交时，它们会在相交点相遇。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        cura = headA</span><br><span class="line">        curb = headB</span><br><span class="line">        <span class="keyword">while</span> cura != curb:</span><br><span class="line">            cura = cura.<span class="built_in">next</span> <span class="keyword">if</span> cura <span class="keyword">else</span> headB</span><br><span class="line">            curb = curb.<span class="built_in">next</span> <span class="keyword">if</span> curb <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> cura</span><br></pre></td></tr></table></figure><p>一种类似算梯形面积的方法，把短的和长的拼在一起，简单来说，就是我让两条链表同时移动，当其中一个链表到达末尾时，让它指向另一个链表的头节点，然后继续移动，当两个链表相交时，它们会在相交点相遇。（感觉这么说有点抽象），那就假设相同部分长度c，不相同部分长的a，短的b。第一条先走a+c，第二条走b+c，此时让一再走b，二再走a，这时候两条都是a+b+c，欸刚好到相同长度，并且接下来走的是相同的部分<br><img src="/images/codecrazy/day4-T3-4.jpg" alt="别笑我"></p><h1 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h1><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>说明：不允许修改给定的链表<br><img src="/images/codecrazy/day4-T4.png" alt="T4"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                index = slow</span><br><span class="line">                index_s = head</span><br><span class="line">                <span class="keyword">while</span> index != index_s:</span><br><span class="line">                    index = index.<span class="built_in">next</span></span><br><span class="line">                    index_s = index_s.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>还是快慢指针，快指针每次移动两步，慢指针每次移动一步，当它们相遇时，说明链表有环。（因为不是环肯定不会相遇，快指针早就跑远了）<br>这时候就是判断环的入口了，让一个指针从相遇点开始移动，另一个指针从链表头开始移动，当它们相遇时，就是环的入口。（数学：假设head到环入口是a，环入口到相遇点是b，相遇点到环入口是c，那么快指针走的距离是a+b+n（b+c），慢指针走的距离是a+b，因为快指针每次移动两步，慢指针每次移动一步，所以快指针走的距离是慢指针的两倍，即2(a+b) &#x3D; a+b+n（b+c），所以a &#x3D; （n-1）（b+c）+c，b+c就是一圈，转一圈也会回到起点，所以两个指针再次出发就会在入口相遇）<br>但，实际上不需要index，在python里面直接让慢指针回到起点，然后快指针再相遇的位置继续走，速度和慢指针相同，当它们再次相遇时，就是环的入口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                fast = head</span><br><span class="line">                <span class="keyword">while</span> slow != fast:</span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> fast</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;两两交换链表中的节点&quot;&gt;&lt;/a&gt;两两交换链表中的节点&lt;/h1&gt;&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;br&gt;你不能只是</summary>
      
    
    
    
    <category term="算法学习——链表、快慢指针" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E3%80%81%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day3</title>
    <link href="http://example.com/2025/12/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day3/"/>
    <id>http://example.com/2025/12/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day3/</id>
    <published>2025-12-19T14:46:40.000Z</published>
    <updated>2025-12-19T15:14:35.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><blockquote><p>题意：删除链表中等于给定值 val 的所有节点。</p></blockquote><ul><li>示例 1： 输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6 输出：[1,2,3,4,5]</li><li>示例 2： 输入：head &#x3D; [], val &#x3D; 1 输出：[]</li><li>示例 3： 输入：head &#x3D; [7,7,7,7], val &#x3D; 7 输出：[]</li></ul><p>解法一：<strong>虚拟头节点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        cur_node = dummy_head</span><br><span class="line">        <span class="keyword">while</span> cur_node.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> cur_node.<span class="built_in">next</span>.val == val:</span><br><span class="line">                cur_node.<span class="built_in">next</span> = cur_node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span> <span class="comment">#关于为啥要.next,因为这个节点是我们创建的虚拟的，它指向的才是头节点</span></span><br></pre></td></tr></table></figure><p>首先，在删除值为val的节点的时候我们要考虑头节点的情况，而且如果连续的多个节点等于val且在头节点的后面的时候，我们要用循环删去，总而言之，这种分类讨论的方法比较麻烦，为了解决这个问题我们可以采用虚拟头结点的方式。<br>创建虚拟头节点dummy_head，指向头节点head。<br>然后设置一个指针current，指向dummy_head。<br>遍历链表，当current.next的值等于val时，删除current.next节点，否则current指针后移。（循环条件用current.next，到达尾端的时候指向None，循环结束）<br>最后返回dummy_head.next，因为dummy_head本身是我们创造的虚拟的，而dummy_head.next才是真正的头节点。<br>解法二：<strong>不使用虚拟头节点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head.val == val :</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">and</span> current.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">while</span> current.<span class="built_in">next</span> <span class="keyword">and</span> current.<span class="built_in">next</span>.val == val:</span><br><span class="line">                current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>我只说我最开始没考虑的情况，例如111123，假设val&#x3D;1，连续的1，当时我是用if的情况，条件满足头节点指向下一个，但是如果连续的val在头节点的后面，就会出错。<br>后面1233244441111232，我又用if，还是没删干净，我粘一下我的错误的代码，大家以此为戒，也可以看看我的错误代码思考我的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">and</span> current.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> current.val == val:</span><br><span class="line">                head = current.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> current.<span class="built_in">next</span>.val == val:</span><br><span class="line">                current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head     </span><br></pre></td></tr></table></figure><h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><blockquote><p>题意：<br>  在链表类中实现这些功能：</p></blockquote><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。<br><img src="/images/codecrazy/day3-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-T2png.png" alt="T2样例"></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val=<span class="number">0</span>,<span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):   </span><br><span class="line">        <span class="variable language_">self</span>.dummy_node = ListNode()</span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="variable language_">self</span>.size <span class="keyword">or</span> index &lt; <span class="number">0</span>:   <span class="comment">#为啥不能取等，类似数组下标从零开始</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        current = <span class="variable language_">self</span>.dummy_node.<span class="built_in">next</span> <span class="comment"># 有效节点从虚拟节点下一个开始</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):<span class="comment">#这里循环用来找目标，链表的查找是要遍历的，不像数组用下标就行</span></span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> current.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.dummy_node.<span class="built_in">next</span> = ListNode(val,<span class="variable language_">self</span>.dummy_node.<span class="built_in">next</span>) <span class="comment">#从右往左，先创建新的节点，且新节点的下个节点指向原来虚拟头的next，然后再让虚拟头指向新节点</span></span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        current = <span class="variable language_">self</span>.dummy_node</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = ListNode(val)</span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt; <span class="variable language_">self</span>.size:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">        current = <span class="variable language_">self</span>.dummy_node</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = ListNode(val,current.<span class="built_in">next</span>)</span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= <span class="variable language_">self</span>.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        current = <span class="variable language_">self</span>.dummy_node</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我做过卡码网的链表的基本操作，期末考完我把卡码网我做过的题也记录到这个blog里<br>额，就是index合法性检查，然后增加删除的基本操作</p><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>题意：反转一个单链表。</p><blockquote><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>方法一：<strong>双指针法</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            temp = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = current</span><br><span class="line">            current = temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><p>通过设置当前指针，pre指针来实现，每次循环都让当前指针指向前一个节点，然后pre指针移动到当前指针，当前指针移动到下一个节点，直到当前指针为空，返回pre指针。但是只是这样会丢失current.next的节点，因此需要temp指针来暂存current.next的节点，然后让current指针指向前一个节点，pre指针移动到current指针，current指针移动到temp指针，直到current指针为空，返回pre指针。</p><p>方法二：<strong>递归法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.reverse(head,<span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self,current,pre</span>) :</span><br><span class="line">        <span class="keyword">if</span> current == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line">        temp = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = pre</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.reverse(temp,current)</span><br></pre></td></tr></table></figure><p>实话实话，让我再写一遍我写不出递归，我再捣鼓捣鼓吧，视频看懂了但又好像没看懂</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;移除链表元素&quot;&gt;&lt;a href=&quot;#移除链表元素&quot; class=&quot;headerlink&quot; title=&quot;移除链表元素&quot;&gt;&lt;/a&gt;移除链表元素&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题意：删除链表中等于给定值 val 的所有节点。&lt;/p&gt;
&lt;/blockquote</summary>
      
    
    
    
    <category term="算法学习——链表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day2</title>
    <link href="http://example.com/2025/12/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day2/"/>
    <id>http://example.com/2025/12/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day2/</id>
    <published>2025-12-18T09:42:23.000Z</published>
    <updated>2025-12-18T10:13:03.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p></blockquote><p>示例：</p><ul><li>输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</li><li>输出：2</li><li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; target &lt;&#x3D; 10^9</li><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span>  <span class="comment">#左闭右闭</span></span><br><span class="line">        min_nums = length + <span class="number">1</span></span><br><span class="line">        sum_n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; length:</span><br><span class="line">            sum_n += nums[right]</span><br><span class="line">            <span class="keyword">while</span> sum_n &gt;= target:</span><br><span class="line">                min_nums = <span class="built_in">min</span>(right - left + <span class="number">1</span>,min_nums)</span><br><span class="line">                sum_n -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min_nums <span class="keyword">if</span> min_nums != length + <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这道题可以用<strong>滑动窗口</strong>的方式来实现<br>设置两个指针left和right，分别指向子数组的左右边界。<br>初始的时候设置两个指针都是0，即指向数组的第一个元素。<br>然后通过移动右指针来扩大子数组的大小直到子数组的和大于等于target。<br>这个时候我们得到的就是在起点为0条件下获得的最小子数组长度。<br>因此我们可以移动左指针的位置，一方面可以缩小子数组的长度，另一方面也是调整子数组的起点。<br>如果减去初始的左指针指向的元素后子数组的和仍然大于等于target，那么我们就可以继续移动左指针，直到子数组的和小于target，当然在这过程中要更新最小数组长度。<br>如果子数组的和小于target了那我们就继续移动右指针，扩大子数组的大小。重复这个过程到循环结束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        min_nums = length + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            sum_n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,length):</span><br><span class="line">                sum_n += nums[j]</span><br><span class="line">                <span class="keyword">if</span> sum_n &gt;= target:</span><br><span class="line">                    min_nums = <span class="built_in">min</span>(min_nums,j-i+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> min_nums <span class="keyword">if</span> min_nums != length + <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>暴力解法就是用两个for循环，一个for循环遍历数组的每个元素，另一个for循环遍历从当前元素开始的所有子数组，计算子数组的和是否大于等于target。超时了就是了</p><h1 id="螺旋矩阵II"><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h1><blockquote><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p></blockquote><p>示例:</p><ul><li>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]<br><img src="/images/day2_code/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day2-T2.png" alt="题目示例"></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums=[[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment"># 创建一个n*n的空列表</span></span><br><span class="line">        start_x,start_y = <span class="number">0</span>,<span class="number">0</span> <span class="comment">#每一圈的起始位置，注意是每一圈的，因此转完一圈后起始位置的x、y都要加一 ,x表示行数，y表示列数</span></span><br><span class="line">        count = <span class="number">1</span> <span class="comment">#表示转到哪个数字</span></span><br><span class="line">        offset = <span class="number">1</span> <span class="comment">#偏移量，其实我觉得也是圈数</span></span><br><span class="line">        <span class="keyword">while</span> n // <span class="number">2</span> &gt; offset-<span class="number">1</span>: <span class="comment">#转一圈消耗两层啦</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(start_y,n-offset):</span><br><span class="line">                nums[start_x][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_x,n-offset):</span><br><span class="line">                nums[i][n-offset] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-offset,start_y,-<span class="number">1</span>):</span><br><span class="line">                nums[n-offset][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-offset,start_x,-<span class="number">1</span>):</span><br><span class="line">                nums[i][start_y] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            start_x += <span class="number">1</span></span><br><span class="line">            start_y += <span class="number">1</span></span><br><span class="line">            offset += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n %<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            nums[n//<span class="number">2</span>][n//<span class="number">2</span>] = count</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>这道题目的核心在处理边界问题，特别在顶点的取否上，这里我们采用左闭右开的方式，然后明白转一圈消耗两层，然后每一圈更新起始位置和偏移量。</p><p>扩展题看了思路，但是我自己还没憋出来，等晚上再试试</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;长度最小的子数组&quot;&gt;&lt;a href=&quot;#长度最小的子数组&quot; class=&quot;headerlink&quot; title=&quot;长度最小的子数组&quot;&gt;&lt;/a&gt;长度最小的子数组&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满</summary>
      
    
    
    
    <category term="算法学习——数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录_day1</title>
    <link href="http://example.com/2025/12/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day1/"/>
    <id>http://example.com/2025/12/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day1/</id>
    <published>2025-12-17T15:02:58.000Z</published>
    <updated>2025-12-18T10:17:27.758Z</updated>
    
    <content type="html"><![CDATA[<p>可恶，今天有点拖拖拉拉的，博客只能水一点了</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><ul><li>示例 1:<br> 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9<br> 输出: 4<br> 解释: 9 出现在 nums 中并且下标为 4<br> 示例 2:</li></ul><p> 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2<br> 输出: -1<br> 解释: 2 不存在 nums 中因此返回 -1<br> 提示：</p><p> 你可以假设 nums 中的所有元素是不重复的。<br> n 将在 [1, 10000]之间。<br> nums 的每个元素都将在 [-9999, 9999]之间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">right=<span class="built_in">len</span>(nums)</span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[middle]:</span><br><span class="line">                right = middle</span><br><span class="line">            <span class="keyword">elif</span> target &gt; nums[middle]:</span><br><span class="line">                left  = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>二分查找有点类似数学的二分法，来简化查找的次数，一个是左闭右闭，right就是指向真实的下标，然后更新的左右都不取到中间值，另一个是<br>左闭右开，right指向数组的数量（实际加一），更新的右边都取到中间值。</p><h1 id="移除数组"><a href="#移除数组" class="headerlink" title="移除数组"></a>移除数组</h1><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><ul><li>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</li></ul><p>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length=<span class="built_in">len</span>(nums)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; length:</span><br><span class="line">            <span class="keyword">if</span> nums[i]  == val:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,length-<span class="number">1</span>):</span><br><span class="line">                    nums[j]=nums[j+<span class="number">1</span>]</span><br><span class="line">                length -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure><p>这个是暴力解法，双层循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span>  nums[fast] != val:</span><br><span class="line">                nums[slow]=nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><p>这个是快慢指针<br>讲一下思路，简单来说就是，设置两个指针，快的指针用来遍历原来的数组，慢的就用来表示新的数组的下标，然后比较快指针对应的和val一不一样，留下不一样的，一样的就跳过，最后返回慢指针的下标就是新数组的长度</p><h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><ul><li>示例 1：<br> 输入：nums &#x3D; [-4,-1,0,3,10]<br> 输出：[0,1,9,16,100]<br> 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</li></ul><p> 示例 2：<br> 输入：nums &#x3D; [-7,-3,2,3,11]<br> 输出：[4,9,9,49,121]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s1 = <span class="number">0</span></span><br><span class="line">        k= s2 = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        nums_list=[<span class="number">0</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> s1 &lt;= s2:</span><br><span class="line">            <span class="keyword">if</span> nums[s1]**<span class="number">2</span> &gt; nums[s2]**<span class="number">2</span>:</span><br><span class="line">                nums_list[k] = nums[s1]**<span class="number">2</span></span><br><span class="line">                s1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                nums_list[k] = nums[s2]**<span class="number">2</span> </span><br><span class="line">                s2 -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums_list</span><br></pre></td></tr></table></figure><p>这个是双指针的方法，设置两个指针，一个指向数组的头，一个指向数组的尾，然后比较两个指针指向的元素的平方，把大的那个放到新数组的最后面，然后相应的指针向中间移动，最后返回新数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">sorted</span>(x*x <span class="keyword">for</span> x <span class="keyword">in</span> nums)</span><br></pre></td></tr></table></figure><p>无需多言，排序加推导式</p><p>来不及了，要回宿舍了，下次不能拖拖拉拉了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可恶，今天有点拖拖拉拉的，博客只能水一点了&lt;/p&gt;
&lt;h1 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h1&gt;&lt;p&gt;给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值</summary>
      
    
    
    
    <category term="算法学习——数组" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>python_入门练习</title>
    <link href="http://example.com/2025/12/09/python-%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0/"/>
    <id>http://example.com/2025/12/09/python-%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0/</id>
    <published>2025-12-09T13:26:24.000Z</published>
    <updated>2025-12-09T15:07:00.025Z</updated>
    
    <content type="html"><![CDATA[<p>  不得不说我的代码能力太弱了，只能先从简单的开始了。</p><h1 id="1-A-B问题I"><a href="#1-A-B问题I" class="headerlink" title="1.A+B问题I"></a>1.A+B问题I</h1><p>题目描述</p><blockquote><p>你的任务是计算a+b。<br>输入描述<br>输入包含一系列的a和b对，通过空格隔开。一对a和b占一行。<br>输出描述<br>如对于输入中的第二对a和b，<br>  在输出中它们的和应该也在第二行。<br>输入示例<br>1 2<br>  3 4<br>输出示例<br>3<br>  7</p></blockquote><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a,b = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">        <span class="built_in">print</span>(a+b)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>好吧我承认我的代码能力是极差的。<br>第一个问题如何保证一直接受用户输入，首先就要用一个一直循环的while语句，直到没有输入后跳出循环。可以用if判断啥时候输入为空，也可以用try except保证输入的合法性。<br>然后就是map函数，这个函数的核心是对序列里面的每一个元素批量应用同一个处理规则，这里是将输入的字符串转换为整数。<br>这里的.split()函数是将输入的字符串按照空格隔开，返回一个列表。<br>哦，补充一下input函数输入的内容是字符串。</p><h1 id="2-A-B问题II"><a href="#2-A-B问题II" class="headerlink" title="2.A+B问题II"></a>2.A+B问题II</h1><p>题目描述</p><blockquote><p>计算a+b，但输入方式有所改变。<br>输入描述<br>第一行是一个整数N，表示后面会有N行a和b，通过空格隔开。<br>输出描述<br>对于输入的每对a和b，你需要在相应的行输出a、b的和。<br>  如第二对a和b，对应的和也输出在第二行。<br>输入示例<br>2<br>  2 4<br>  9 21<br>输出示例<br>6<br>  30<br>提示信息<br>注意，测试数据不仅仅一组。也就是说，会持续输入N以及后面的a和b</p></blockquote><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>这道题和上一道题的区别在于，上一道题是一直接受用户输入，直到没有输入为止。<br>这道题是先接受一个整数N，然后接受N行a和b，输出N行a+b。而且分组输入导致每一块都有组数N，就不能像上一道题一样无脑接收输入了。<br>补充知识：<br>.strip()函数是去掉字符串首尾的空格，包括换行符、制表符等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        N = <span class="built_in">int</span>(<span class="built_in">input</span>().strip())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            a,b = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">            <span class="built_in">print</span>(a+b)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    N=<span class="built_in">int</span>(line.strip())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        a,b=<span class="built_in">map</span>(<span class="built_in">int</span>,sys.stdin.readline().strip().split())</span><br><span class="line">        <span class="built_in">print</span>(a+b)</span><br></pre></td></tr></table></figure><blockquote><p>导入sys模块后，通过<code>for line in sys.stdin</code>启动外层循环——这个循环的作用是<strong>逐个读取输入中“每组数据的开头行（即N所在的行）”</strong>。每次外层循环执行时：</p></blockquote><ol><li><p>首先处理当前读取到的<code>line</code>：这行内容是当前组的分组信息（整数N），通过<code>int(line.strip())</code>转成整数后，明确“这一组需要处理N对a和b”。</p></li><li><p>接着启动内层循环<code>for _ in range(N)</code>：这个循环的作用是<strong>主动读取当前组内的N行a和b数据</strong>。<br>每次内层循环会通过<code>sys.stdin.readline()</code>读取一行新的输入（这行是a和b，用空格分隔），经过<code>strip()</code>清理空白、<code>split()</code>拆分、<code>map(int, ...)</code>转整数后，得到a和b的值，计算并输出它们的和。<br>内层循环会严格执行N次，确保当前组的N对a和b全部被处理。</p></li><li><p>内层循环结束后，外层循环才会继续执行：此时外层循环会自动读取下一行输入，而这一行恰好是“下一组数据的N”（因为内层循环已经主动读完了上一组的N行a和b，不会让外层循环误读这些行）。</p></li></ol><p>整个过程中，外层循环负责“按组拆分输入”（找到每一组的N），内层循环负责“按组内数量处理数据”（读完N对a和b），两层循环分工配合，既不会漏读数据，也不会错把a和b的行当成N处理，最终完美实现“持续处理多组N及对应a+b”的题目要求。<br>sys.stdin():内置的标准输入流对象，用于从控制台或其他输入源读取数据。<br>sys.stdin.readline()：读取输入的一行,从stdin中读取一行数据,包括换行符。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  不得不说我的代码能力太弱了，只能先从简单的开始了。&lt;/p&gt;
&lt;h1 id=&quot;1-A-B问题I&quot;&gt;&lt;a href=&quot;#1-A-B问题I&quot; class=&quot;headerlink&quot; title=&quot;1.A+B问题I&quot;&gt;&lt;/a&gt;1.A+B问题I&lt;/h1&gt;&lt;p&gt;题目描述&lt;/p&gt;
&lt;b</summary>
      
    
    
    
    
    <category term="入门算法" scheme="http://example.com/tags/%E5%85%A5%E9%97%A8%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_1</title>
    <link href="http://example.com/2025/12/01/hello-world/"/>
    <id>http://example.com/2025/12/01/hello-world/</id>
    <published>2025-12-01T03:32:38.765Z</published>
    <updated>2025-12-01T07:14:12.184Z</updated>
    
    <content type="html"><![CDATA[<p>  从这篇文章开始，我将会将我在算法练习中的所想和收获记录下来。</p><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br> 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br> 你可以按任意顺序返回答案。<br><img src="/images/post1/1.png" alt="题目输出案例"></p><h2 id="1-1-思路1"><a href="#1-1-思路1" class="headerlink" title="1.1 思路1"></a>1.1 思路1</h2><p>  思路1是最简单的思路，就是遍历数组，对于每个元素，都去数组中查找是否有目标值减去当前值的元素。<br>  时间复杂度为O(n^2)，空间复杂度为O(1)。<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">          j = target - i</span><br><span class="line">          start_index = nums.index(i)</span><br><span class="line">          next_index = start_index + <span class="number">1</span> </span><br><span class="line">          nums_new = nums[next_index:]<span class="comment">#对原数组进行切片，去掉当前元素之前的元素</span></span><br><span class="line">          <span class="keyword">if</span> j <span class="keyword">in</span> nums_new:</span><br><span class="line">              <span class="keyword">return</span> [start_index,next_index+nums_new.index(j)]</span><br></pre></td></tr></table></figure></p><h2 id="1-2-思路2-哈希表"><a href="#1-2-思路2-哈希表" class="headerlink" title="1.2 思路2(哈希表)"></a>1.2 思路2(哈希表)</h2><p>  思路2是利用哈希表来解决问题。我们遍历数组，对于每个元素，都去哈希表中查找是否有目标值减去当前值的元素。<br>  如果有，就返回当前元素的下标和哈希表中目标值减去当前值的元素的下标。<br>  如果没有，就将当前元素和下标加入哈希表中。<br>  时间复杂度为O(n)，空间复杂度为O(n)。<em><strong>用空间换时间</strong></em><br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">      <span class="built_in">dir</span>=&#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)): <span class="comment">#遍历数组</span></span><br><span class="line">          <span class="keyword">if</span> target-nums[i] <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dir</span>: <span class="comment">#如果目标值减去当前值不在字典中</span></span><br><span class="line">              <span class="built_in">dir</span>[nums[i]] = i</span><br><span class="line">          <span class="keyword">else</span> :</span><br><span class="line">              <span class="keyword">return</span> [<span class="built_in">dir</span>[target-nums[i]],i]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  从这篇文章开始，我将会将我在算法练习中的所想和收获记录下来。&lt;/p&gt;
&lt;h1 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;1. 两数之和&lt;/h1&gt;&lt;p&gt; 给定一个整数数组 nu</summary>
      
    
    
    
    <category term="算法学习——哈希" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
