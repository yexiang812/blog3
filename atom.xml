<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yeye 想变强</title>
  
  <subtitle>技术&amp;生活blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2026-01-11T13:39:33.010Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yeyeyefirst</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码随想录-day25</title>
    <link href="http://example.com/2026/01/11/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day25/"/>
    <id>http://example.com/2026/01/11/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day25/</id>
    <published>2026-01-11T12:27:16.000Z</published>
    <updated>2026-01-11T13:39:33.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h1><p><a href="https://leetcode.cn/problems/restore-ip-addresses/description/">93. 复原 IP 地址</a></p><blockquote><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p></blockquote><ul><li>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#57;&#x32;&#46;&#x31;&#54;&#x38;&#64;&#x31;&#46;&#49;">192.168@1.1</a>“ 是 无效 IP 地址。<br></li></ul><blockquote><p>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isok</span>(<span class="params">self,s,s_index,e_index</span>):</span><br><span class="line">        <span class="keyword">if</span> s_index &gt; e_index:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s[s_index] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> s_index != e_index:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(s[s_index:e_index+<span class="number">1</span>]) &gt; <span class="number">255</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,s,index,count,cur,result</span>):</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">3</span> <span class="keyword">and</span> <span class="variable language_">self</span>.isok(s,index,<span class="built_in">len</span>(s)-<span class="number">1</span>):</span><br><span class="line">            cur += s[index:]</span><br><span class="line">            result.append(cur)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.isok(s,index,i):</span><br><span class="line">                temp = s[index:i+<span class="number">1</span>]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="variable language_">self</span>.backtracking(s,i+<span class="number">1</span>,count,cur+temp+<span class="string">&#x27;.&#x27;</span>,result) <span class="comment">#隐式回溯，cur本身不变</span></span><br><span class="line">                count -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(s,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>不能直接用s，字符串不可变还是要设置个变量接住</p><h1 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h1><p><a href="https://leetcode.cn/problems/subsets/description/">78. 子集</a></p><blockquote><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p></blockquote><ul><li>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,nums,index,path,result</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(nums)):</span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(nums,i+<span class="number">1</span>,path,result)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = [[]]</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(nums,<span class="number">0</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>真别说，连剪枝都不要，但是这道题每个节点都要记录一下</p><h1 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h1><p><a href="https://leetcode.cn/problems/subsets-ii/description/">90. 子集 II</a></p><blockquote><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p></blockquote><ul><li><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><blockquote><p>示例 1：</p></blockquote></li><li><p>输入：nums &#x3D; [1,2,2]</p></li><li><p>输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</p><blockquote><p>示例 2：</p></blockquote></li><li><p>输入：nums &#x3D; [0]</p></li><li><p>输出：[[],[0]]</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,nums,index,path,result,used</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i&gt;index <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span> </span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(nums,i+<span class="number">1</span>,path,result,used)</span><br><span class="line">            path.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = [[]]</span><br><span class="line">        nums.sort()</span><br><span class="line">        used = [<span class="literal">False</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(nums,<span class="number">0</span>,[],result,used)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>就是在上道题的基础上，加一个去重的操作，用昨天的树层去重的方法，添加一个<code>uesd</code>来表示是否被使用</p><p>怎么说，终于赶上来，之前每天都要在截止前，现在也可以按时完成了，感觉回溯学的不如之前的，可能是在期末考，总是把这个当负担，希望后面考完状态可以调整过来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复原IP地址&quot;&gt;&lt;a href=&quot;#复原IP地址&quot; class=&quot;headerlink&quot; title=&quot;复原IP地址&quot;&gt;&lt;/a&gt;复原IP地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/restore-ip-addre</summary>
      
    
    
    
    <category term="算法学习——回溯" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day24</title>
    <link href="http://example.com/2026/01/10/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day24/"/>
    <id>http://example.com/2026/01/10/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day24/</id>
    <published>2026-01-10T13:21:03.000Z</published>
    <updated>2026-01-11T13:26:50.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h1><h2 id="原始版本"><a href="#原始版本" class="headerlink" title="原始版本"></a>原始版本</h2><p><a href="https://leetcode.cn/problems/combination-sum/description/">39. 组合总和</a></p><blockquote><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,candidates,target,sums,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> sums &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> sums == target:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">#空返回，改变result就行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(candidates)):</span><br><span class="line">            sums += candidates[i]</span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(candidates,target,sums,i,path,result)</span><br><span class="line">            sums -= candidates[i] </span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(candidates,target,<span class="number">0</span>,<span class="number">0</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>总的来说，就是回溯的模板，只是在递归的过程中，需要判断一下是否超过了目标值，如果超过了，就直接返回。如果等于目标值，就将当前路径加入结果集中。然后因为可以重复使用元素，所以递归的索引从当前索引开始（不用i+1）。</p><h2 id="排序加剪枝"><a href="#排序加剪枝" class="headerlink" title="排序加剪枝"></a>排序加剪枝</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,candidates,target,sums,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> sums == target:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">#空返回，改变result就行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(candidates)):</span><br><span class="line">            sums += candidates[i]</span><br><span class="line">            <span class="keyword">if</span> sums &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(candidates,target,sums,i,path,result)</span><br><span class="line">            sums -= candidates[i] </span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(candidates,target,<span class="number">0</span>,<span class="number">0</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br>     <h1 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h1><p><a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II</a></p><blockquote><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,candidates,target,sums,index,used,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> sums == target:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(candidates)): <span class="comment">#用循环让数组的每个变成一棵树的根节点，同时一棵树比一颗更窄，目的就是不要重复（指的是（1，2）（2，1）这种）</span></span><br><span class="line">            <span class="comment">#下面的去重是数组里面本身元素的重复导致的（但是又不能简单的把数组元素去重）</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;index <span class="keyword">and</span> candidates[i] == candidates[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]: <span class="comment">#进行层剪枝的操作</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            sums += candidates[i]</span><br><span class="line">            <span class="keyword">if</span> sums &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            <span class="variable language_">self</span>.backtracking(candidates,target,sums,i+<span class="number">1</span>,used,path,result)</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">            sums -= candidates[i]</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(candidates)</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(candidates,target,<span class="number">0</span>,<span class="number">0</span>,used,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这道题关键在于区分树枝重复和树层重复，叶子可以和父节点相同，但是不能跟兄弟相同（包括每一个根节点）</p><h1 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h1><p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">131. 分割回文串</a></p><blockquote><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,s,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(s):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[index:i+<span class="number">1</span>] == s[index:i+<span class="number">1</span>][::-<span class="number">1</span>] :</span><br><span class="line">                path.append(s[index:i+<span class="number">1</span>])</span><br><span class="line">                <span class="variable language_">self</span>.backtracking(s,i+<span class="number">1</span>,path,result)</span><br><span class="line">                path.pop()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(s,<span class="number">0</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>就是用递归加回溯把所有切割方式列出来返回是回文的内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组合总和&quot;&gt;&lt;a href=&quot;#组合总和&quot; class=&quot;headerlink&quot; title=&quot;组合总和&quot;&gt;&lt;/a&gt;组合总和&lt;/h1&gt;&lt;h2 id=&quot;原始版本&quot;&gt;&lt;a href=&quot;#原始版本&quot; class=&quot;headerlink&quot; title=&quot;原始版本&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="算法学习——回溯" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day23</title>
    <link href="http://example.com/2026/01/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day23/"/>
    <id>http://example.com/2026/01/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day23/</id>
    <published>2026-01-09T13:45:25.000Z</published>
    <updated>2026-01-10T12:24:03.458Z</updated>
    
    <content type="html"><![CDATA[<p>只能说越到后面越难坚持，加油</p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p><a href="https://leetcode.cn/problems/combinations/description/">77. 组合</a></p><blockquote><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p></blockquote><h2 id="未剪枝"><a href="#未剪枝" class="headerlink" title="未剪枝"></a>未剪枝</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(n,k,<span class="number">1</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,n,k,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">            result.append(path[:]) <span class="comment"># 注意path的拷贝方式</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,n+<span class="number">1</span>):</span><br><span class="line">            path.append(i)</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(n,k,i+<span class="number">1</span>,path,result) <span class="comment">#这里改成index+1会返回所有组合（包括重复的）</span></span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(n,k,<span class="number">1</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,n,k,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">            result.append(path[:]) <span class="comment"># 注意path的拷贝方式</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,n-(k-<span class="built_in">len</span>(path))+<span class="number">2</span>): <span class="comment"># 这里的n-(k-len(path))+2是为了剪枝，因为如果n-(k-len(path))+2还小于k，那么就没有必要继续遍历了</span></span><br><span class="line">            path.append(i)</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(n,k,i+<span class="number">1</span>,path,result) <span class="comment">#这里改成index+1会返回所有组合（包括重复的）</span></span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure><p>解释一下这个剪枝的地方：<br>need &#x3D; k - len(path)，i一直到n，共有n-i+1个元素，剩余元素至少要大于等于need才行，因此n-i+1 &gt;&#x3D; need，即n-i+1 &gt;&#x3D; k - len(path)，即n-(k-len(path))+1 &lt;&#x3D; n，但是python的range是左闭右开的，右边取不到，所以要+1变成<strong>n-(k-len(path))+2</strong></p><h1 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h1><p><a href="https://leetcode.cn/problems/combination-sum-iii/description/">216. 组合总和 III</a></p><blockquote><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：<br>只使用数字1到9<br>每个数字 最多使用一次</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(n,k,<span class="number">0</span>,<span class="number">1</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,targetsum,k,cursum,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> cursum &gt; targetsum:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k :</span><br><span class="line">            <span class="keyword">if</span> targetsum == cursum:</span><br><span class="line">                result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="number">9</span>-(k-<span class="built_in">len</span>(path))+<span class="number">2</span>):</span><br><span class="line">            cursum += i</span><br><span class="line">            path.append(i)</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(targetsum,k,cursum,i+<span class="number">1</span>,path,result)</span><br><span class="line">            cursum -= i</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure><ul><li>这道题比上一道题多的剪枝的内容是当前和大于目标和时，直接返回</li><li>以及在回溯的时候别忘了更新当前和</li></ul><h1 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h1><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合</a></p><blockquote><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="/images/codecrazy/day23-T3.png" alt="按键实例"></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.lettermap=[</span><br><span class="line">            <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;def&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;ghi&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;jkl&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mno&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;pqrs&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;tuv&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;wxyz&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        <span class="variable language_">self</span>.result = []</span><br><span class="line">        <span class="variable language_">self</span>.s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,digits,index</span>):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(digits): <span class="comment">#终止条件深度等于位数</span></span><br><span class="line">            <span class="variable language_">self</span>.result.append(<span class="variable language_">self</span>.s)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        digit = <span class="built_in">int</span>(digits[index]) <span class="comment">#字符形式转化，便于查字典</span></span><br><span class="line">        letter = <span class="variable language_">self</span>.lettermap[digit] <span class="comment">#对应层的字符串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> letter: <span class="comment">#实现分叉</span></span><br><span class="line">            <span class="variable language_">self</span>.s += i</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(digits,index + <span class="number">1</span>) <span class="comment">#深度探索</span></span><br><span class="line">            <span class="variable language_">self</span>.s = <span class="variable language_">self</span>.s[:-<span class="number">1</span>] <span class="comment">#回溯，删掉最后一个</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(digits,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br></pre></td></tr></table></figure><p>咱就是说明天别个人休息我再努力一下就可以按时完成了，每天的任务一定要完成，欠了就永远赶不上了，一天做两个就很辛苦了，加油          </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;只能说越到后面越难坚持，加油&lt;/p&gt;
&lt;h1 id=&quot;组合&quot;&gt;&lt;a href=&quot;#组合&quot; class=&quot;headerlink&quot; title=&quot;组合&quot;&gt;&lt;/a&gt;组合&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/combinatio</summary>
      
    
    
    
    <category term="算法学习——回溯" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day22</title>
    <link href="http://example.com/2026/01/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day22/"/>
    <id>http://example.com/2026/01/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day22/</id>
    <published>2026-01-08T02:10:34.000Z</published>
    <updated>2026-01-08T03:09:22.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h1><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669. 修剪二叉搜索树</a></p><blockquote><p>给你二叉搜索树的根节点 root ，同时给定最小边界 low 和最大边界 high 。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 之间。修剪树 不应该 改变保留在树中的节点的相对结构（即，如果没有被移除，原有的父子关系都应当保留）。可以证明，存在 唯一的答案 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trimBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; low:</span><br><span class="line">            right = <span class="variable language_">self</span>.trimBST(root.right,low,high)</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; high:</span><br><span class="line">            left = <span class="variable language_">self</span>.trimBST(root.left,low,high)</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        root.left = <span class="variable language_">self</span>.trimBST(root.left,low,high)</span><br><span class="line">        root.right = <span class="variable language_">self</span>.trimBST(root.right,low,high)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>如果访问节点的值在[low,high]之间，那么就递归访问左右子树。<br>如果节点值小于low，那么就去访问右子树，因为左子树的值一定更小。（返回右子树的根节点，并且右子树也要进行修剪）<br>如果节点值大于high，那么就去访问左子树，因为右子树的值一定更大。（返回左子树的根节点，并且左子树也要进行修剪）</p><h1 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h1><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108. 将有序数组转换为二叉搜索树</a></p><blockquote><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">tra</span>(<span class="params">nums,left,right</span>):</span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            mid = (left + right)//<span class="number">2</span></span><br><span class="line">            root = TreeNode(nums[mid])</span><br><span class="line">            root.left =  tra(nums,left,mid-<span class="number">1</span>)</span><br><span class="line">            root.right = tra(nums,mid+<span class="number">1</span>,right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> tra(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>有点类似二分法，每次取中间值作为根节点，然后递归构造左右子树。（左闭右闭）</p><h1 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h1><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538. 把二叉搜索树转换为累加树</a></p><blockquote><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="variable language_">self</span>.convertBST(root.right)</span><br><span class="line">        root.val += <span class="variable language_">self</span>.pre </span><br><span class="line">        <span class="variable language_">self</span>.pre = root.val</span><br><span class="line">        <span class="variable language_">self</span>.convertBST(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>采用右中左的遍历顺序，先遍历右子树，然后遍历根节点，最后遍历左子树。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;修剪二叉搜索树&quot;&gt;&lt;a href=&quot;#修剪二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;修剪二叉搜索树&quot;&gt;&lt;/a&gt;修剪二叉搜索树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/trim-a-binar</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day21</title>
    <link href="http://example.com/2026/01/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day21/"/>
    <id>http://example.com/2026/01/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day21/</id>
    <published>2026-01-07T02:37:00.000Z</published>
    <updated>2026-01-07T04:40:02.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">235. 二叉搜索树的最近公共祖先</a></p><blockquote><p>给定一个二叉搜索树, </p></blockquote><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            left = <span class="variable language_">self</span>.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">            <span class="keyword">return</span> left </span><br><span class="line">        <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            right = <span class="variable language_">self</span>.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>只要val在p和q之间，那么root就是最近公共祖先</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">                root = root.right    </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h1><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701. 二叉搜索树中的插入操作</a></p><blockquote><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val ，</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            root.left = <span class="variable language_">self</span>.insertIntoBST(root.left,val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.right = <span class="variable language_">self</span>.insertIntoBST(root.right,val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left :</span><br><span class="line">                root.left = TreeNode(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="variable language_">self</span>.insertIntoBST(root.left,val)</span><br><span class="line">        <span class="keyword">if</span> val &gt; root.val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                root.right = TreeNode(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="variable language_">self</span>.insertIntoBST(root.right,val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h1><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450. 删除二叉搜索树中的节点</a></p><blockquote><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val == key:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                cur = root.right</span><br><span class="line">                <span class="keyword">while</span> cur.left:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                cur.left = root.left</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; key:</span><br><span class="line">            root.left= <span class="variable language_">self</span>.deleteNode(root.left,key)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key:</span><br><span class="line">            root.right= <span class="variable language_">self</span>.deleteNode(root.right,key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>当找到要删除的节点时，分四种情况讨论：</p><ol><li>该节点没有子节点，直接删除，返回 None。</li><li>该节点只有右子节点，返回右子节点，替代该节点。</li><li>该节点只有左子节点，返回左子节点，替代该节点。</li><li>该节点有左右子节点，将左子树挂到右子树的最左节点的左子树上，返回右子节点，替代该节点。<br>挺难的</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉搜索树的最近公共祖先&quot;&gt;&lt;a href=&quot;#二叉搜索树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的最近公共祖先&quot;&gt;&lt;/a&gt;二叉搜索树的最近公共祖先&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/p</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day20</title>
    <link href="http://example.com/2026/01/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day20/"/>
    <id>http://example.com/2026/01/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day20/</id>
    <published>2026-01-06T11:23:16.000Z</published>
    <updated>2026-01-06T13:05:25.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h1><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530. 二叉搜索树的最小绝对差</a></p><blockquote><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.result = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,cur</span>):</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="variable language_">self</span>.dfs(cur.left)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.pre <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.result = <span class="built_in">min</span>(<span class="variable language_">self</span>.result,cur.val-<span class="variable language_">self</span>.pre.val)</span><br><span class="line">        <span class="variable language_">self</span>.pre = cur</span><br><span class="line">        <span class="variable language_">self</span>.dfs(cur.right)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinimumDifference</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="variable language_">self</span>.dfs(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br></pre></td></tr></table></figure><p>采用递归（中序遍历）加双指针的方法，遍历二叉搜索树，记录前一个节点，每次遍历到当前节点时，计算当前节点和前一个节点的差值，取最小值即可。</p><h1 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h1><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">501. 二叉搜索树中的众数</a></p><blockquote><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。<br>如果树中有不止一个众数，可以按 任意顺序 返回。<br>假定 BST 满足如下定义：<br>结点左子树中所含节点的值 小于等于 当前节点的值<br>结点右子树中所含节点的值 大于等于 当前节点的值<br>左子树和右子树都是二叉搜索树</p></blockquote><h2 id="递归（中序遍历）-哈希表-双指针"><a href="#递归（中序遍历）-哈希表-双指针" class="headerlink" title="递归（中序遍历）+ 哈希表 + 双指针"></a>递归（中序遍历）+ 哈希表 + 双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.count = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.pre = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.result = &#123;&#125; </span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,cur</span>):</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="variable language_">self</span>.dfs(cur.left)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.pre <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.pre.val == cur.val:</span><br><span class="line">                <span class="variable language_">self</span>.count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="variable language_">self</span>.count = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.result[cur.val] = <span class="variable language_">self</span>.count</span><br><span class="line">        <span class="variable language_">self</span>.pre = cur</span><br><span class="line">        <span class="variable language_">self</span>.dfs(cur.right)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(root)</span><br><span class="line">        target_count = <span class="built_in">max</span>(<span class="variable language_">self</span>.result.values())</span><br><span class="line">        num = [k <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="variable language_">self</span>.result.items() <span class="keyword">if</span> v == target_count]</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><p>这是我没看视频前做的，额，最开始我想的是，相等就count+1，然后用flag来区分到底是哪个节点重复，额，然后写着写着就成了哈希表，然后感觉flag用cur.val替代更好</p><h2 id="双指针-数组-递归（中序遍历）"><a href="#双指针-数组-递归（中序遍历）" class="headerlink" title="双指针+数组+递归（中序遍历）"></a>双指针+数组+递归（中序遍历）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.Maxc = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.count = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.pre = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.result = []</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,cur</span>):</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="variable language_">self</span>.dfs(cur.left)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.pre <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.pre.val == cur.val:</span><br><span class="line">            <span class="variable language_">self</span>.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.count = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.pre = cur</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.count ==<span class="variable language_">self</span>. Maxc:</span><br><span class="line">            <span class="variable language_">self</span>.result.append(cur.val)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.count &gt; <span class="variable language_">self</span>.Maxc:</span><br><span class="line">            <span class="variable language_">self</span>.Maxc = <span class="variable language_">self</span>.count</span><br><span class="line">            <span class="variable language_">self</span>.result = [cur.val]</span><br><span class="line">        <span class="variable language_">self</span>.dfs(cur.right)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br></pre></td></tr></table></figure><h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先</a></p><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> root == q <span class="keyword">or</span> root ==p <span class="keyword">or</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left_ = <span class="variable language_">self</span>.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right_ = <span class="variable language_">self</span>.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> left_ <span class="keyword">and</span> right_:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> left_ <span class="keyword">and</span> <span class="keyword">not</span> right_:</span><br><span class="line">            <span class="keyword">return</span> left_</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> left_ <span class="keyword">and</span> right_:</span><br><span class="line">            <span class="keyword">return</span> right_</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>在递归中包含回溯的思想，这里的特例包括：</p><ol><li>根节点是p或q</li><li>p或q在根节点的左子树或右子树中<hr><br>递归三部曲：</li><li>确定递归函数的参数和返回值（root,p,q）</li><li>确定终止条件（root &#x3D;&#x3D; p or root &#x3D;&#x3D; q or root &#x3D;&#x3D; None）</li><li>确定单层递归的逻辑（左子树和右子树的遍历）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉搜索树的最小绝对差&quot;&gt;&lt;a href=&quot;#二叉搜索树的最小绝对差&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的最小绝对差&quot;&gt;&lt;/a&gt;二叉搜索树的最小绝对差&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/probl</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day18</title>
    <link href="http://example.com/2026/01/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day18/"/>
    <id>http://example.com/2026/01/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day18/</id>
    <published>2026-01-03T12:07:24.000Z</published>
    <updated>2026-01-03T14:39:50.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h1><p><a href="https://leetcode.cn/problems/maximum-binary-tree/description/">654. 最大二叉树</a></p><blockquote><p>给定一个不含重复元素的整数数组 nums 。 你需要从 nums 中找出最大的数，将其作为二叉树的根节点，然后递归地构建左子树和右子树。<br>左子树的构建过程是从数组中 最大值左边 的 子数组中 构建出最大二叉树 。<br>右子树的构建过程是从数组中 最大值右边 的 子数组中 构建出最大二叉树 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructMaximumBinaryTree</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:     <span class="comment">#只有一个点就创建以这个为点的树</span></span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">        node = TreeNode(<span class="number">0</span>) <span class="comment">#创建节点设置值为零</span></span><br><span class="line">        max_n = <span class="number">0</span></span><br><span class="line">        index_n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; max_n:</span><br><span class="line">                max_n =nums[i]</span><br><span class="line">                index_n = i</span><br><span class="line">        node.val = max_n</span><br><span class="line">        <span class="keyword">if</span> index_n &gt; <span class="number">0</span>:</span><br><span class="line">            left_num = nums[<span class="number">0</span>:index_n]</span><br><span class="line">            node.left = <span class="variable language_">self</span>.constructMaximumBinaryTree(left_num)</span><br><span class="line">        <span class="keyword">if</span> index_n &lt; <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">            right_num = nums[index_n+<span class="number">1</span>:]</span><br><span class="line">            node.right = <span class="variable language_">self</span>.constructMaximumBinaryTree(right_num)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p>递归法，递归三部曲：</p><ol><li>确定递归函数的参数和返回值（nums）</li><li>确定递归的终止条件（数组长度为1）</li><li>确定单层递归的逻辑（找到最大值和索引，创建节点，递归左子树和右子树）</li></ol><h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617. 合并二叉树</a></p><blockquote><p>给你两棵二叉树： root1 和 root2 。想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。<br>返回合并后的二叉树。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> root2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        root1.val += root2.val</span><br><span class="line">        root1.left = <span class="variable language_">self</span>.mergeTrees(root1.left,root2.left)</span><br><span class="line">        root1.right = <span class="variable language_">self</span>.mergeTrees(root1.right,root2.right)</span><br><span class="line">        <span class="keyword">return</span> root1</span><br></pre></td></tr></table></figure><p>递归法，递归三部曲：</p><ol><li>确定递归函数的参数和返回值（root1,root2）</li><li>确定递归的终止条件（root1为空返回root2，root2为空返回root1）(包含都为空的情况)</li><li>确定单层递归的逻辑（将root2的值加到root1上，递归左子树和右子树）</li></ol><h1 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h1><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">700. 二叉搜索树中的搜索</a></p><blockquote><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。你需要在 BST 中找到节点值等于 val 的节点。返回以该节点为根的子树。如果节点不存在，则返回 null 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.searchBST(root.left,val)</span><br><span class="line">        <span class="keyword">if</span> val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.searchBST(root.right,val)</span><br></pre></td></tr></table></figure><p>递归法，递归三部曲：</p><ol><li>确定递归函数的参数和返回值（root,val）(注意题目要求的返回值是节点（值为val的节点）)</li><li>确定递归的终止条件（root为空返回None，root值等于val返回root）</li><li>确定单层递归的逻辑（如果val小于root值，递归左子树，否则递归右子树）</li></ol><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">                root=root.left</span><br><span class="line">            <span class="keyword">elif</span> val &gt; root.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>迭代法，循环遍历二叉搜索树，找到值为val的节点，返回该节点。如果遍历完整个树都没有找到，返回None。</p><h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98. 验证二叉搜索树</a></p><blockquote><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<br>有效 二叉搜索树定义如下：<br>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        left = <span class="variable language_">self</span>.isValidBST(root.left)</span><br><span class="line">        <span class="keyword">if</span>  <span class="variable language_">self</span>.pre <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="variable language_">self</span>.pre.val &gt;= root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="variable language_">self</span>.pre = root</span><br><span class="line">        right = <span class="variable language_">self</span>.isValidBST(root.right)</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure><p>递归法，递归三部曲：</p><ol><li>确定递归函数的参数和返回值（root）(注意题目要求的返回值是布尔值)</li><li>确定递归的终止条件（root为空返回True）</li><li>确定单层递归的逻辑（中序遍历，判断当前节点是否大于前一个节点，递归左子树和右子树）<br>在这道题我遇到了个很有意思的错误，就是我把self.pre &#x3D; None放在isValidBST里面，欸，产生了一直返回True的情况，按照以前ai教我的，把这个放在里面按道理是防止污染，是好的，我仔细思考了一下，因为在这道题pre是不可以被重新初始化的，放在isValidBST里面会导致每次递归都重新初始化pre，所以会一直返回True。所以再__init__里面创建一次最好</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最大二叉树&quot;&gt;&lt;a href=&quot;#最大二叉树&quot; class=&quot;headerlink&quot; title=&quot;最大二叉树&quot;&gt;&lt;/a&gt;最大二叉树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/maximum-binary-tree/</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day17</title>
    <link href="http://example.com/2026/01/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day17/"/>
    <id>http://example.com/2026/01/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day17/</id>
    <published>2026-01-02T01:45:54.000Z</published>
    <updated>2026-01-02T04:56:48.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="找二叉树的左下角的值"><a href="#找二叉树的左下角的值" class="headerlink" title="找二叉树的左下角的值"></a>找二叉树的左下角的值</h1><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">513. 找树左下角的值</a></p><blockquote><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。<br>假设二叉树中至少有一个节点。</p></blockquote><h2 id="找二叉树的左下角的值-递归"><a href="#找二叉树的左下角的值-递归" class="headerlink" title="找二叉树的左下角的值-递归"></a>找二叉树的左下角的值-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="variable language_">self</span>.max_ = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.result = []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,node,depth</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">if</span> depth &gt; <span class="variable language_">self</span>.max_:</span><br><span class="line">                <span class="variable language_">self</span>.max_ = depth</span><br><span class="line">                <span class="variable language_">self</span>.result = node.val</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.dfs(node.left,depth)</span><br><span class="line">            depth -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.dfs(node.right,depth)</span><br><span class="line">            depth -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>递归法，并且结合了回溯的思想。<br>这里递归三部曲：</p><ol><li>确定递归函数的参数和返回值（node,depth）</li><li>确定递归的终止条件（到达叶子节点）</li><li>确定单层递归的逻辑（更新最大深度和结果值，递归左右子树）<br>我原本一直在想为啥–完不会回去循环，因为递归是一种自顶向下的过程，每次递归调用都进入到下一层，而不是回到上一层。（栈？）</li></ol><h1 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h1><p><a href="https://leetcode.cn/problems/path-sum/description/">112. 路径总和</a></p><blockquote><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。<br>叶子节点 是指没有子节点的节点。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.dfs(root,targetSum-root.val)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,node,targetSum</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> targetSum == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> targetSum != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            targetSum -= node.left.val</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.dfs(node.left,targetSum):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            targetSum += node.left.val</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            targetSum -= node.right.val</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.dfs(node.right,targetSum):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            targetSum += node.right.val</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>递归法，回溯，<br>判断是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和。<br>这里递归三部曲：</p><ol><li>确定递归函数的参数和返回值（node,targetSum）（bool,并且一直向上返回）</li><li>确定递归的终止条件（到达叶子节点）(目标和为0则返回True，否则返回False)</li><li>确定单层递归的逻辑（判断是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和）</li></ol><h1 id="路径总和-路径"><a href="#路径总和-路径" class="headerlink" title="路径总和-路径"></a>路径总和-路径</h1><p><a href="https://leetcode.cn/problems/path-sum-ii/description/">113. 路径总和 II</a></p><blockquote><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。<br>叶子节点 是指没有子节点的节点。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.result = []</span><br><span class="line">        <span class="variable language_">self</span>.path = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br><span class="line">        <span class="variable language_">self</span>.path.append(root.val)</span><br><span class="line">        <span class="variable language_">self</span>.dfs(root,targetSum-root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,node,targetSum</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> targetSum == <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.result.append(<span class="variable language_">self</span>.path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            <span class="variable language_">self</span>.path.append(node.left.val)</span><br><span class="line">            targetSum -= node.left.val</span><br><span class="line">            <span class="variable language_">self</span>.dfs(node.left,targetSum)</span><br><span class="line">            targetSum += node.left.val</span><br><span class="line">            <span class="variable language_">self</span>.path.pop() </span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            <span class="variable language_">self</span>.path.append(node.right.val)</span><br><span class="line">            targetSum -= node.right.val</span><br><span class="line">            <span class="variable language_">self</span>.dfs(node.right,targetSum)</span><br><span class="line">            targetSum += node.right.val</span><br><span class="line">            <span class="variable language_">self</span>.path.pop()</span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>递归法，回溯，<br>判断是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和。<br>这里递归三部曲：</p><ol><li>确定递归函数的参数和返回值（node,targetSum）</li><li>确定递归的终止条件（到达叶子节点）</li><li>确定单层递归的逻辑（判断是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和）<ol><li>如果存在左子树，递归左子树，路径上添加左子节点值，目标和减去左子节点值。</li><li>如果存在右子树，递归右子树，路径上添加右子节点值，目标和减去右子节点值。</li><li>如果到达叶子节点且目标和为0，将当前路径添加到结果中。</li><li>如果到达叶子节点且目标和不为0，返回False。</li></ol></li></ol><hr><p>这里我遇到了一个有意思的问题<br>self.result.append(self.path[:])我写成了self.result.append(self.path)，然后path只有一个返回值,如果是self.result.append(self.path[])则直接报错，为啥呢</p><ul><li><code>self.result.append(self.path) (错误)</code>这是添加引用。<br><code>self.result</code> 里保存的是指向<code>self.path</code>的指针。后续对<code> self.path</code> 的任何修改（比如 <code>pop()</code>）都会影响到 <code>self.result</code> 里的内容。</li><li><code>self.result.append(self.path[]) (完全错误)</code><br>只写了方括号，但没有告诉 Python 你要索引哪个位置，或者要切片哪个范围。这就像你对别人说 “请把书从书架上拿下来”，但没说拿哪一本，对方无法执行你的指令。</li><li><code>self.result.append(self.path[:]) (正确)</code><br>这会创建一个 <code>self.path</code> 的副本，然后将这个副本添加到 <code>self.result</code> 中。这个副本是一个独立的新列表，它的内容在被添加时就固定了。后续对 <code>self.path</code> 的回溯修改（<code>pop()</code>）不会影响到已经存入 <code>self.result</code> 的这个副本。<hr><br>我的理解是，[:]是拷贝一份，然后修改原列表不会影响到拷贝的列表，而直接<code>self.path</code>是(类似指针)会修改原列表，会影响到<code>self.result</code>里的内容。</li></ul><h1 id="从中序和后序遍历构造二叉树"><a href="#从中序和后序遍历构造二叉树" class="headerlink" title="从中序和后序遍历构造二叉树"></a>从中序和后序遍历构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树</a></p><blockquote><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = postorder[-<span class="number">1</span>]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line"></span><br><span class="line">        mid_index = inorder.index(root_val)</span><br><span class="line"></span><br><span class="line">        left_in = inorder[:mid_index]</span><br><span class="line">        right_in = inorder[mid_index+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        left_po = postorder[:mid_index]</span><br><span class="line">        right_po = postorder[mid_index:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        root.left = <span class="variable language_">self</span>.buildTree(left_in,left_po)</span><br><span class="line">        root.right = <span class="variable language_">self</span>.buildTree(right_in,right_po)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>right_po &#x3D; postorder[mid_index:-1]最开始我记错了，写成right_po &#x3D; postorder[mid_index:-2]，因为我以为-1是最后也取，但实际上-1表示最后一个不取，因为后序遍历的最后一个是根节点。</p><h1 id="从前序和中序遍历构造二叉树"><a href="#从前序和中序遍历构造二叉树" class="headerlink" title="从前序和中序遍历构造二叉树"></a>从前序和中序遍历构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105. 从前序与中序遍历序列构造二叉树</a></p><blockquote><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造并返回这颗 二叉树 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = preorder[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        mid_index = inorder.index(root_val)</span><br><span class="line">        left_in = inorder[:mid_index] </span><br><span class="line">        right_in = inorder[mid_index+<span class="number">1</span>:]</span><br><span class="line">        left_pr = preorder[<span class="number">1</span>:mid_index+<span class="number">1</span>]</span><br><span class="line">        right_pr = preorder[mid_index+<span class="number">1</span>:]</span><br><span class="line">        root.left = <span class="variable language_">self</span>.buildTree(left_pr,left_in)</span><br><span class="line">        root.right = <span class="variable language_">self</span>.buildTree(right_pr,right_in)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>暂时先这样，吃个饭去</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;找二叉树的左下角的值&quot;&gt;&lt;a href=&quot;#找二叉树的左下角的值&quot; class=&quot;headerlink&quot; title=&quot;找二叉树的左下角的值&quot;&gt;&lt;/a&gt;找二叉树的左下角的值&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day15</title>
    <link href="http://example.com/2026/01/01/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day15/"/>
    <id>http://example.com/2026/01/01/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day15/</id>
    <published>2026-01-01T08:16:08.000Z</published>
    <updated>2026-01-01T13:58:06.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">平衡二叉树</a><br>给你一个二叉树的根节点 root ，判断它是否是平衡二叉树。</p><h2 id="平衡二叉树-递归"><a href="#平衡二叉树-递归" class="headerlink" title="平衡二叉树-递归"></a>平衡二叉树-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.get_h(root) == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_h</span>(<span class="params">self,node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_h = <span class="variable language_">self</span>.get_h(node.left)</span><br><span class="line">        <span class="keyword">if</span> left_h == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> (right_h := <span class="variable language_">self</span>.get_h(node.right)) == -<span class="number">1</span>: <span class="comment">#海象运算符</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">abs</span>(left_h - right_h)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_h,right_h)+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过后序遍历的方式计算每个节点的高度，并判断其左右子树的高度差是否超过1，若超过则返回-1表示不平衡，否则返回节点的高度。其中可以用海象运算符（:&#x3D;）来简化代码，避免重复计算。</p><h1 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h1><p><a href="https://leetcode.cn/problems/binary-tree-paths/description/">二叉树的所有路径</a><br>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p><h2 id="二叉树的所有路径-递归"><a href="#二叉树的所有路径-递归" class="headerlink" title="二叉树的所有路径-递归"></a>二叉树的所有路径-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,cur,path,result</span>):</span><br><span class="line">        path.append(cur.val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">            result.append(<span class="string">&quot;-&gt;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,path)))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> cur.left:</span><br><span class="line">            <span class="variable language_">self</span>.dfs(cur.left,path,result)</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">if</span> cur.right:</span><br><span class="line">            <span class="variable language_">self</span>.dfs(cur.right,path,result)</span><br><span class="line">            path.pop()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        path = []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(root,path,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>因为是从根节点出发查找路径，很容易想到用前序遍历的方式来实现。<br>在递归中其实是包含了回溯的过程，每次递归结束后，都需要将当前节点从路径中弹出，以确保路径的正确性。</p><h1 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h1><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">左叶子之和</a><br>给你二叉树的根节点 root ，返回所有左叶子节点的和。</p><h2 id="左叶子之和-递归"><a href="#左叶子之和-递归" class="headerlink" title="左叶子之和-递归"></a>左叶子之和-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftnum = <span class="variable language_">self</span>.sumOfLeftLeaves(root.left)</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.right:</span><br><span class="line">            leftnum = root.left.val</span><br><span class="line">        rightnum = <span class="variable language_">self</span>.sumOfLeftLeaves(root.right)</span><br><span class="line">        sum_val = leftnum + rightnum</span><br><span class="line">        <span class="keyword">return</span> sum_val</span><br></pre></td></tr></table></figure><p>采用后序遍历的方式，先计算左子树的左叶子节点之和，再计算右子树的左叶子节点之和，最后将它们相加即可。<br>判断当前节点的左子节点是否为左叶子节点（即左子节点没有左右子节点），若为左叶子节点，则将其值加入左子树的左叶子节点之和中。</p><h1 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h1><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">完全二叉树的节点个数</a><br>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><h2 id="完全二叉树的节点个数-递归"><a href="#完全二叉树的节点个数-递归" class="headerlink" title="完全二叉树的节点个数-递归"></a>完全二叉树的节点个数-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = root.left</span><br><span class="line">        right= root.right</span><br><span class="line">        ld = <span class="number">0</span></span><br><span class="line">        rd = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left:</span><br><span class="line">            left = left.left</span><br><span class="line">            ld += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            right = right.right</span><br><span class="line">            rd += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> ld==rd:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>**(ld+<span class="number">1</span>)-<span class="number">1</span></span><br><span class="line">        leftnum = <span class="variable language_">self</span>.countNodes(root.left)</span><br><span class="line">        rightnum = <span class="variable language_">self</span>.countNodes(root.right)</span><br><span class="line">        result = leftnum + rightnum + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>通过计算左子树和右子树的深度，判断当前节点是否为满二叉树的根节点。如果是，则直接计算节点数（2^（ld+1）-1）；否则递归计算左右子树的节点数并相加。这个方法其实是找满二叉树的根节点，满二叉树的节点数为2^（ld+1）-1。从而减少时间复杂度。<br>也可以用普通后序遍历的方式来实现，但是时间复杂度会高一些。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;平衡二叉树&quot;&gt;&lt;a href=&quot;#平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;&lt;/a&gt;平衡二叉树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/balanced-binary-tree</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>2026的第一篇blog</title>
    <link href="http://example.com/2026/01/01/2026%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/"/>
    <id>http://example.com/2026/01/01/2026%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/</id>
    <published>2025-12-31T16:24:15.000Z</published>
    <updated>2025-12-31T16:29:30.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h1><p>  今天是2026年的第一天，这一年里给自己几个目标吧：</p><ol><li>完成代码随想录打卡任务的所有题目</li><li>每个月跑100km</li><li>每天坚持背单词</li><li>通过英语六级</li><li>蓝桥杯获奖</li><li>跟上项目组的节奏，明年的人工智能比赛能有好的成绩</li><li>在kaggle上完成一个项目</li><li>找个对象（可能？）</li><li>希望看到这个blog的每一个人都能开开心心，如尝所愿！</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;新年快乐&quot;&gt;&lt;a href=&quot;#新年快乐&quot; class=&quot;headerlink&quot; title=&quot;新年快乐&quot;&gt;&lt;/a&gt;新年快乐&lt;/h1&gt;&lt;p&gt;  今天是2026年的第一天，这一年里给自己几个目标吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成代码随想录打卡任务的所有题目&lt;/li</summary>
      
    
    
    
    
    <category term="杂谈" scheme="http://example.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day14</title>
    <link href="http://example.com/2025/12/31/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day14/"/>
    <id>http://example.com/2025/12/31/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day14/</id>
    <published>2025-12-31T13:04:22.000Z</published>
    <updated>2025-12-31T16:13:48.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">翻转二叉树</a><br>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><h2 id="翻转二叉树-递归"><a href="#翻转二叉树-递归" class="headerlink" title="翻转二叉树-递归"></a>翻转二叉树-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            root.left,root.right = root.right,root.left</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>就是在前序遍历前交换左右子树</p><h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/description/">对称二叉树</a><br>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><h2 id="对称二叉树-递归"><a href="#对称二叉树-递归" class="headerlink" title="对称二叉树-递归"></a>对称二叉树-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.compare(root.left,root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">self,left,right</span>):</span><br><span class="line">        <span class="keyword">if</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> left.val != right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        outside = <span class="variable language_">self</span>.compare(left.left,right.right)</span><br><span class="line">        inside = <span class="variable language_">self</span>.compare(left.right,right.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inside <span class="keyword">and</span> outside</span><br></pre></td></tr></table></figure><p>在后续遍历的基础上，判断以 left 为根的子树和以 right 为根的子树，是否互为镜像，为了让两棵子树互为镜像，必须满足以下三个条件：<br>它们的根节点值必须相同。</p><ul><li>left 子树的左孩子，必须和 right 子树的右孩子互为镜像。</li><li>left 子树的右孩子，必须和 right 子树的左孩子互为镜像。</li></ul><h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">二叉树的最大深度</a><br>给你一个二叉树的根节点 root ，返回它的 最大深度 。</p><h2 id="二叉树的最大深度-递归"><a href="#二叉树的最大深度-递归" class="headerlink" title="二叉树的最大深度-递归"></a>二叉树的最大深度-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.getdeepth(root)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getdeepth</span>(<span class="params">self,node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftdeepth = <span class="variable language_">self</span>.getdeepth(node.left)</span><br><span class="line">        rightdeepth = <span class="variable language_">self</span>.getdeepth(node.right)</span><br><span class="line">        deepth = <span class="built_in">max</span>(leftdeepth,rightdeepth) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> deepth </span><br></pre></td></tr></table></figure><p>首先区分高度和深度</p><ul><li>高度：指的是从根节点到叶子节点的最长路径上的节点数。</li><li>深度：指的是从根节点到当前节点的路径上的节点数。<br>所以这里可以用根节点的高度来表示二叉树的最大深度，而求根节点的高度可以用后序遍历。<br>并且初始深度为0，当前节点的深度，等于其左右子树中较深的那一个的深度，再加上当前节点自己这一层</li></ul><h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">二叉树的最小深度</a><br>给你一个二叉树的根节点 root ，返回它的 最小深度 。</p><h2 id="二叉树的最小深度-递归"><a href="#二叉树的最小深度-递归" class="headerlink" title="二叉树的最小深度-递归"></a>二叉树的最小深度-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.getdep(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getdep</span>(<span class="params">self,node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftdpt = <span class="variable language_">self</span>.getdep(node.left)</span><br><span class="line">        rightdpt = <span class="variable language_">self</span>.getdep(node.right)</span><br><span class="line">        <span class="keyword">if</span> leftdpt == <span class="number">0</span> <span class="keyword">and</span> rightdpt:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightdpt</span><br><span class="line">        <span class="keyword">if</span> leftdpt <span class="keyword">and</span> rightdpt == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftdpt</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(rightdpt,leftdpt)+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里和最大深度的区别在于，当一个节点只有左子树或右子树时，最小深度是右子树或左子树的深度加1。因此要判断一下左右子树是否为空，为空则返回另一个子树的深度加1。然后将max替换为min即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;翻转二叉树&quot;&gt;&lt;a href=&quot;#翻转二叉树&quot; class=&quot;headerlink&quot; title=&quot;翻转二叉树&quot;&gt;&lt;/a&gt;翻转二叉树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/invert-binary-tree/d</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day13</title>
    <link href="http://example.com/2025/12/29/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day13/"/>
    <id>http://example.com/2025/12/29/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day13/</id>
    <published>2025-12-29T12:07:20.000Z</published>
    <updated>2025-12-30T15:09:07.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树的基本知识"><a href="#树的基本知识" class="headerlink" title="树的基本知识"></a>树的基本知识</h1><p>这个部分我暂时先空着，明天要考计算机组成原理与系统结构。</p><h1 id="树的遍历（前中后序）"><a href="#树的遍历（前中后序）" class="headerlink" title="树的遍历（前中后序）"></a>树的遍历（前中后序）</h1><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">二叉树的前序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">二叉树的中序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">二叉树的后序遍历</a><br>给你二叉树的根节点 root ，返回它节点值的 前序、中序、后序 遍历。</p><h2 id="树的遍历（前中后序）-递归"><a href="#树的遍历（前中后序）-递归" class="headerlink" title="树的遍历（前中后序）-递归"></a>树的遍历（前中后序）-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            dfs(node.left)</span><br><span class="line">            dfs(node.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个是前序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(node.left)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            dfs(node.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个是中序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            dfs(node.left)</span><br><span class="line">            dfs(node.right)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个是后序</p><h2 id="树的遍历（前中后序）-迭代"><a href="#树的遍历（前中后序）-迭代" class="headerlink" title="树的遍历（前中后序）-迭代"></a>树的遍历（前中后序）-迭代</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result  </span><br></pre></td></tr></table></figure><p>这是前序的迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>这是后序的迭代 </p><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历</a></p><blockquote><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        que = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            in_ = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(que)):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                in_.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:    </span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            result.append(in_)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这是二叉树的层序遍历代码，使用队列实现。每一层记录个数，然后遍历这个个数，将当前层的节点值加入到结果中，并且将当前层的子节点加入到队列中，在下一次遍历的时候，就可以遍历到下一层的节点了。</p><h1 id="二叉树的层序遍历-II"><a href="#二叉树的层序遍历-II" class="headerlink" title="二叉树的层序遍历 II"></a>二叉树的层序遍历 II</h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">107. 二叉树的层序遍历 II</a></p><blockquote><p>给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        que = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            in_ = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(que)):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                in_.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            result.append(in_)</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>这是二叉树的层序遍历 II 代码，和层序遍历的代码只有一行不同，就是在返回结果的时候，将结果反转一下即可。(就多了个反转)</p><h1 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h1><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">199. 二叉树的右视图</a></p><blockquote><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result=[]</span><br><span class="line">        que = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            n=<span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> i == n-<span class="number">1</span>:</span><br><span class="line">                    result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>就是在每一层遍历的时候，只记录当前层的最后一个节点，将其加入到结果中即可。</p><h1 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h1><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">637. 二叉树的层平均值</a></p><blockquote><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        que = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            n=<span class="built_in">len</span>(que)</span><br><span class="line">            in_ = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                in_ += cur.val</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            result.append(in_/n)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>就是在每一层遍历的时候，记录当前层的节点值的和，然后除以当前层的节点个数，即可得到当前层的平均值。<br>暂时到这里，明天开始就没课了，确实一旦松懈了一点就很麻烦了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树的基本知识&quot;&gt;&lt;a href=&quot;#树的基本知识&quot; class=&quot;headerlink&quot; title=&quot;树的基本知识&quot;&gt;&lt;/a&gt;树的基本知识&lt;/h1&gt;&lt;p&gt;这个部分我暂时先空着，明天要考计算机组成原理与系统结构。&lt;/p&gt;
&lt;h1 id=&quot;树的遍历（前中后序）&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day11</title>
    <link href="http://example.com/2025/12/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day11/"/>
    <id>http://example.com/2025/12/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day11/</id>
    <published>2025-12-27T04:33:10.000Z</published>
    <updated>2025-12-27T07:58:11.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h1><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">题目链接</a><br>根据 逆波兰表示法，求表达式的值。<br>有效的运算符包括 + ,  - ,  * ,  &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：<br>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><ul><li>示例 1：<br>输入: [“2”, “1”, “+”, “3”, “ * “]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</li><li>示例 2：<br>输入: [“4”, “13”, “5”, “&#x2F;“, “+”]<br>输出: 6<br>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</li><li>示例 3：<br>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “ * “, “&#x2F;“, “ * “, “17”, “+”, “5”, “+”]<br>输出: 22<br>解释:该算式转化为常见的中缀算术表达式为：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((10 * (6 / ((9 + 3) * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5     </span><br><span class="line">= ((10 * 0) + 17) + 5     </span><br><span class="line">= (0 + 17) + 5    </span><br><span class="line">= 17 + 5    </span><br><span class="line">= 22    </span><br></pre></td></tr></table></figure><blockquote><p>逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。<br> 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br> 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。（是一种二叉数树的后续遍历）<br> 逆波兰表达式主要有以下两个优点：<br> 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br> 适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。<hr></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&quot;+&quot;</span> <span class="keyword">or</span> i == <span class="string">&#x27;-&#x27;</span> <span class="keyword">or</span> i == <span class="string">&#x27;*&#x27;</span> <span class="keyword">or</span> i == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                a = stack.pop()</span><br><span class="line">                b = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    stack.append(a+b)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    stack.append(b-a)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    stack.append(a*b)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(b/a)) <span class="comment"># 向零取整用int（b/a）直接截断小数部分</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                stack.append(<span class="built_in">int</span>(i))</span><br><span class="line">        <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure><p>使用栈来保存数字，遇到运算符就弹出栈顶的两个数字进行计算，然后把结果压回栈中。最后栈中剩下的数字就是结果。</p><h1 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">题目链接</a><br>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回滑动窗口中的最大值。</p><ul><li>示例 1：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> :</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (<span class="variable language_">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.que = deque()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self,value</span>): <span class="comment">#这里啥时候队列可能为空呢</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.que <span class="keyword">and</span> value == <span class="variable language_">self</span>.que[<span class="number">0</span>]:<span class="comment">#队列不为空且遍历的值等于队口</span></span><br><span class="line">            <span class="variable language_">self</span>.que.popleft()   <span class="comment">#弹的是最大（对头在左）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.que <span class="keyword">and</span> value &gt; <span class="variable language_">self</span>.que[-<span class="number">1</span>]:</span><br><span class="line">            <span class="variable language_">self</span>.que.pop()</span><br><span class="line">        <span class="variable language_">self</span>.que.append(value)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        que = Queue()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            que.push(nums[i])</span><br><span class="line">        result.append(que.get())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,<span class="built_in">len</span>(nums)):</span><br><span class="line">            que.pop(nums[i-k]) <span class="comment">#例如加入第四个元素前要移除第一个</span></span><br><span class="line">            que.push(nums[i])</span><br><span class="line">            result.append(que.get())</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>下面是ai的带注释的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonotonicQueue</span>:  <span class="comment"># 改名：明确是单调递减队列，避免语义混淆</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.que = deque()  <span class="comment"># 存储 nums 的元素（也可存索引，更灵活）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_left</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        滑动窗口移动时，移除窗口左边界的元素（仅当该元素是队首时，因为队首是最大值）</span></span><br><span class="line"><span class="string">        此时队列可能为空：必须先判断 self.que 非空</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.que <span class="keyword">and</span> value == <span class="variable language_">self</span>.que[<span class="number">0</span>]:  <span class="comment"># 队列非空 + 左边界元素是队首（最大值）</span></span><br><span class="line">            <span class="variable language_">self</span>.que.popleft()  <span class="comment"># 弹出队首（移除窗口外的最大值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        加入当前元素，维持队列单调递减：</span></span><br><span class="line"><span class="string">        移除队列中所有比当前元素小的元素（这些元素不可能成为后续窗口的最大值）</span></span><br><span class="line"><span class="string">        此时队列可能为空：空队列直接 append 即可</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.que <span class="keyword">and</span> <span class="variable language_">self</span>.que[-<span class="number">1</span>] &lt; value:  <span class="comment"># 队列非空 + 队尾元素 &lt; 当前元素</span></span><br><span class="line">            <span class="variable language_">self</span>.que.pop()  <span class="comment"># 移除队尾（从右弹出，deque.pop() 是O(1)）</span></span><br><span class="line">        <span class="variable language_">self</span>.que.append(value)  <span class="comment"># 加入当前元素，队列仍保持递减</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_max</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取当前窗口最大值（队首），必须保证调用前队列非空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        <span class="comment"># 边界情况处理（避免队列空时调用 get_max）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k == <span class="number">0</span> <span class="keyword">or</span> k &gt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        que = MonotonicQueue()</span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第一步：初始化第一个窗口（前 k 个元素）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            que.push(nums[i])</span><br><span class="line">        <span class="comment"># 第一个窗口的最大值加入结果（此时队列非空，因为 k&lt;=len(nums) 且 nums 非空）</span></span><br><span class="line">        result.append(que.get_max())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二步：滑动窗口（从第 k 个元素开始，到最后一个元素）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 1. 移除窗口左边界的元素（i-k 是当前窗口的左边界索引）</span></span><br><span class="line">            left_value = nums[i - k]  <span class="comment"># 窗口要移除的左边界元素</span></span><br><span class="line">            que.remove_left(left_value)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 2. 加入当前窗口的右边界元素（第 i 个元素）</span></span><br><span class="line">            que.push(nums[i])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 3. 记录当前窗口的最大值（队列非空）</span></span><br><span class="line">            result.append(que.get_max())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试案例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="built_in">print</span>(s.maxSlidingWindow([<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="number">3</span>))  <span class="comment"># 输出 [3,3,5,5,6,7]（正确）</span></span><br><span class="line">    <span class="built_in">print</span>(s.maxSlidingWindow([], <span class="number">3</span>))  <span class="comment"># 输出 []（边界处理）</span></span><br><span class="line">    <span class="built_in">print</span>(s.maxSlidingWindow([<span class="number">1</span>], <span class="number">1</span>))  <span class="comment"># 输出 [1]（边界处理）</span></span><br><span class="line">    <span class="built_in">print</span>(s.maxSlidingWindow([<span class="number">1</span>,-<span class="number">1</span>], <span class="number">2</span>))  <span class="comment"># 输出 [1]（边界处理）</span></span><br></pre></td></tr></table></figure><p>这道题是用单调队列来解决的，单调队列是指队列中的元素是单调递增或递减的。<br>那如何保证队列中的元素是单调递减的呢？<br>当有新元素加入时，我们将队列中所有比新元素小的元素都弹出，直到队列为空或者队列尾部的元素大于等于新元素为止。这样就保证了队列中的元素是单调递减的。</p><ul><li>关于我在视频弹幕上遇到的一个情况5231，其实解决这个的方式是在push方法中加入一个判断，当队列非空且队尾元素小于等于新元素时，弹出队尾元素，直到队列为空或者队列尾部的元素大于等于新元素为止。（这样3进去的之前2就被弹出了）<hr></li><li>为啥要判断队列非空？<br><br>初始阶段：刚实例化 Queue 时（<strong>init</strong> 后），self.que &#x3D; deque() 是空的，此时调用 pop&#x2F;get 都会操作空队列。<br><br>窗口滑动时移除元素后：比如窗口内所有元素都被 pop 方法移除（例如滑动窗口移动时，队首元素是前一个窗口的最大值，被弹出后队列无其他元素）。<br><br>nums 数组本身为空或 k&#x3D;0：当输入 nums &#x3D; [] 或 k&#x3D;0 时，循环不执行 push，队列始终为空。<hr></li></ul><h1 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h1><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">题目链接</a></p><blockquote><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p></blockquote><p>示例 1:</p><ul><li>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</li><li>输出: [1,2]<br></li></ul><p>示例 2:</p><ul><li>输入: nums &#x3D; [1], k &#x3D; 1</li><li>输出: [1]<br></li></ul><p>提示：</p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 $O(n \log n)$ , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="built_in">dir</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">dir</span>[nums[i]] = <span class="built_in">dir</span>.get(nums[i],<span class="number">0</span>) + <span class="number">1</span> <span class="comment">#key不存在就设为0，存在就加1</span></span><br><span class="line">        que = []</span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">dir</span>.items():</span><br><span class="line">            heapq.heappush(que,(value,key)) <span class="comment">#注意value在前，因为按照value排序的</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(que) &gt; k:</span><br><span class="line">                heapq.heappop(que)</span><br><span class="line">        result = [<span class="number">0</span>] * k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>): <span class="comment">#第一个-1取不到所以就是0开始</span></span><br><span class="line">            result[i] = heapq.heappop(que)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>使用哈希表统计每个元素的频率，然后使用小顶堆维护前 k 个高频元素。<br>小顶堆的大小为 k，每次加入一个元素后，如果堆的大小超过 k，就弹出堆顶元素。<br>解释一下堆，就是完全二叉树，每个节点的左右子树都是堆，且根节点是堆顶。<br>小顶堆的性质是，堆顶元素是堆中最小的元素。<br>大顶堆的性质是，堆顶元素是堆中最大的元素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逆波兰表达式求值&quot;&gt;&lt;a href=&quot;#逆波兰表达式求值&quot; class=&quot;headerlink&quot; title=&quot;逆波兰表达式求值&quot;&gt;&lt;/a&gt;逆波兰表达式求值&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/evaluate</summary>
      
    
    
    
    <category term="算法学习——栈和队列" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day10</title>
    <link href="http://example.com/2025/12/26/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day10/"/>
    <id>http://example.com/2025/12/26/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day10/</id>
    <published>2025-12-26T13:25:17.000Z</published>
    <updated>2025-12-26T15:01:16.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">题目链接</a></p><blockquote><p>使用栈实现队列的下列操作：<br>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。<br>示例:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);</span><br><span class="line">queue.peek();  // 返回 1</span><br><span class="line">queue.pop();   // 返回 1</span><br><span class="line">queue.empty(); // 返回 false</span><br></pre></td></tr></table></figure><p>说明:<br>你只能使用标准的栈操作 – 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack_in = []</span><br><span class="line">        <span class="variable language_">self</span>.stack_out = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.stack_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stack_out :</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stack_out.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.stack_in)):</span><br><span class="line">                <span class="variable language_">self</span>.stack_out.append(<span class="variable language_">self</span>.stack_in.pop())</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stack_out.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = <span class="variable language_">self</span>.pop()</span><br><span class="line">        <span class="variable language_">self</span>.stack_out.append(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span>  (<span class="variable language_">self</span>.stack_in <span class="keyword">or</span> <span class="variable language_">self</span>.stack_out)</span><br></pre></td></tr></table></figure><p>由于栈是先进后出，队列是先进先出，所以需要两个栈来实现队列的功能。实现负负得正。<br>然后查看头节点可以用出队列的代码复用，得到后记得再入栈</p><h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">题目链接</a></p><blockquote><p>使用队列实现栈的下列操作：</p></blockquote><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p>注意:</p><ul><li>你只能使用队列的基本操作– 也就是 push to back, peek&#x2F;pop from front, size, 和 is empty 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.deq = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.deq.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.deq)-<span class="number">1</span>):</span><br><span class="line">                <span class="variable language_">self</span>.deq.append(<span class="variable language_">self</span>.deq.popleft())</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.deq.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.deq[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.deq</span><br></pre></td></tr></table></figure><p>使用一个队列来实现栈的功能。入栈直接入队列即可。出栈需要将队列中的元素依次出队列再入队列，直到只剩下最后一个元素，这个元素就是栈顶元素，直接出队列即可。</p><h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">题目链接</a></p><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：</p></blockquote><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。<br>示例 1：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) %<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                stack.append(<span class="string">&quot;)&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                stack.append(<span class="string">&quot;]&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                stack.append(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> i != stack[-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>这道题是用栈来实现的，遍历字符串，遇到左括号就入栈，遇到右括号就出栈，判断是否匹配。提前为空、栈顶元素不匹配、字符串遍历完成后栈不为空，这三种情况都是无效的。<br>我遇到了一个很有意思的错误<code>elif not stack or i != stack.pop():</code><br>原先我的代码是这样的，但是报错确实在十六行告诉我空栈不能pop，我原本以为是因为python的判断条件是左右会都判断，哪怕左边已经为真了，但其实问题是我在判断栈顶元素是否匹配时，直接用了pop方法，提前把最后一元素出栈这会导致栈为空后续没法pop。</p><h1 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h1><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">题目链接</a></p><blockquote><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p></blockquote><ul><li><p>示例：</p></li><li><p>输入：”abbaca”</p></li><li><p>输出：”ca”</p></li><li><p>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。<br>之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。<br>提示：</p></li><li><p>1 &lt;&#x3D; S.length &lt;&#x3D; 20000</p></li><li><p>S 仅由小写英文字母组成。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> i == stack[-<span class="number">1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure><p>这道题是用栈来实现的，遍历字符串，遇到字符就入栈，遇到和栈顶元素相同的字符就出栈。最后栈中的元素就是没有重复项的字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用栈实现队列&quot;&gt;&lt;a href=&quot;#用栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;用栈实现队列&quot;&gt;&lt;/a&gt;用栈实现队列&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/implement-queue-</summary>
      
    
    
    
    <category term="算法学习——栈和队列" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>一些关于编程语言的知识</title>
    <link href="http://example.com/2025/12/26/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2025/12/26/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%9F%A5%E8%AF%86/</id>
    <published>2025-12-26T12:40:16.000Z</published>
    <updated>2025-12-27T05:12:30.938Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容来自ai（豆包），为了我自己的学习，我把它记录下来。</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="一、STL-到底是什么？"><a href="#一、STL-到底是什么？" class="headerlink" title="一、STL 到底是什么？"></a>一、STL 到底是什么？</h3><p>STL 是 <strong>Standard Template Library（标准模板库）</strong> 的缩写，是 C++ 标准库的核心组成部分，本质是一套 <strong>通用、可复用的模板类&#x2F;函数库</strong>。</p><p>简单说：</p><ul><li>它是 C++ 官方提供的“工具集”，不用自己写基础数据结构（比如栈、队列、数组、链表）和算法（比如排序、查找、遍历），直接调用就行；</li><li>核心优势是 <strong>模板化</strong>（跨数据类型通用，比如一个 <code>vector</code> 既可以存 <code>int</code>，也能存 <code>string</code>）、<strong>高效</strong>（底层用最优算法实现）、<strong>标准化</strong>（所有符合 C++ 标准的编译器都支持，比如 GCC、Clang、MSVC）。</li></ul><p>STL 主要包含 6 大组件，日常开发最常用的是前 4 个：</p><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td>容器（Container）</td><td>存储数据的“容器”（比如 <code>vector</code> 动态数组、<code>list</code> 链表、<code>stack</code> 栈、<code>map</code> 字典）</td></tr><tr><td>算法（Algorithm）</td><td>操作容器数据的算法（比如 <code>sort</code> 排序、<code>find</code> 查找、<code>reverse</code> 反转）</td></tr><tr><td>迭代器（Iterator）</td><td>连接容器和算法的“桥梁”（类似指针，遍历容器数据）</td></tr><tr><td>适配器（Adaptor）</td><td>对现有容器“包装改造”，改变其接口（比如 <code>stack</code> 就是对其他容器的适配器）</td></tr><tr><td>函数对象（Functor）</td><td>行为类似函数的对象（配合算法使用，比如自定义排序规则）</td></tr><tr><td>分配器（Allocator）</td><td>负责容器的内存分配&#x2F;释放（底层细节，用户一般不用关心）</td></tr></tbody></table><h3 id="二、STL-中-stack-的实现原理"><a href="#二、STL-中-stack-的实现原理" class="headerlink" title="二、STL 中 stack 的实现原理"></a>二、STL 中 <code>stack</code> 的实现原理</h3><p><code>stack</code>（栈）的核心特性是 <strong>LIFO（后进先出）</strong>：只能从“栈顶”插入（<code>push</code>）、删除（<code>pop</code>）和访问（<code>top</code>）数据，不能随机访问中间元素。</p><h4 id="关键结论：stack-不是独立的容器，而是「容器适配器」"><a href="#关键结论：stack-不是独立的容器，而是「容器适配器」" class="headerlink" title="关键结论：stack 不是独立的容器，而是「容器适配器」"></a>关键结论：<code>stack</code> 不是独立的容器，而是「容器适配器」</h4><p>STL 的 <code>stack</code> 本身不存储数据，它是对一个 <strong>底层容器（Underlying Container）</strong> 进行“包装”，限制了其接口（只暴露栈需要的 <code>push/pop/top</code> 等），底层数据的存储、内存管理全靠这个“被包装的容器”。</p><h4 id="1-默认底层容器是什么？"><a href="#1-默认底层容器是什么？" class="headerlink" title="1. 默认底层容器是什么？"></a>1. 默认底层容器是什么？</h4><p>C++ 标准规定，<code>stack</code> 的 <strong>默认底层容器是 <code>deque</code></strong>（双端队列）。<br>选择 <code>deque</code> 的原因很简单：<code>deque</code> 支持 <strong>两端高效插入&#x2F;删除</strong>（时间复杂度 O(1)），而栈只需要操作“一端”（栈顶），用 <code>deque</code> 刚好匹配，且 <code>deque</code> 没有 <code>vector</code> 扩容时的拷贝开销，效率更高。</p><h4 id="2-可以自定义底层容器吗？"><a href="#2-可以自定义底层容器吗？" class="headerlink" title="2. 可以自定义底层容器吗？"></a>2. 可以自定义底层容器吗？</h4><p>可以！<code>stack</code> 是模板类，允许用户指定底层容器，只要这个容器支持以下 3 个核心操作即可：</p><ul><li><code>push_back()</code>：在尾部插入元素（栈顶对应容器尾部）；</li><li><code>pop_back()</code>：删除尾部元素；</li><li><code>back()</code>：访问尾部元素。</li></ul><p>满足条件的容器有 <code>vector</code>、<code>list</code>、<code>deque</code>，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 默认底层容器：deque</span></span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; st1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 自定义底层容器为 vector</span></span><br><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;&gt; st2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 自定义底层容器为 list</span></span><br><span class="line">std::stack&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; st3;</span><br></pre></td></tr></table></figure><h4 id="3-stack-的核心接口实现（伪代码）"><a href="#3-stack-的核心接口实现（伪代码）" class="headerlink" title="3. stack 的核心接口实现（伪代码）"></a>3. <code>stack</code> 的核心接口实现（伪代码）</h4><p><code>stack</code> 的接口非常简单，本质就是“转发”到底层容器的对应操作，伪代码能直观体现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = std::deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container c;  <span class="comment">// 底层容器（被包装的对象）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 入栈：调用底层容器的 push_back()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出栈：调用底层容器的 pop_back()（注意：不返回元素）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问栈顶：调用底层容器的 back()</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 栈是否为空：调用底层容器的 empty()</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 栈的大小：调用底层容器的 size()</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从伪代码能看出来：<code>stack</code> 没有自己的“数据存储逻辑”，所有操作都依赖底层容器，它只做了一件事——<strong>隐藏底层容器的其他接口（比如 <code>vector</code> 的 <code>operator[]</code> 随机访问），只暴露栈需要的 LIFO 接口</strong>。</p><h3 id="三、补充：stack-为什么不叫“容器”而叫“适配器”？"><a href="#三、补充：stack-为什么不叫“容器”而叫“适配器”？" class="headerlink" title="三、补充：stack 为什么不叫“容器”而叫“适配器”？"></a>三、补充：<code>stack</code> 为什么不叫“容器”而叫“适配器”？</h3><ul><li>容器（比如 <code>vector</code>、<code>list</code>）：是“原始存储容器”，支持完整的元素访问&#x2F;操作（比如 <code>vector</code> 可以随机访问、<code>list</code> 可以双向遍历）；</li><li>适配器（比如 <code>stack</code>、<code>queue</code>）：是“包装器”，不提供原始存储，而是基于现有容器，通过“限制接口”来实现特定的数据结构行为（栈的 LIFO、队列的 FIFO）。</li></ul><p>简单说：适配器是“改造现有容器”，而容器是“原生存储数据”。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>STL 是 C++ 标准库的核心，是通用的模板工具集，包含容器、算法、迭代器等组件；</li><li>STL 的 <code>stack</code> 是 <strong>容器适配器</strong>，底层不存数据，依赖其他容器实现；</li><li>默认底层容器是 <code>deque</code>，也可指定 <code>vector</code> 或 <code>list</code>（需支持 <code>push_back/pop_back/back</code>）；</li><li><code>stack</code> 的所有接口（<code>push/pop/top</code>）都是转发到底层容器的对应操作，核心是实现 LIFO 特性。</li></ol><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p><code>from collections import deque</code> 是 Python 中导入内置容器类 <code>deque</code> 的标准语法，以下是关于 <code>deque</code> 的详细解析、用法和场景说明：</p><h3 id="一、核心基础：什么是-deque？"><a href="#一、核心基础：什么是-deque？" class="headerlink" title="一、核心基础：什么是 deque？"></a>一、核心基础：什么是 deque？</h3><ul><li><strong>全称</strong>：Double-Ended Queue（双端队列）</li><li><strong>本质</strong>：Python 标准库 <code>collections</code> 模块提供的高效双端队列数据结构，支持<strong>两端（队首&#x2F;队尾）的快速插入和删除操作</strong>。</li><li><strong>与 list 的区别</strong>：<ul><li><code>list</code> 基于数组实现，队首插入&#x2F;删除（如 <code>list.insert(0, x)</code>、<code>list.pop(0)</code>）时间复杂度为 <code>O(n)</code>（需移动所有元素）；</li><li><code>deque</code> 基于双向链表（或类似优化结构）实现，两端操作时间复杂度均为 <code>O(1)</code>，效率远超 <code>list</code>。</li></ul></li></ul><h3 id="二、基本用法（需先导入-deque）"><a href="#二、基本用法（需先导入-deque）" class="headerlink" title="二、基本用法（需先导入 deque）"></a>二、基本用法（需先导入 <code>deque</code>）</h3><h4 id="1-初始化-deque"><a href="#1-初始化-deque" class="headerlink" title="1. 初始化 deque"></a>1. 初始化 deque</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 空队列</span></span><br><span class="line">dq = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 从可迭代对象（列表、字符串、元组等）初始化</span></span><br><span class="line">dq1 = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])       <span class="comment"># deque([1, 2, 3])</span></span><br><span class="line">dq2 = deque(<span class="string">&quot;abc&quot;</span>)           <span class="comment"># deque([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span></span><br><span class="line">dq3 = deque((<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), maxlen=<span class="number">5</span>)  <span class="comment"># 限制最大长度为5（超出会自动丢弃另一端元素）</span></span><br></pre></td></tr></table></figure><h4 id="2-两端插入操作（核心优势）"><a href="#2-两端插入操作（核心优势）" class="headerlink" title="2. 两端插入操作（核心优势）"></a>2. 两端插入操作（核心优势）</h4><table><thead><tr><th>方法</th><th>功能</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>append(x)</code></td><td>队尾添加元素 x</td><td><code>dq1.append(4)</code></td><td><code>deque([1, 2, 3, 4])</code></td></tr><tr><td><code>appendleft(x)</code></td><td>队首添加元素 x</td><td><code>dq1.appendleft(0)</code></td><td><code>deque([0, 1, 2, 3, 4])</code></td></tr><tr><td><code>extend(iterable)</code></td><td>队尾批量添加可迭代对象</td><td><code>dq1.extend([5, 6])</code></td><td><code>deque([0,1,2,3,4,5,6])</code></td></tr><tr><td><code>extendleft(iterable)</code></td><td>队首批量添加（逆序插入）</td><td><code>dq1.extendleft([-2, -1])</code></td><td><code>deque([-1, -2, 0,1,2,3,4,5,6])</code></td></tr></tbody></table><blockquote><p>注意 <code>extendleft</code>：会将可迭代对象的元素<strong>逆序</strong>插入队首（如 <code>extendleft([a,b])</code> 等价于 <code>appendleft(b)</code> 后 <code>appendleft(a)</code>）。</p></blockquote><h4 id="3-两端删除操作"><a href="#3-两端删除操作" class="headerlink" title="3. 两端删除操作"></a>3. 两端删除操作</h4><table><thead><tr><th>方法</th><th>功能</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>pop()</code></td><td>队尾删除并返回元素</td><td><code>dq1.pop()</code></td><td>返回 <code>6</code>，队列变为 <code>deque([-1,-2,0,1,2,3,4,5])</code></td></tr><tr><td><code>popleft()</code></td><td>队首删除并返回元素</td><td><code>dq1.popleft()</code></td><td>返回 <code>-1</code>，队列变为 <code>deque([-2,0,1,2,3,4,5])</code></td></tr><tr><td><code>clear()</code></td><td>清空队列</td><td><code>dq1.clear()</code></td><td><code>deque([])</code></td></tr></tbody></table><h4 id="4-其他常用方法"><a href="#4-其他常用方法" class="headerlink" title="4. 其他常用方法"></a>4. 其他常用方法</h4><ul><li><p><strong><code>maxlen</code> 属性</strong>：获取队列最大长度（初始化时指定，不可修改）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dq = deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(dq.maxlen)  <span class="comment"># 3</span></span><br><span class="line">dq.append(<span class="number">4</span>)      <span class="comment"># 超出maxlen，队首元素1被自动丢弃</span></span><br><span class="line"><span class="built_in">print</span>(dq)         <span class="comment"># deque([2, 3, 4])</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>rotate(n)</code></strong>：队列旋转（默认 <code>n=1</code>，队尾元素移到队首；<code>n=-1</code> 则队首元素移到队尾）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dq = deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">dq.rotate(<span class="number">1</span>)   <span class="comment"># 右旋转1位：4→队首</span></span><br><span class="line"><span class="built_in">print</span>(dq)      <span class="comment"># deque([4, 1, 2, 3])</span></span><br><span class="line">dq.rotate(-<span class="number">2</span>)  <span class="comment"># 左旋转2位：4、1→队尾</span></span><br><span class="line"><span class="built_in">print</span>(dq)      <span class="comment"># deque([2, 3, 4, 1])</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>count(x)</code></strong>：统计元素 x 的出现次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]).count(<span class="number">2</span>)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>remove(x)</code></strong>：删除第一个出现的元素 x（不存在则抛 <code>ValueError</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dq = deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line">dq.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(dq)  <span class="comment"># deque([1, 3, 2])</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="三、典型应用场景"><a href="#三、典型应用场景" class="headerlink" title="三、典型应用场景"></a>三、典型应用场景</h3><h4 id="1-实现队列（FIFO：先进先出）"><a href="#1-实现队列（FIFO：先进先出）" class="headerlink" title="1. 实现队列（FIFO：先进先出）"></a>1. 实现队列（FIFO：先进先出）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">queue = deque()</span><br><span class="line"><span class="comment"># 入队（队尾添加）</span></span><br><span class="line">queue.append(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">queue.append(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="comment"># 出队（队首删除）</span></span><br><span class="line"><span class="built_in">print</span>(queue.popleft())  <span class="comment"># &quot;a&quot;</span></span><br><span class="line"><span class="built_in">print</span>(queue.popleft())  <span class="comment"># &quot;b&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-实现栈（LIFO：后进先出）"><a href="#2-实现栈（LIFO：后进先出）" class="headerlink" title="2. 实现栈（LIFO：后进先出）"></a>2. 实现栈（LIFO：后进先出）</h4><p>（直接用 <code>append()</code> 和 <code>pop()</code>，等价于栈的压栈&#x2F;出栈）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack = deque()</span><br><span class="line">stack.append(<span class="number">1</span>)</span><br><span class="line">stack.append(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(stack.pop())  <span class="comment"># 2（后进先出）</span></span><br><span class="line"><span class="built_in">print</span>(stack.pop())  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h4 id="3-滑动窗口问题（利用-maxlen-自动维护窗口大小）"><a href="#3-滑动窗口问题（利用-maxlen-自动维护窗口大小）" class="headerlink" title="3. 滑动窗口问题（利用 maxlen 自动维护窗口大小）"></a>3. 滑动窗口问题（利用 <code>maxlen</code> 自动维护窗口大小）</h4><p>例如：求数组中每个位置的前 k 个元素的平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_average</span>(<span class="params">nums, k</span>):</span><br><span class="line">    dq = deque(maxlen=k)</span><br><span class="line">    averages = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        dq.append(num)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(dq) == k:  <span class="comment"># 窗口满了才计算平均值</span></span><br><span class="line">            averages.append(<span class="built_in">sum</span>(dq)/k)</span><br><span class="line">    <span class="keyword">return</span> averages</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sliding_average([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">3</span>))  <span class="comment"># [2.0, 3.0, 4.0, 5.0]</span></span><br></pre></td></tr></table></figure><h4 id="4-广度优先搜索（BFS）"><a href="#4-广度优先搜索（BFS）" class="headerlink" title="4. 广度优先搜索（BFS）"></a>4. 广度优先搜索（BFS）</h4><p>BFS 算法的核心是用队列存储待访问节点，<code>deque</code> 的 <code>popleft()</code> 效率远高于 <code>list.pop(0)</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    queue = deque([root])</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()  <span class="comment"># 队首出队</span></span><br><span class="line">        result.append(node.val)</span><br><span class="line">        <span class="comment"># 子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><ul><li><code>deque</code> 是 Python 中<strong>高效双端队列</strong>，核心优势是两端插入&#x2F;删除 <code>O(1)</code> 时间复杂度；</li><li>功能覆盖队列、栈、滑动窗口等场景，比 <code>list</code> 更适合频繁操作两端的场景；</li><li>需通过 <code>from collections import deque</code> 导入，支持 <code>maxlen</code>、<code>rotate</code> 等实用功能，是 Python 开发中高频使用的容器类。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下内容来自ai（豆包），为了我自己的学习，我把它记录下来。&lt;/p&gt;
&lt;h2 id=&quot;STL&quot;&gt;&lt;a href=&quot;#STL&quot; class=&quot;headerlink&quot; title=&quot;STL&quot;&gt;&lt;/a&gt;STL&lt;/h2&gt;&lt;h3 id=&quot;一、STL-到底是什么？&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day9</title>
    <link href="http://example.com/2025/12/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day9/"/>
    <id>http://example.com/2025/12/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day9/</id>
    <published>2025-12-25T14:22:45.000Z</published>
    <updated>2025-12-25T14:48:31.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h1><blockquote><p>给定一个字符串，逐个翻转字符串中的每个单词。</p></blockquote><ul><li>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</li><li>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>示例 3：<br>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br>方法一：split()分割加列表反转</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s_list = s.split()</span><br><span class="line">        s_list = s_list[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(s_list)</span><br></pre></td></tr></table></figure><p>方法二：双指针法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = s.split()</span><br><span class="line">        left,right = <span class="number">0</span>,<span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left],s[right]=s[right],s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(s)</span><br></pre></td></tr></table></figure><p>视频的方法今天有点来不及</p><h1 id="右旋字符串"><a href="#右旋字符串" class="headerlink" title="右旋字符串"></a>右旋字符串</h1><blockquote><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。<br>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。<br>输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。<br>输出：输出共一行，为进行了右旋转操作后的字符串。</p></blockquote><ul><li>样例输入：<br>2<br>abcdefg<br>样例输出：<br>fgabcde</li></ul><p>数据范围：1 &lt;&#x3D; k &lt; 10000, 1 &lt;&#x3D; s.length &lt; 10000</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s=<span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(s[-n:]+s[:-n])</span><br></pre></td></tr></table></figure><p>额，今天考马原上午都在看马原，额，但是不得不说，python真的太刁了，字符串切片操作真的是太方便了，但是我还是要提醒一下，字符串是不可变的，所以切片操作不会改变原字符串，而是返回一个新的字符串。</p><h1 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h1><p>感觉马原要挂科。明明我背那么久了，结果全背错了，张冠李戴给我玩明白了，我服了。一想到考研要考政治我就绝望</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;翻转字符串里的单词&quot;&gt;&lt;a href=&quot;#翻转字符串里的单词&quot; class=&quot;headerlink&quot; title=&quot;翻转字符串里的单词&quot;&gt;&lt;/a&gt;翻转字符串里的单词&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    <category term="算法学习——字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day8</title>
    <link href="http://example.com/2025/12/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day8/"/>
    <id>http://example.com/2025/12/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day8/</id>
    <published>2025-12-24T11:33:56.000Z</published>
    <updated>2025-12-24T13:04:56.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p></blockquote><ul><li>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</li><li>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        j=<span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)//<span class="number">2</span>):</span><br><span class="line">            s[i],s[j] = s[j],s[i]</span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这道题的思路是用双指针的方式，分别指向头尾，然后交换位置，循环判断条件就到中间位置（比长度的一半小）。</p><h1 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/">leetcode链接</a></p><blockquote><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。<br>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p></blockquote><ul><li>示例:<br>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “bacdfeg”</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">c_r</span>(<span class="params">s_</span>):</span><br><span class="line">            left,right = <span class="number">0</span>,<span class="built_in">len</span>(s_)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                s_[left],s_[right]=s_[right],s_[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s_</span><br><span class="line"></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        s_list=<span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            s_list[i:i+k] = c_r(s_list[i:i+k])</span><br><span class="line">            i += <span class="number">2</span> * k</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s_list)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s), <span class="number">2</span>*k):</span><br><span class="line">            s[i:i+k] = s[i:i+k][::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure><p>这道题的主要特点是切片的方式是以2k为步长，每次取k个字符进行反转。<br>并且python的切片操作是可以超出索引范围的，会自动截断为有效范围。（Python 切片的容错特性：无需判断剩余字符长度，i:i+k 自动截断为有效范围，让 “反转前 k 个 &#x2F; 反转全部剩余” 的要求自然满足），i相当于一个指针，每次移动2k个位置，只要能移动在下一次循环就进行切片。</p><h1 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h1><blockquote><p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。</p></blockquote><ul><li>例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。<br>对于输入字符串 “a5b”，函数应该将其转换为 “anumberb”<br>输入：一个字符串 s,s 仅包含小写字母和数字字符。<br>输出：打印一个新的字符串，其中每个数字字符都被替换为了number<br>样例输入：a1b2c3<br>样例输出：anumberbnumbercnumber<br>数据范围：1 &lt;&#x3D; s.length &lt; 10000。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">input</span>()</span><br><span class="line">count_num = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> n <span class="keyword">if</span> i.isdigit())</span><br><span class="line">count = count_num * <span class="number">5</span> + <span class="built_in">len</span>(n) <span class="comment">#记得count_num是数字字符的个数，每个数字字符替换为number后会增加5个字符，所以是*5</span></span><br><span class="line">n_list = [<span class="string">&#x27;&#x27;</span>] * count</span><br><span class="line">o_p = <span class="built_in">len</span>(n)- <span class="number">1</span></span><br><span class="line">n_p = count - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> o_p &gt;= <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> n[o_p].isdigit():</span><br><span class="line">        n_list[n_p-<span class="number">5</span>:n_p+<span class="number">1</span>] = <span class="string">&quot;number&quot;</span> <span class="comment">#注意切片是位置到位置，不能直接[n_p-5:6]这种操作</span></span><br><span class="line">        n_p -= <span class="number">6</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        n_list[n_p]=n[o_p]</span><br><span class="line">        n_p -= <span class="number">1</span></span><br><span class="line">    o_p -= <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(n_list))</span><br></pre></td></tr></table></figure><p>这道题还是用双指针的方式，一个指向原字符串的尾，一个指向新字符串的尾，根据是否为数字字符来判断是否需要替换。<br>如果是c语言从后向前可以避免每次替换后需要移动后面的字符的问题。python因为字符串是不可变的，所以需要先将字符串转换为列表，修改后再转换为字符串。<br>然后就是要两个指针一一对应，一个指向原字符串的当前字符，一个指向新字符串的当前位置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反转字符串&quot;&gt;&lt;a href=&quot;#反转字符串&quot; class=&quot;headerlink&quot; title=&quot;反转字符串&quot;&gt;&lt;/a&gt;反转字符串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给</summary>
      
    
    
    
    <category term="算法学习——字符串" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day7</title>
    <link href="http://example.com/2025/12/23/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day7/"/>
    <id>http://example.com/2025/12/23/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day7/</id>
    <published>2025-12-23T12:08:42.000Z</published>
    <updated>2025-12-23T15:16:20.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四数相加II"><a href="#四数相加II" class="headerlink" title="四数相加II"></a>四数相加II</h1><blockquote><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。<br>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p></blockquote><ul><li>例如:<br>输入:<br>A &#x3D; [ 1, 2]<br>B &#x3D; [-2,-1]<br>C &#x3D; [-1, 2]<br>D &#x3D; [ 0, 2]<br>输出:<br>2<br>解释:<br>两个元组如下:<br>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0<br>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        t_set = &#123;&#125;</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                t_set[i+j] = t_set.get(i+j,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums3:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums4:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>-(i+j) <span class="keyword">in</span> t_set.keys():</span><br><span class="line">                    count += t_set[<span class="number">0</span>-(i+j)]</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>这道题就是将四个数分成两组前两个数一组，并把他们的和作为key，出现的次数作为value，存到一个哈希表中。<br>然后遍历后两个数的组合，判断0-(i+j)是否在哈希表中，如果在，就把出现的次数加到count中（注意加的是value的值不是一，原因是不用去重）。</p><h1 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h1><blockquote><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。<br>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p></blockquote><ul><li>例如:<br>输入: ransomNote &#x3D; “a”, magazine &#x3D; “b”<br>输出: false<br>输入: ransomNote &#x3D; “aa”, magazine &#x3D; “ab”<br>输出: false<br>输入: ransomNote &#x3D; “aa”, magazine &#x3D; “aab”<br>输出: true</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        a_hash = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            a_hash[<span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ransomNote:</span><br><span class="line">            <span class="keyword">if</span> a_hash[<span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                a_hash[<span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这道题就是用一个哈希表来记录 magazine 中的字符出现的次数，然后遍历 ransomNote 中的字符，判断是否在哈希表中，如果在，就把哈希表中对应的值减一。<br>直到遇到了0，就说明 magazine 中的字符不能构成 ransomNote 中的字符，返回 False。跟昨天第一题很像</p><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><blockquote><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。<br>注意： 答案中不可以包含重复的三元组。</p></blockquote><ul><li>示例：<br>给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result.append([nums[i],nums[left],nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>用了双指针的思路<br>首先先对数组排序，然后for循环用i作为第一个数，left作为第二个数，right作为第三个数，三个数求和判断是否等于0，如果等于0，就把这三个数加入到结果中。<br>如果大于0，就把right减一，如果小于0，就把left加一。<br>直到left大于等于right，就说明这个数组合完了，就可以继续下一个数了。<br>注意点<strong>去重操作是i和i-1比较，left和left+1比较，right和right-1比较</strong>，为啥这样的，因为i是基准，如果i和i+1判断，把下一个i跳了，i就像边界一样，left就指不到被跳的i的那个位置了，比如-2 -1 -1 0 2，但是i继续加一以后，发现和之前的i一样，这个i就可去掉了，这里不会重复是上一组的i已经用过这个顺序了，例如-1 -1 0 0 1 2，然后left和right就是和自己的下一个数比较即可，而且不会遗漏，哪怕有连续的left挑掉，right也会移动过去，不像i是基准</p><h1 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h1><blockquote><p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。<br>注意：<br>答案中不可以包含重复的四元组。</p></blockquote><ul><li>示例： 给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] &gt; target//<span class="number">4</span> :</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">#这里不能return result</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] &gt; target <span class="keyword">and</span> target &gt; <span class="number">0</span>: </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left,right = j+<span class="number">1</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    sum_=nums[i]+nums[j]+nums[left]+nums[right]</span><br><span class="line">                    <span class="keyword">if</span> sum_ == target:</span><br><span class="line">                        result.append([nums[i],nums[j],nums[left],nums[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right-<span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> sum_ &gt; target    :</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span> :</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>就是在i的基础上加了一个j也作为基准，然后在i和j的基础上用双指针的思路，left和right作为第三个数和第四个数，判断是否等于target，如果等于0，就把这四个数加入到结果中。<br>我再思考一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四数相加II&quot;&gt;&lt;a href=&quot;#四数相加II&quot; class=&quot;headerlink&quot; title=&quot;四数相加II&quot;&gt;&lt;/a&gt;四数相加II&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i,</summary>
      
    
    
    
    <category term="算法学习——哈希表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>python中我遇到的语法问题</title>
    <link href="http://example.com/2025/12/23/python%E4%B8%AD%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/12/23/python%E4%B8%AD%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98/</id>
    <published>2025-12-23T11:57:37.000Z</published>
    <updated>2025-12-26T13:58:57.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>1.python中查询key是否存在直接用<code>key in dict</code>，并且时间复杂度为O(1)因为字典底层是哈希表实现的。<br>2.字典的get方法可以设置默认值，比如<code>dict.get(key, default_value)</code>，如果key不存在则返回default_value。<br>3.分别使用<code>dict.keys()</code>、<code>dict.values()</code>、<code>dict.items()</code>可以获取字典的所有key、value、key-value对。<strong>注意</strong>，这三个都是方法，括号别忘了写。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>1.空数组的创建可以用<code>[]</code>或者<code>list()</code>，比如<code>a = []</code>或者<code>a = list()</code>。如果设置初值可以用<code>a = [0]*n</code>或者<code>a = list([0]*n)</code>。<br>2. 数组的切片可以用<code>array[start:end:step]</code>，比如<code>a[1:3]</code>表示获取数组a中索引从1到2的元素（不包括3），<code>a[::-1]</code>表示将数组a反转。<br>3. Python 中切片赋值时，右侧的赋值对象必须是可迭代对象，字符串 “number” 会被自动拆解为单个字符的可迭代序列，再逐个赋值到切片对应的位置(res[new_index-5:new_index+1] &#x3D; “number”)</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ol><li>python中排序可以用<code>list.sort()</code>或者<code>sorted(list)</code>，前者是在原数组上排序，后者是返回一个新的排序后的数组。</li><li>排序默认是升序排序，如果要降序排序可以用<code>list.sort(reverse=True)</code>或者<code>sorted(list, reverse=True)</code>。</li></ol><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ol><li>python中字符串是不可变的，所以如果要修改字符串中的某个字符，只能先将字符串转换为列表，修改后再转换为字符串。</li><li>字符串的拼接可以用<code>+</code>号，也可以用<code>join()</code>方法，比如<code>&#39;a&#39;+&#39;b&#39;</code>或者<code>&#39;a&#39;.join([&#39;b&#39;, &#39;c&#39;])</code>。</li><li>判断字符串是否只包含数字可以用<code>str.isdigit()</code>方法，比如<code>&#39;123&#39;.isdigit()</code>返回True，<code>&#39;123a&#39;.isdigit()</code>返回False。</li></ol><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><ol><li>生成器表达式是一种简洁的创建生成器的方式，它的语法和列表推导式类似，但是用圆括号括起来，比如<code>(x for x in range(5))</code>。</li></ol><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ol><li><p>deque（发音：deck），它是 Python 标准库 collections 中的「双端队列」，实现了在队列两端高效插入和删除元素的功能。相比于列表，deque 在头尾操作时具有更好的性能表现，时间复杂度为 O(1)。</p></li><li><p>deque 提供了 append()、appendleft()、pop()、popleft() 等方法，分别用于在队列的右端插入元素、左端插入元素、从右端删除元素、从左端删除元素。</p></li><li><p>deque 支持索引访问，比如<code>deque[0]</code>表示获取队列的队头元素，<code>deque[-1]</code>表示获取队列的队尾元素。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h1&gt;&lt;p&gt;1.python中查询key是否存在直接用&lt;code&gt;key in dict&lt;/code&gt;，并且时间复杂度为O(1)因为字典底层是哈希表实现</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day6</title>
    <link href="http://example.com/2025/12/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day6/"/>
    <id>http://example.com/2025/12/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day6/</id>
    <published>2025-12-22T12:53:47.000Z</published>
    <updated>2025-12-22T15:01:21.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1><blockquote><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br>-示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true<br>-示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false<br>说明: 你可以假设字符串只包含小写字母。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="built_in">hash</span> = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="built_in">hash</span>[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> t_ <span class="keyword">in</span> t:</span><br><span class="line">            <span class="built_in">hash</span>[<span class="built_in">ord</span>(t_) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">hash</span>:</span><br><span class="line">            <span class="keyword">if</span> h != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这道题的思路是：用一个长度为26的数组来存储每个字母出现的次数，遍历字符串s时，对应字母的位置加1，遍历字符串t时，对应字母的位置减1。最后遍历数组，<br>如果数组里面的元素都为0，说明两个字符串是字母异位词，返回True，否则返回False。<br>讲一下我觉得比较有意思的地方就是这个下标转化的方式，通过减去a的ascll值得到一个在0-25之间的下标，对应数组的位置，这样就可以统计每个字母出现的次数。（有点像凯撒密码，也算是一种哈希函数的实现）</p><h1 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h1><p>题意：给定两个数组，编写一个函数来计算它们的交集。<br><img src="/images/codecrazy/dsy6-T2.png" alt="T2题目案例"><br>说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hash_set = <span class="built_in">set</span>()</span><br><span class="line">        hash_list = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            hash_set.add(i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> hash_set:</span><br><span class="line">                hash_list.add(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(hash_list)</span><br></pre></td></tr></table></figure><p>也是用哈希表来存储数组里面的元素，然后存放在集合里面，因为集合里面要求元素是唯一的，再把数组1里集合元素和数组2里元素进行对比，如果存在就放到另一个集合里面，<br>最后返回集合转换为列表即可。</p><h1 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h1><blockquote><p>编写一个算法来判断一个数 n 是不是快乐数。<br> 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。<br> 如果 n 是快乐数就返回 True ；不是，则返回 False 。</p></blockquote><ul><li>示例：<br>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 &#x3D; 82<br>8^2 + 2^2 &#x3D; 68<br>6^2 + 8^2 &#x3D; 100<br>1^2 + 0^2 + 0^2 &#x3D; 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        set_=<span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            n = <span class="variable language_">self</span>.self_sum(n)</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> set_:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                set_.add(n)         </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">self_sum</span>(<span class="params">self,n</span>):   </span><br><span class="line">        new_n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n :</span><br><span class="line">            n1 = n % <span class="number">10</span></span><br><span class="line">            n = n // <span class="number">10</span></span><br><span class="line">            new_n += n1 ** <span class="number">2</span> </span><br><span class="line">        <span class="keyword">return</span> new_n</span><br></pre></td></tr></table></figure><p>这道题的思路是：用一个集合来存储每次计算得到的结果，如果结果重复出现，说明进入了循环，不是快乐数。如果结果为1，说明是快乐数。<br>利用哈希表来存储每次计算的结果，一旦出现重复的结果，说明进入了循环，不是快乐数。</p><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p></blockquote><ul><li>示例:<br>给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9<br>因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9<br>所以返回 [0, 1]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>=&#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)): <span class="comment">#遍历数组</span></span><br><span class="line">          <span class="keyword">if</span> target-nums[i] <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dir</span>: <span class="comment">#如果目标值减去当前值不在字典中</span></span><br><span class="line">              <span class="built_in">dir</span>[nums[i]] = i</span><br><span class="line">          <span class="keyword">else</span> :</span><br><span class="line">              <span class="keyword">return</span> [<span class="built_in">dir</span>[target-nums[i]],i]</span><br></pre></td></tr></table></figure><p>这道题在我的第一篇blog有，感兴趣的可以去看看，这道题是哈希表里面map的应用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有效的字母异位词&quot;&gt;&lt;a href=&quot;#有效的字母异位词&quot; class=&quot;headerlink&quot; title=&quot;有效的字母异位词&quot;&gt;&lt;/a&gt;有效的字母异位词&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s </summary>
      
    
    
    
    <category term="算法学习——哈希表" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
</feed>
