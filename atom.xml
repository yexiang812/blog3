<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yeye 想变强</title>
  
  <subtitle>技术&amp;生活blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2026-01-20T12:38:58.036Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yeyeyefirst</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码随想录-day34</title>
    <link href="http://example.com/2026/01/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day34/"/>
    <id>http://example.com/2026/01/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day34/</id>
    <published>2026-01-19T14:57:02.000Z</published>
    <updated>2026-01-20T12:38:58.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p><a href="https://leetcode.cn/problems/fibonacci-number/">斐波那契数列</a><br>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：<br><br>F(0) &#x3D; 0，F(1) &#x3D; 1<br><br>F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1<br><br>给定 n ，请计算 F(n) 。<br></p><p>示例 1：</p><blockquote><p>输入：n &#x3D; 2<br><br>输出：1<br><br>解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1<br></p></blockquote><p>示例 2：</p><blockquote><p>输入：n &#x3D; 3<br><br>输出：2<br><br>解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2<br></p></blockquote><p>示例 3：</p><blockquote><p>输入：n &#x3D; 4<br><br>输出：3<br><br>解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3<br></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.fib(n-<span class="number">2</span>) + <span class="variable language_">self</span>.fib(n-<span class="number">1</span>) </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/fibonacci-number</summary>
      
    
    
    
    <category term="算法学习——动态规划" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day-32</title>
    <link href="http://example.com/2026/01/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day32/"/>
    <id>http://example.com/2026/01/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day32/</id>
    <published>2026-01-18T13:39:32.000Z</published>
    <updated>2026-01-19T14:57:07.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h1><p><a href="https://leetcode.cn/problems/merge-intervals/">合并区间</a><br>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。<br></p><p>示例 1：</p><blockquote><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br><br>输出：[[1,6],[8,10],[15,18]]<br><br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br></p></blockquote><p>示例 2：</p><blockquote><p>输入：intervals &#x3D; [[1,4],[4,5]]<br><br>输出：[[1,5]]<br><br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。<br></p></blockquote><p>示例 3：</p><blockquote><p>输入：intervals &#x3D; [[4,7],[1,4]]<br><br>输出：[[1,7]]<br><br>解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。<br></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(intervals) &lt;= <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">return</span> intervals</span><br><span class="line">        result = []</span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        result.append(intervals[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &lt;= result[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                result[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(result[-<span class="number">1</span>][<span class="number">1</span>],intervals[i][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                result.append(intervals[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>首先设置初始数组为第一个区间(作为结果数组)<br><br>再判断重叠区间，重叠区间的判断条件是当前区间的起始位置小于等于结果数组中最后一个区间的结束位置。<br><br>如果重叠，则更新结果数组中最后一个区间的结束位置为两者的最大值。<br><br>如果不重叠，则将当前区间添加到结果数组中。<br></p><h1 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h1><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/">单调递增的数字</a><br>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。<br><br>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。<br></p><p>示例 1:</p><blockquote><p>输入: n &#x3D; 10<br><br>输出: 9<br></p></blockquote><p>示例 2:</p><blockquote><p>输入: n &#x3D; 1234<br><br>输出: 1234<br></p></blockquote><p>示例 3:</p><blockquote><p>输入: n &#x3D; 332<br><br>输出: 299<br></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">monotoneIncreasingDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        strn = <span class="built_in">str</span>(n)</span><br><span class="line">        flag = <span class="built_in">len</span>(strn)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strn)-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>): <span class="comment">#因为后续用i-1和i比较，不包含第一个来防止越界访问</span></span><br><span class="line">            <span class="keyword">if</span> strn[i-<span class="number">1</span>] &gt; strn[i]:</span><br><span class="line">                flag = i</span><br><span class="line">                strn = strn[<span class="number">0</span>:i-<span class="number">1</span>]+<span class="built_in">str</span>(<span class="built_in">int</span>(strn[i-<span class="number">1</span>])-<span class="number">1</span>)+strn[i:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(flag,<span class="built_in">len</span>(strn)):</span><br><span class="line">            strn = strn[:i] + <span class="string">&quot;9&quot;</span> + strn[i+<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(strn)</span><br></pre></td></tr></table></figure><p>首先将整数转换为字符串以便逐位处理。<br><br>从右向左遍历字符串，找到第一个不满足单调递增条件的位置i。<br><br>将该位置的数字减1，并将该位置后面的所有数字都设为9。<br><br>将处理后的字符串转换为整数并返回。<br></p><h1 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h1><p><a href="https://leetcode.cn/problems/binary-tree-cameras/">监控二叉树</a><br>给定一个二叉树，我们在树的节点上安装摄像头。<br><br>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br><br>计算监控树的所有节点所需的最小摄像头数量。<br><br><img src="/images/codecrazy/day32-T3.png" alt="题目示例"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 0：未覆盖 1：有摄像头 2：有覆盖</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCameraCover</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="variable language_">self</span>.result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.dfs(root,<span class="variable language_">self</span>.result) == <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,cur,result</span>):</span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        left = <span class="variable language_">self</span>.dfs(cur.left,<span class="variable language_">self</span>.result)</span><br><span class="line">        right = <span class="variable language_">self</span>.dfs(cur.right,<span class="variable language_">self</span>.result)</span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">2</span> <span class="keyword">and</span> right == <span class="number">2</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">or</span> right == <span class="number">0</span> :</span><br><span class="line">            <span class="variable language_">self</span>.result += <span class="number">1</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">1</span> <span class="keyword">or</span> right == <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> </span><br></pre></td></tr></table></figure><p>首先要给每个节点设置状态，0：未覆盖 1：有摄像头 2：有覆盖<br><br>并让叶子节点的子节点设置为2（有覆盖），因为叶子节点没有子节点，所以设置为0（未覆盖）。<br><br>如果一个节点的左右子节点都是2（有覆盖），那么该节点就是0（未覆盖）。<br><br>如果一个节点的左右子节点有一个是0（未覆盖），那么该节点就是1（有摄像头）（）优先级比下面的高。<br><br>如果一个节点的左右子节点都是1（有摄像头），那么该节点就是2（有覆盖）。<br><br>还有第四种情况就是到根节点了，并设置为未覆盖，但是根节点可没有父节点，因此要改为1（有摄像头）。<br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;合并区间&quot;&gt;&lt;a href=&quot;#合并区间&quot; class=&quot;headerlink&quot; title=&quot;合并区间&quot;&gt;&lt;/a&gt;合并区间&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/merge-intervals/&quot;&gt;合并区间&lt;/</summary>
      
    
    
    
    <category term="算法学习——贪心" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day31</title>
    <link href="http://example.com/2026/01/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day31/"/>
    <id>http://example.com/2026/01/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day31/</id>
    <published>2026-01-17T14:23:15.000Z</published>
    <updated>2026-01-17T15:02:02.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h1><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a><br>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。<br><br>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。<br><br>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。<br></p><p>示例 1：</p><blockquote><p>输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]<br><br>输出：2<br><br>解释：气球可以用2支箭来爆破:<br></p></blockquote><ul><li>在x &#x3D; 6处射出箭，击破气球[2,8]和[1,6]。</li><li>在x &#x3D; 11处发射箭，击破气球[10,16]和[7,12]。</li></ul><p>示例 2：</p><blockquote><p>输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]<br><br>输出：4<br><br>解释：每个气球需要射出一支箭，总共需要4支箭。<br></p></blockquote><p>示例 3：</p><blockquote><p>输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]<br><br>输出：2<br><br>解释：气球可以用2支箭来爆破:<br></p></blockquote><ul><li>在x &#x3D; 2处发射箭，击破气球[1,2]和[2,3]。<br></li><li>在x &#x3D; 4处射出箭，击破气球[3,4]和[4,5]。<br></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMinArrowShots</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        points.sort(key =<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(points)):</span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; points[i-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i-<span class="number">1</span>][<span class="number">1</span>],points[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h1><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">无重叠区间</a><br>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。<br><br>注意 只在一点上接触的区间是 不重叠的。例如 [1, 2] 和 [2, 3] 是不重叠的。<br></p><p>示例 1:</p><blockquote><p>输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]<br><br>输出: 1<br><br>解释: 移除 [1,3] 后，剩下的区间没有重叠。<br></p></blockquote><p>示例 2:</p><blockquote><p>输入: intervals &#x3D; [ [1,2], [1,2], [1,2] ]<br><br>输出: 2<br><br>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。<br></p></blockquote><p>示例 3:</p><blockquote><p>输入: intervals &#x3D; [ [1,2], [2,3] ]<br><br>输出: 0<br><br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。<br></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= intervals[i-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                intervals[i][<span class="number">1</span>] = <span class="built_in">min</span>(intervals[i][<span class="number">1</span>],intervals[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - result</span><br></pre></td></tr></table></figure><p>这一题就是在上一题的基础上，合并重叠的区域并计算数量，总的减去数量就是重叠的数量（注意：只在一点上接触的区间是不重叠的，多个取等）。</p><h1 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h1><p><a href="https://leetcode.cn/problems/partition-labels/">划分字母区间</a><br>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 “ababcc” 能够被分为 [“abab”, “cc”]，但类似 [“aba”, “bcc”] 或 [“ab”, “ab”, “cc”] 的划分是非法的。<br><br>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。<br><br>返回一个表示每个字符串片段的长度的列表。<br></p><p>示例 1：</p><blockquote><p>输入：s &#x3D; “ababcbacadefegdehijhklij”<br><br>输出：[9,7,8]<br><br>解释：<br><br>划分结果为 “ababcbaca”、”defegde”、”hijhklij” 。<br><br>每个字母最多出现在一个片段中。<br><br>像 “ababcbacadefegde”, “hijhklij” 这样的划分是错误的，因为划分的片段数较少。 <br></p></blockquote><p>示例 2：</p><blockquote><p>输入：s &#x3D; “eccbbbbdec”<br><br>输出：[10]<br></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partitionLabels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        has = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            has[s[i]] = i</span><br><span class="line">        result = []</span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            end = <span class="built_in">max</span>(end,has[c])</span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                result.append(end-start+<span class="number">1</span>)</span><br><span class="line">                start = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>用哈希表记录每个字符最后出现的位置，然后遍历字符串，记录当前字符最后出现的位置，当遍历到的位置等于当前字符最后出现的位置时（实际上片段中的结束是在更新的），说明当前片段结束，将当前片段的长度加入结果列表中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用最少数量的箭引爆气球&quot;&gt;&lt;a href=&quot;#用最少数量的箭引爆气球&quot; class=&quot;headerlink&quot; title=&quot;用最少数量的箭引爆气球&quot;&gt;&lt;/a&gt;用最少数量的箭引爆气球&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/probl</summary>
      
    
    
    
    <category term="算法学习——贪心" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day30</title>
    <link href="http://example.com/2026/01/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day30/"/>
    <id>http://example.com/2026/01/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day30/</id>
    <published>2026-01-16T11:49:34.000Z</published>
    <updated>2026-01-16T13:57:26.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h1><p><a href="https://leetcode.cn/problems/gas-station/">加油站</a><br>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br><br>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br><br>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。<br></p><p>示例 1:</p><blockquote><p>输入: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]<br><br>输出: 3<br><br>解释:<br><br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br><br>开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油<br><br>开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油<br><br>开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油<br><br>开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油<br><br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br><br>因此，3 可为起始索引。<br></p></blockquote><p>示例 2:</p><blockquote><p>输入: gas &#x3D; [2,3,4], cost &#x3D; [3,4,3]<br>输出: -1<br><br>解释:<br><br>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br><br>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br><br>开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油<br><br>开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油<br><br>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br><br>因此，无论怎样，你都不可能绕环路行驶一周。<br></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            dle = gas[i] - cost[i]</span><br><span class="line">            total += dle</span><br><span class="line">            cur += dle</span><br><span class="line">            <span class="keyword">if</span> cur &lt; <span class="number">0</span>:</span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> total &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure><h1 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h1><p><a href="https://leetcode.cn/problems/candy/">分发糖果</a><br>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。<br><br>你需要按照以下要求，给这些孩子分发糖果：<br><br>每个孩子至少分配到 1 个糖果。<br><br>相邻两个孩子中，评分更高的那个会获得更多的糖果。<br><br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。<br><br>示例 1：</p><blockquote><p>输入：ratings &#x3D; [1,0,2]<br><br>输出：5<br><br>解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。<br></p></blockquote><p>示例 2：</p><blockquote><p>输入：ratings &#x3D; [1,2,2]<br><br>输出：4<br><br>解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。<br><br>     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。<br></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(ratings)</span><br><span class="line">        candies = n * [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i-<span class="number">1</span>]:</span><br><span class="line">                candies[i] = candies[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i+<span class="number">1</span>]:</span><br><span class="line">                candies[i] = <span class="built_in">max</span>(candies[i+<span class="number">1</span>]+<span class="number">1</span>,candies[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(candies)</span><br></pre></td></tr></table></figure><ul><li>先从左到右遍历一遍，如果当前孩子评分比前一个孩子高，则当前孩子糖果数为前一个孩子糖果数加一。</li><li>然后从右到左遍历一遍，如果当前孩子评分比后一个孩子高，则当前孩子糖果数为后一个孩子糖果数加一。(注意要取当前孩子糖果数和后一个孩子糖果数加一的较大值)</li><li>最后将所有孩子的糖果数相加即为所需的最少糖果数目。</li></ul><h1 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h1><p><a href="https://leetcode.cn/problems/lemonade-change/">柠檬水找零</a><br>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。<br><br>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。<br><br>注意，一开始你手头没有任何零钱。<br><br>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。<br></p><p>示例 1：</p><blockquote><p>输入：bills &#x3D; [5,5,5,10,20]<br><br>输出：true<br><br>解释：<br><br>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。<br><br>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。<br><br>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。<br><br>由于所有客户都得到了正确的找零，所以我们输出 true。<br></p></blockquote><p>示例 2：</p><blockquote><p>输入：bills &#x3D; [5,5,10,10,20]<br><br>输出：false<br><br>解释：<br><br>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。<br><br>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。<br><br>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。<br><br>由于不是每位顾客都得到了正确的找零，所以答案是 false。<br></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lemonadeChange</span>(<span class="params">self, bills: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        change1 = <span class="number">0</span></span><br><span class="line">        change2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> bills[<span class="number">0</span>] != <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bills)):</span><br><span class="line">            <span class="keyword">if</span> bills[i] == <span class="number">5</span>:</span><br><span class="line">                change1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> bills[i] == <span class="number">10</span> :</span><br><span class="line">                <span class="keyword">if</span> change1 &gt;= <span class="number">1</span>:</span><br><span class="line">                    change1 -= <span class="number">1</span></span><br><span class="line">                    change2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">            <span class="keyword">if</span> bills[i] == <span class="number">20</span> :</span><br><span class="line">                <span class="keyword">if</span> change1 &gt;= <span class="number">1</span> <span class="keyword">and</span> change2 &gt;= <span class="number">1</span>:</span><br><span class="line">                    change1 -= <span class="number">1</span></span><br><span class="line">                    change2 -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> change1 &gt;= <span class="number">3</span>:</span><br><span class="line">                    change1 -= <span class="number">3</span></span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>用change1记录5美元的数量，change2记录10美元的数量。</li><li>遍历账单数组，对于每个账单：<ul><li>如果是5美元，change1加一。</li><li>如果是10美元，若change1大于等于1，则change1减一，change2加一；否则返回False。</li><li>如果是20美元，若change1大于等于1且change2大于等于1，则change1减一，change2减一；若change1大于等于3，则change1减三；否则返回False。</li></ul></li><li>最后返回True。</li></ul><h1 id="按照身高重建队列"><a href="#按照身高重建队列" class="headerlink" title="按照身高重建队列"></a>按照身高重建队列</h1><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">按照身高重建队列</a><br>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。<br><br>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。<br></p><p>示例 1：</p><blockquote><p>输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br><br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]<br><br>解释：<br><br>队列重新构造如下：<br></p></blockquote><ul><li>第 1 个人，[5,0]，没有身高更高或相等的人在他前面。<br></li><li>第 2 个人，[7,0]，没有身高更高或相等的人在他前面。<br></li><li>第 3 个人，[5,2]，有 2 个身高更高或相等的人在他前面，即 [7,0] 和 [7,1]。<br></li><li>第 4 个人，[6,1]，有 1 个身高更高或相等的人在他前面，即 [7,0]。<br></li><li>第 5 个人，[4,4]，有 4 个身高更高或相等的人在他前面，即 [7,0]、[7,1]、[5,0] 和 [5,2]。<br></li><li>第 6 个人，[7,1]，有 1 个身高更高或相等的人在他前面，即 [7,0]。<br></li></ul><p>示例 2：</p><blockquote><p>输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br><br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]<br><br>解释：<br><br>队列重新构造如下：<br></p></blockquote><ul><li>第 1 个人，[4,0]，没有身高更高或相等的人在他前面。<br></li><li>第 2 个人，[5,0]，没有身高更高或相等的人在他前面。<br></li><li>第 3 个人，[2,2]，有 2 个身高更高或相等的人在他前面，即 [6,0] 和 [5,0]。<br></li><li>第 4 个人，[3,2]，有 2 个身高更高或相等的人在他前面，即 [6,0] 和 [5,0]。<br></li><li>第 5 个人，[1,4]，有 4 个身高更高或相等的人在他前面，即 [6,0]、[5,0]、[4,0] 和 [3,2]。<br></li><li>第 6 个人，[6,0]，没有身高更高或相等的人在他前面。<br></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        people.sort(key = <span class="keyword">lambda</span> x:(-x[<span class="number">0</span>],x[<span class="number">1</span>])) <span class="comment">#第一个元素从大到小，第二个元素从小到大</span></span><br><span class="line">        que = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> people:</span><br><span class="line">            que.insert(i[<span class="number">1</span>],i) <span class="comment">#把排好的元组按照元素2的值插入</span></span><br><span class="line">        <span class="keyword">return</span> que</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="comment"># 先按照h维度的身高顺序从高到低排序。确定第一个维度</span></span><br><span class="line">        <span class="comment"># lambda返回的是一个元组：当-x[0](维度h）相同时，再根据x[1]（维度k）从小到大排序</span></span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        que = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据每个元素的第二个维度k，贪心算法，进行插入</span></span><br><span class="line">        <span class="comment"># people已经排序过了：同一高度时k值小的排前面。</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            que.insert(p[<span class="number">1</span>], p)</span><br><span class="line">        <span class="keyword">return</span> que</span><br></pre></td></tr></table></figure><p>思路上类似分糖果，一项一项的完成，先按照身高h从高到低排序，若身高相同则按照k值从小到大排序，再根据k值插入到队列中。</p><ul><li>先按照身高h从高到低排序，若身高相同则按照k值从小到大排序。</li><li>遍历排序后的数组，对于每个元素p：<ul><li>插入到队列que的第p[1]个位置。</li></ul></li><li>最后返回que。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;加油站&quot;&gt;&lt;a href=&quot;#加油站&quot; class=&quot;headerlink&quot; title=&quot;加油站&quot;&gt;&lt;/a&gt;加油站&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/gas-station/&quot;&gt;加油站&lt;/a&gt;&lt;br&gt;在一条</summary>
      
    
    
    
    <category term="算法学习——贪心" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day29</title>
    <link href="http://example.com/2026/01/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day29/"/>
    <id>http://example.com/2026/01/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day29/</id>
    <published>2026-01-14T13:15:23.000Z</published>
    <updated>2026-01-16T11:49:08.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a><br>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。<br><br>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。<br><br>返回 你能获得的 最大 利润 。<br></p><p>示例 1：</p><blockquote><p>输入：prices &#x3D; [7,1,5,3,6,4]<br><br> 输出：7<br><br> 解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4。<br><br>随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3。<br><br>最大总利润为 4 + 3 &#x3D; 7 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：prices &#x3D; [1,2,3,4,5]<br><br>输出：4<br><br>解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4。<br><br>最大总利润为 4 。<br></p></blockquote><p>示例 3：</p><blockquote><p>输入：prices &#x3D; [7,6,4,3,1]<br><br>输出：0<br><br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。<br></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] -prices[i-<span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                result.append(prices[i] -prices[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(result)</span><br></pre></td></tr></table></figure><p>贪心算法，局部最优：收集每天的正利润，全局最优：求得最大利润。</p><h1 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h1><p><a href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a><br>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。<br><br>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。<br>   </p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [2,3,1,1,4]<br><br>输出：true<br><br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<br></p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [3,2,1,0,4]<br><br>输出：false<br><br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。<br></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cover = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= cover:</span><br><span class="line">            cover = <span class="built_in">max</span>(nums[i]+i,cover)</span><br><span class="line">            <span class="keyword">if</span> cover &gt;= <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> </span><br></pre></td></tr></table></figure><ul><li>i 只能在覆盖范围内移动，所以i &lt;&#x3D; cover</li><li>每次更新覆盖范围cover &#x3D; max(nums[i]+i,cover)</li></ul><h1 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h1><p><a href="https://leetcode.cn/problems/jump-game-ii/">跳跃游戏 II</a><br>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。<br><br>你的目标是使用最少的跳跃次数到达数组的最后一个下标。<br><br>假设你总是可以到达数组的最后一个下标。<br></p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [2,3,1,1,4]<br><br>输出：2<br><br>解释：跳到最后一个下标需要 2 步。<br><br>第一步，从下标 0 跳到下标 1, 跳 1 步。<br><br>第二步，从下标 1 跳到下标 4, 跳 3 步。<br></p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [2,3,0,1,4]<br><br>输出：2<br></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="built_in">next</span> = <span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            <span class="built_in">next</span> = <span class="built_in">max</span>(i+nums[i],<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">if</span> i == cur:</span><br><span class="line">                result+=<span class="number">1</span></span><br><span class="line">                cur = <span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">next</span> &gt;= <span class="built_in">len</span>(nums)-<span class="number">1</span> :</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><ul><li>cur表示当前覆盖范围的边界</li><li>next表示下一次跳跃能到达的最远位置</li><li>当i到达cur时，说明需要进行下一次跳跃，更新cur为next</li><li>遍历时只需要遍历到len(nums)-2，因为到达最后一个位置不需要跳跃</li></ul><h1 id="k次取反后最大化的数组和"><a href="#k次取反后最大化的数组和" class="headerlink" title="k次取反后最大化的数组和"></a>k次取反后最大化的数组和</h1><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">K 次取反后最大化的数组和</a><br>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：<br><br>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。<br><br>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。<br><br>以这种方式修改数组后，返回数组 可能的最大和 。<br></p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [4,2,3], k &#x3D; 1<br><br>输出：5<br><br>解释：选择下标 1 ，nums 变为 [4,-2,3] 。<br></p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [3,-1,0,2], k &#x3D; 3<br><br>输出：6<br><br>解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。<br></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestSumAfterKNegations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort(key = <span class="keyword">lambda</span> x:<span class="built_in">abs</span>(x),reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                nums[i] *= -<span class="number">1</span></span><br><span class="line">                k -=  <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            nums[-<span class="number">1</span>] *= -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure><ul><li>先将数组按绝对值从大到小排序，这样可以优先处理绝对值大的负数</li><li>遍历数组，将负数变为正数，直到k用完或者没有负数为止</li><li>如果k还有剩余且为奇数，则将绝对值最小的数变为负数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;买卖股票的最佳时机-II&quot;&gt;&lt;a href=&quot;#买卖股票的最佳时机-II&quot; class=&quot;headerlink&quot; title=&quot;买卖股票的最佳时机 II&quot;&gt;&lt;/a&gt;买卖股票的最佳时机 II&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/p</summary>
      
    
    
    
    <category term="算法学习——贪心" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day-28</title>
    <link href="http://example.com/2026/01/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day28/"/>
    <id>http://example.com/2026/01/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day28/</id>
    <published>2026-01-13T14:27:12.000Z</published>
    <updated>2026-01-14T13:04:56.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h1><p><a href="https://leetcode.cn/problems/assign-cookies/">分发饼干</a></p><blockquote><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。<br><br>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。</p></blockquote><hr>示例 1:<ul><li>输入: g &#x3D; [1,2,3], s &#x3D; [1,1]</li><li>输出: 1</li><li>解释:<br>你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。<br>所以你应该输出 1。<br></li></ul><p>示例 2:</p><ul><li>输入: g &#x3D; [1,2], s &#x3D; [1,2,3]</li><li>输出: 2</li><li>解释:<br>你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出 2。<hr></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(g):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> g[index] &lt;= s[i]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure><p>感觉掌握的很差，不是很理解云里雾里的过的</p><h1 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h1><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">摆动序列</a><br>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</li><li>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br></li></ul><p>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。<br><br>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。<br><br>示例 1：</p><blockquote><p>输入：nums &#x3D; [1,7,4,9,2,5]<br><br>输出：6<br><br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [1,17,5,10,13,15,10,5,16,8]<br><br>输出：7 <br><br>解释：这个序列包含几个长度为 7 摆动序列。<br><br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。<br></p></blockquote><p>示例 3：</p><blockquote><p>输入：nums &#x3D; [1,2,3,4,5,6,7,8,9]<br><br>输出：2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        curdif = <span class="number">0</span></span><br><span class="line">        predif = <span class="number">0</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            curdif = nums[i+<span class="number">1</span>] - nums[i]</span><br><span class="line">            <span class="keyword">if</span> (predif &lt;= <span class="number">0</span> <span class="keyword">and</span> curdif &gt; <span class="number">0</span>) <span class="keyword">or</span> (predif &gt;= <span class="number">0</span> <span class="keyword">and</span> curdif &lt; <span class="number">0</span>):</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                predif = curdif</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>主要是找那个尖尖的数量（也可以是圆润的），然后最后一个默认添加</p><h1 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h1><p><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></p><blockquote><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br><br>子数组 是数组中的一个连续部分。<br></p></blockquote><p>示例 1：</p><ul><li>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</li><li>输出：6</li><li>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br></li></ul><p>示例 2：</p><ul><li>输入：nums &#x3D; [1]</li><li>输出：1<br></li></ul><p>示例 3：</p><ul><li>输入：nums &#x3D; [5,4,-1,7,8]</li><li>输出：23<br></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            count += i</span><br><span class="line">            <span class="keyword">if</span> count &gt; result:</span><br><span class="line">                result = count</span><br><span class="line">            <span class="keyword">if</span> count &lt; <span class="number">0</span>:</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>局部最大，如果局部最大为负数，那么就从下一个数开始计算（用置零来实现）<br>把昨天的补了，今天的暂时不行，明天考英语</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分发饼干&quot;&gt;&lt;a href=&quot;#分发饼干&quot; class=&quot;headerlink&quot; title=&quot;分发饼干&quot;&gt;&lt;/a&gt;分发饼干&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/assign-cookies/&quot;&gt;分发饼干&lt;/a</summary>
      
    
    
    
    <category term="算法学习——贪心" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day27</title>
    <link href="http://example.com/2026/01/12/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day27/"/>
    <id>http://example.com/2026/01/12/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day27/</id>
    <published>2026-01-12T13:59:33.000Z</published>
    <updated>2026-01-12T15:22:08.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="非递减子序列"><a href="#非递减子序列" class="headerlink" title="非递减子序列"></a>非递减子序列</h1><p><a href="https://leetcode.cn/problems/increasing-subsequences/description/">491. 非递减子序列</a></p><blockquote><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。<br><br>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况    </p></blockquote><ul><li>数组的子序列是由数组删除一些元素（也可能不删除）而不改变剩余元素顺序形成的序列。</li><li>例如，[4,6,7] 是数组 [4,5,6,7] 的一个子序列。</li><li>题目数据保证答案中至少有一个非递减子序列。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,nums,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="number">1</span>:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">        set_ = <span class="built_in">set</span>()    <span class="comment">#!!!!!!进入下一层前重置集合，相当于只在同层里面使用set实现层去重</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> (path <span class="keyword">and</span> nums[i] &lt; path[-<span class="number">1</span>]) <span class="keyword">or</span> nums[i] <span class="keyword">in</span> set_:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            set_.add(nums[i]) <span class="comment">#但是往下探索返回的set不会设置成最底下的元素吗</span></span><br><span class="line">            <span class="comment">#不会，我的理解是for循环是分树枝，回溯函数是生长枝条，哦，used在每个函数里被创建，就属于这个函数的局部变量，所以每一层都有自己的used</span></span><br><span class="line">            <span class="variable language_">self</span>.backtracking(nums,i+<span class="number">1</span>,path,result)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubsequences</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(nums,<span class="number">0</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>主要是加了一个set来实现树层去重，注意<code>set</code>是在每一层递归开始时创建的<hr><br>不能直接排序<code>nums</code>,因为排序会改变元素的相对顺序，导致错误的结果,因此这里想实现返回的是非递减子序列就要在path加元素的时候判断是否比path[-1]大<hr><br>然后还有个有意思的就是实现树层去重（就是在分层的时候根节点相同的树枝就不要了），结合这几天的学习我对这种题目的理解就是————<strong>for循环是分树枝，回溯函数是生长枝条</strong>，所以在for循环里面判断是否去重，而不是在回溯函数里面判断是否去重。<br><br><strong>那如何实现树层去重呢？</strong><br><br>那就是用<code>set_</code>这个集合来实现，并且这是个局部变量（作用域在当前层，也就是在每个回溯函数中），每一层递归都会创建当层的集合，用来记录当层已经使用过的元素，从而实现树层去重。<br></p><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列(题目链接)</a><br><br>给定一个不含重复数字的数组 nums ，返回其所有可能的全排列。你可以按 任意顺序 返回答案。<br></p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [1,2,3]<br><br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br><br></p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [0,1]<br><br>输出：[[0,1],[1,0]]<br><br></p></blockquote><p>示例 3：</p><blockquote><p>输入：nums &#x3D; [1]<br><br>输出：[[1]]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,nums,used,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            <span class="variable language_">self</span>.backtracking(nums,used,path,result)</span><br><span class="line">            path.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        used = [<span class="literal">False</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(nums,used,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>在排列问题上就不再需要startIndex了，因为排列是有序的，所以每次都从0开始遍历<br><br><br>但是选过的元素就不能再选了，所以需要一个used数组来记录哪些元素已经被选过了（类似组合问题的剪枝，每调用回溯函数就剪一条边）</p><h1 id="全排列-II"><a href="#全排列-II" class="headerlink" title="全排列 II"></a>全排列 II</h1><p><a href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II(题目链接)</a><br>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。<br><br>示例 1：</p><blockquote><p>输入：nums &#x3D; [1,1,2]<br><br>输出：<br>[[1,1,2],<br> [1,2,1],<br> [2,1,1]]<br><br></p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [1,2,3]<br><br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,nums,used,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">        set_ = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> set_ <span class="keyword">or</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            set_.add(nums[i])</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(nums,used,path,result)</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">            path.pop()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(nums,used,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>主要是在排列的基础上加了一个set来实现树层去重，注意<code>set</code>是在每一层递归开始时创建的,就是结合上道题的排列，和上上道题的去重。<hr><br>实际上一个uesd也行，用之前的排序加<code>used[i]</code>和<code>used[i-1]</code>判断是否相同来实现树层去重</p><hr>感觉先自己做再看视频就激情四射了]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;非递减子序列&quot;&gt;&lt;a href=&quot;#非递减子序列&quot; class=&quot;headerlink&quot; title=&quot;非递减子序列&quot;&gt;&lt;/a&gt;非递减子序列&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/increasing-subse</summary>
      
    
    
    
    <category term="算法学习——回溯" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day25</title>
    <link href="http://example.com/2026/01/11/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day25/"/>
    <id>http://example.com/2026/01/11/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day25/</id>
    <published>2026-01-11T12:27:16.000Z</published>
    <updated>2026-01-11T13:39:33.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h1><p><a href="https://leetcode.cn/problems/restore-ip-addresses/description/">93. 复原 IP 地址</a></p><blockquote><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p></blockquote><ul><li>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#56;&#64;&#49;&#46;&#49;">192.168@1.1</a>“ 是 无效 IP 地址。<br></li></ul><blockquote><p>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isok</span>(<span class="params">self,s,s_index,e_index</span>):</span><br><span class="line">        <span class="keyword">if</span> s_index &gt; e_index:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s[s_index] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> s_index != e_index:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(s[s_index:e_index+<span class="number">1</span>]) &gt; <span class="number">255</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,s,index,count,cur,result</span>):</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">3</span> <span class="keyword">and</span> <span class="variable language_">self</span>.isok(s,index,<span class="built_in">len</span>(s)-<span class="number">1</span>):</span><br><span class="line">            cur += s[index:]</span><br><span class="line">            result.append(cur)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.isok(s,index,i):</span><br><span class="line">                temp = s[index:i+<span class="number">1</span>]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="variable language_">self</span>.backtracking(s,i+<span class="number">1</span>,count,cur+temp+<span class="string">&#x27;.&#x27;</span>,result) <span class="comment">#隐式回溯，cur本身不变</span></span><br><span class="line">                count -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(s,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>不能直接用s，字符串不可变还是要设置个变量接住</p><h1 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h1><p><a href="https://leetcode.cn/problems/subsets/description/">78. 子集</a></p><blockquote><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p></blockquote><ul><li>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,nums,index,path,result</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(nums)):</span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(nums,i+<span class="number">1</span>,path,result)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = [[]]</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(nums,<span class="number">0</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>真别说，连剪枝都不要，但是这道题每个节点都要记录一下</p><h1 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h1><p><a href="https://leetcode.cn/problems/subsets-ii/description/">90. 子集 II</a></p><blockquote><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p></blockquote><ul><li><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><blockquote><p>示例 1：</p></blockquote></li><li><p>输入：nums &#x3D; [1,2,2]</p></li><li><p>输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</p><blockquote><p>示例 2：</p></blockquote></li><li><p>输入：nums &#x3D; [0]</p></li><li><p>输出：[[],[0]]</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,nums,index,path,result,used</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i&gt;index <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span> </span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(nums,i+<span class="number">1</span>,path,result,used)</span><br><span class="line">            path.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = [[]]</span><br><span class="line">        nums.sort()</span><br><span class="line">        used = [<span class="literal">False</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(nums,<span class="number">0</span>,[],result,used)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>就是在上道题的基础上，加一个去重的操作，用昨天的树层去重的方法，添加一个<code>uesd</code>来表示是否被使用</p><p>怎么说，终于赶上来，之前每天都要在截止前，现在也可以按时完成了，感觉回溯学的不如之前的，可能是在期末考，总是把这个当负担，希望后面考完状态可以调整过来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复原IP地址&quot;&gt;&lt;a href=&quot;#复原IP地址&quot; class=&quot;headerlink&quot; title=&quot;复原IP地址&quot;&gt;&lt;/a&gt;复原IP地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/restore-ip-addre</summary>
      
    
    
    
    <category term="算法学习——回溯" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day24</title>
    <link href="http://example.com/2026/01/10/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day24/"/>
    <id>http://example.com/2026/01/10/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day24/</id>
    <published>2026-01-10T13:21:03.000Z</published>
    <updated>2026-01-11T13:26:50.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h1><h2 id="原始版本"><a href="#原始版本" class="headerlink" title="原始版本"></a>原始版本</h2><p><a href="https://leetcode.cn/problems/combination-sum/description/">39. 组合总和</a></p><blockquote><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,candidates,target,sums,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> sums &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> sums == target:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">#空返回，改变result就行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(candidates)):</span><br><span class="line">            sums += candidates[i]</span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(candidates,target,sums,i,path,result)</span><br><span class="line">            sums -= candidates[i] </span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(candidates,target,<span class="number">0</span>,<span class="number">0</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>总的来说，就是回溯的模板，只是在递归的过程中，需要判断一下是否超过了目标值，如果超过了，就直接返回。如果等于目标值，就将当前路径加入结果集中。然后因为可以重复使用元素，所以递归的索引从当前索引开始（不用i+1）。</p><h2 id="排序加剪枝"><a href="#排序加剪枝" class="headerlink" title="排序加剪枝"></a>排序加剪枝</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,candidates,target,sums,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> sums == target:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">#空返回，改变result就行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(candidates)):</span><br><span class="line">            sums += candidates[i]</span><br><span class="line">            <span class="keyword">if</span> sums &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(candidates,target,sums,i,path,result)</span><br><span class="line">            sums -= candidates[i] </span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(candidates,target,<span class="number">0</span>,<span class="number">0</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br>     <h1 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h1><p><a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II</a></p><blockquote><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,candidates,target,sums,index,used,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> sums == target:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(candidates)): <span class="comment">#用循环让数组的每个变成一棵树的根节点，同时一棵树比一颗更窄，目的就是不要重复（指的是（1，2）（2，1）这种）</span></span><br><span class="line">            <span class="comment">#下面的去重是数组里面本身元素的重复导致的（但是又不能简单的把数组元素去重）</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;index <span class="keyword">and</span> candidates[i] == candidates[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]: <span class="comment">#进行层剪枝的操作</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            sums += candidates[i]</span><br><span class="line">            <span class="keyword">if</span> sums &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            <span class="variable language_">self</span>.backtracking(candidates,target,sums,i+<span class="number">1</span>,used,path,result)</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">            sums -= candidates[i]</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(candidates)</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(candidates,target,<span class="number">0</span>,<span class="number">0</span>,used,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这道题关键在于区分树枝重复和树层重复，叶子可以和父节点相同，但是不能跟兄弟相同（包括每一个根节点）</p><h1 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h1><p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">131. 分割回文串</a></p><blockquote><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,s,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(s):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[index:i+<span class="number">1</span>] == s[index:i+<span class="number">1</span>][::-<span class="number">1</span>] :</span><br><span class="line">                path.append(s[index:i+<span class="number">1</span>])</span><br><span class="line">                <span class="variable language_">self</span>.backtracking(s,i+<span class="number">1</span>,path,result)</span><br><span class="line">                path.pop()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(s,<span class="number">0</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>就是用递归加回溯把所有切割方式列出来返回是回文的内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组合总和&quot;&gt;&lt;a href=&quot;#组合总和&quot; class=&quot;headerlink&quot; title=&quot;组合总和&quot;&gt;&lt;/a&gt;组合总和&lt;/h1&gt;&lt;h2 id=&quot;原始版本&quot;&gt;&lt;a href=&quot;#原始版本&quot; class=&quot;headerlink&quot; title=&quot;原始版本&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="算法学习——回溯" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day23</title>
    <link href="http://example.com/2026/01/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day23/"/>
    <id>http://example.com/2026/01/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day23/</id>
    <published>2026-01-09T13:45:25.000Z</published>
    <updated>2026-01-10T12:24:03.458Z</updated>
    
    <content type="html"><![CDATA[<p>只能说越到后面越难坚持，加油</p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p><a href="https://leetcode.cn/problems/combinations/description/">77. 组合</a></p><blockquote><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p></blockquote><h2 id="未剪枝"><a href="#未剪枝" class="headerlink" title="未剪枝"></a>未剪枝</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(n,k,<span class="number">1</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,n,k,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">            result.append(path[:]) <span class="comment"># 注意path的拷贝方式</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,n+<span class="number">1</span>):</span><br><span class="line">            path.append(i)</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(n,k,i+<span class="number">1</span>,path,result) <span class="comment">#这里改成index+1会返回所有组合（包括重复的）</span></span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(n,k,<span class="number">1</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,n,k,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">            result.append(path[:]) <span class="comment"># 注意path的拷贝方式</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,n-(k-<span class="built_in">len</span>(path))+<span class="number">2</span>): <span class="comment"># 这里的n-(k-len(path))+2是为了剪枝，因为如果n-(k-len(path))+2还小于k，那么就没有必要继续遍历了</span></span><br><span class="line">            path.append(i)</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(n,k,i+<span class="number">1</span>,path,result) <span class="comment">#这里改成index+1会返回所有组合（包括重复的）</span></span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure><p>解释一下这个剪枝的地方：<br>need &#x3D; k - len(path)，i一直到n，共有n-i+1个元素，剩余元素至少要大于等于need才行，因此n-i+1 &gt;&#x3D; need，即n-i+1 &gt;&#x3D; k - len(path)，即n-(k-len(path))+1 &lt;&#x3D; n，但是python的range是左闭右开的，右边取不到，所以要+1变成<strong>n-(k-len(path))+2</strong></p><h1 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h1><p><a href="https://leetcode.cn/problems/combination-sum-iii/description/">216. 组合总和 III</a></p><blockquote><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：<br>只使用数字1到9<br>每个数字 最多使用一次</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(n,k,<span class="number">0</span>,<span class="number">1</span>,[],result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,targetsum,k,cursum,index,path,result</span>):</span><br><span class="line">        <span class="keyword">if</span> cursum &gt; targetsum:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k :</span><br><span class="line">            <span class="keyword">if</span> targetsum == cursum:</span><br><span class="line">                result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="number">9</span>-(k-<span class="built_in">len</span>(path))+<span class="number">2</span>):</span><br><span class="line">            cursum += i</span><br><span class="line">            path.append(i)</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(targetsum,k,cursum,i+<span class="number">1</span>,path,result)</span><br><span class="line">            cursum -= i</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure><ul><li>这道题比上一道题多的剪枝的内容是当前和大于目标和时，直接返回</li><li>以及在回溯的时候别忘了更新当前和</li></ul><h1 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h1><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合</a></p><blockquote><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="/images/codecrazy/day23-T3.png" alt="按键实例"></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.lettermap=[</span><br><span class="line">            <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;def&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;ghi&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;jkl&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mno&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;pqrs&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;tuv&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;wxyz&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        <span class="variable language_">self</span>.result = []</span><br><span class="line">        <span class="variable language_">self</span>.s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self,digits,index</span>):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(digits): <span class="comment">#终止条件深度等于位数</span></span><br><span class="line">            <span class="variable language_">self</span>.result.append(<span class="variable language_">self</span>.s)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        digit = <span class="built_in">int</span>(digits[index]) <span class="comment">#字符形式转化，便于查字典</span></span><br><span class="line">        letter = <span class="variable language_">self</span>.lettermap[digit] <span class="comment">#对应层的字符串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> letter: <span class="comment">#实现分叉</span></span><br><span class="line">            <span class="variable language_">self</span>.s += i</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(digits,index + <span class="number">1</span>) <span class="comment">#深度探索</span></span><br><span class="line">            <span class="variable language_">self</span>.s = <span class="variable language_">self</span>.s[:-<span class="number">1</span>] <span class="comment">#回溯，删掉最后一个</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br><span class="line">        <span class="variable language_">self</span>.backtracking(digits,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br></pre></td></tr></table></figure><p>咱就是说明天别个人休息我再努力一下就可以按时完成了，每天的任务一定要完成，欠了就永远赶不上了，一天做两个就很辛苦了，加油          </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;只能说越到后面越难坚持，加油&lt;/p&gt;
&lt;h1 id=&quot;组合&quot;&gt;&lt;a href=&quot;#组合&quot; class=&quot;headerlink&quot; title=&quot;组合&quot;&gt;&lt;/a&gt;组合&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/combinatio</summary>
      
    
    
    
    <category term="算法学习——回溯" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day22</title>
    <link href="http://example.com/2026/01/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day22/"/>
    <id>http://example.com/2026/01/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day22/</id>
    <published>2026-01-08T02:10:34.000Z</published>
    <updated>2026-01-08T03:09:22.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h1><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669. 修剪二叉搜索树</a></p><blockquote><p>给你二叉搜索树的根节点 root ，同时给定最小边界 low 和最大边界 high 。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 之间。修剪树 不应该 改变保留在树中的节点的相对结构（即，如果没有被移除，原有的父子关系都应当保留）。可以证明，存在 唯一的答案 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trimBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; low:</span><br><span class="line">            right = <span class="variable language_">self</span>.trimBST(root.right,low,high)</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; high:</span><br><span class="line">            left = <span class="variable language_">self</span>.trimBST(root.left,low,high)</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        root.left = <span class="variable language_">self</span>.trimBST(root.left,low,high)</span><br><span class="line">        root.right = <span class="variable language_">self</span>.trimBST(root.right,low,high)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>如果访问节点的值在[low,high]之间，那么就递归访问左右子树。<br>如果节点值小于low，那么就去访问右子树，因为左子树的值一定更小。（返回右子树的根节点，并且右子树也要进行修剪）<br>如果节点值大于high，那么就去访问左子树，因为右子树的值一定更大。（返回左子树的根节点，并且左子树也要进行修剪）</p><h1 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h1><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108. 将有序数组转换为二叉搜索树</a></p><blockquote><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">tra</span>(<span class="params">nums,left,right</span>):</span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            mid = (left + right)//<span class="number">2</span></span><br><span class="line">            root = TreeNode(nums[mid])</span><br><span class="line">            root.left =  tra(nums,left,mid-<span class="number">1</span>)</span><br><span class="line">            root.right = tra(nums,mid+<span class="number">1</span>,right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> tra(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>有点类似二分法，每次取中间值作为根节点，然后递归构造左右子树。（左闭右闭）</p><h1 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h1><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538. 把二叉搜索树转换为累加树</a></p><blockquote><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="variable language_">self</span>.convertBST(root.right)</span><br><span class="line">        root.val += <span class="variable language_">self</span>.pre </span><br><span class="line">        <span class="variable language_">self</span>.pre = root.val</span><br><span class="line">        <span class="variable language_">self</span>.convertBST(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>采用右中左的遍历顺序，先遍历右子树，然后遍历根节点，最后遍历左子树。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;修剪二叉搜索树&quot;&gt;&lt;a href=&quot;#修剪二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;修剪二叉搜索树&quot;&gt;&lt;/a&gt;修剪二叉搜索树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/trim-a-binar</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day21</title>
    <link href="http://example.com/2026/01/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day21/"/>
    <id>http://example.com/2026/01/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day21/</id>
    <published>2026-01-07T02:37:00.000Z</published>
    <updated>2026-01-07T04:40:02.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">235. 二叉搜索树的最近公共祖先</a></p><blockquote><p>给定一个二叉搜索树, </p></blockquote><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            left = <span class="variable language_">self</span>.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">            <span class="keyword">return</span> left </span><br><span class="line">        <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            right = <span class="variable language_">self</span>.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>只要val在p和q之间，那么root就是最近公共祖先</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">                root = root.right    </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h1><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701. 二叉搜索树中的插入操作</a></p><blockquote><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val ，</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            root.left = <span class="variable language_">self</span>.insertIntoBST(root.left,val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.right = <span class="variable language_">self</span>.insertIntoBST(root.right,val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left :</span><br><span class="line">                root.left = TreeNode(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="variable language_">self</span>.insertIntoBST(root.left,val)</span><br><span class="line">        <span class="keyword">if</span> val &gt; root.val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                root.right = TreeNode(val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="variable language_">self</span>.insertIntoBST(root.right,val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h1><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450. 删除二叉搜索树中的节点</a></p><blockquote><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val == key:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                cur = root.right</span><br><span class="line">                <span class="keyword">while</span> cur.left:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                cur.left = root.left</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; key:</span><br><span class="line">            root.left= <span class="variable language_">self</span>.deleteNode(root.left,key)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key:</span><br><span class="line">            root.right= <span class="variable language_">self</span>.deleteNode(root.right,key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>当找到要删除的节点时，分四种情况讨论：</p><ol><li>该节点没有子节点，直接删除，返回 None。</li><li>该节点只有右子节点，返回右子节点，替代该节点。</li><li>该节点只有左子节点，返回左子节点，替代该节点。</li><li>该节点有左右子节点，将左子树挂到右子树的最左节点的左子树上，返回右子节点，替代该节点。<br>挺难的</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉搜索树的最近公共祖先&quot;&gt;&lt;a href=&quot;#二叉搜索树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的最近公共祖先&quot;&gt;&lt;/a&gt;二叉搜索树的最近公共祖先&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/p</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day20</title>
    <link href="http://example.com/2026/01/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day20/"/>
    <id>http://example.com/2026/01/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day20/</id>
    <published>2026-01-06T11:23:16.000Z</published>
    <updated>2026-01-06T13:05:25.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h1><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530. 二叉搜索树的最小绝对差</a></p><blockquote><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.result = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,cur</span>):</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="variable language_">self</span>.dfs(cur.left)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.pre <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.result = <span class="built_in">min</span>(<span class="variable language_">self</span>.result,cur.val-<span class="variable language_">self</span>.pre.val)</span><br><span class="line">        <span class="variable language_">self</span>.pre = cur</span><br><span class="line">        <span class="variable language_">self</span>.dfs(cur.right)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinimumDifference</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="variable language_">self</span>.dfs(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br></pre></td></tr></table></figure><p>采用递归（中序遍历）加双指针的方法，遍历二叉搜索树，记录前一个节点，每次遍历到当前节点时，计算当前节点和前一个节点的差值，取最小值即可。</p><h1 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h1><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">501. 二叉搜索树中的众数</a></p><blockquote><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。<br>如果树中有不止一个众数，可以按 任意顺序 返回。<br>假定 BST 满足如下定义：<br>结点左子树中所含节点的值 小于等于 当前节点的值<br>结点右子树中所含节点的值 大于等于 当前节点的值<br>左子树和右子树都是二叉搜索树</p></blockquote><h2 id="递归（中序遍历）-哈希表-双指针"><a href="#递归（中序遍历）-哈希表-双指针" class="headerlink" title="递归（中序遍历）+ 哈希表 + 双指针"></a>递归（中序遍历）+ 哈希表 + 双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.count = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.pre = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.result = &#123;&#125; </span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,cur</span>):</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="variable language_">self</span>.dfs(cur.left)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.pre <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.pre.val == cur.val:</span><br><span class="line">                <span class="variable language_">self</span>.count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="variable language_">self</span>.count = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.result[cur.val] = <span class="variable language_">self</span>.count</span><br><span class="line">        <span class="variable language_">self</span>.pre = cur</span><br><span class="line">        <span class="variable language_">self</span>.dfs(cur.right)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(root)</span><br><span class="line">        target_count = <span class="built_in">max</span>(<span class="variable language_">self</span>.result.values())</span><br><span class="line">        num = [k <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="variable language_">self</span>.result.items() <span class="keyword">if</span> v == target_count]</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><p>这是我没看视频前做的，额，最开始我想的是，相等就count+1，然后用flag来区分到底是哪个节点重复，额，然后写着写着就成了哈希表，然后感觉flag用cur.val替代更好</p><h2 id="双指针-数组-递归（中序遍历）"><a href="#双指针-数组-递归（中序遍历）" class="headerlink" title="双指针+数组+递归（中序遍历）"></a>双指针+数组+递归（中序遍历）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.Maxc = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.count = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.pre = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.result = []</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,cur</span>):</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="variable language_">self</span>.dfs(cur.left)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.pre <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.pre.val == cur.val:</span><br><span class="line">            <span class="variable language_">self</span>.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.count = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.pre = cur</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.count ==<span class="variable language_">self</span>. Maxc:</span><br><span class="line">            <span class="variable language_">self</span>.result.append(cur.val)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.count &gt; <span class="variable language_">self</span>.Maxc:</span><br><span class="line">            <span class="variable language_">self</span>.Maxc = <span class="variable language_">self</span>.count</span><br><span class="line">            <span class="variable language_">self</span>.result = [cur.val]</span><br><span class="line">        <span class="variable language_">self</span>.dfs(cur.right)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br></pre></td></tr></table></figure><h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先</a></p><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> root == q <span class="keyword">or</span> root ==p <span class="keyword">or</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left_ = <span class="variable language_">self</span>.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right_ = <span class="variable language_">self</span>.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> left_ <span class="keyword">and</span> right_:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> left_ <span class="keyword">and</span> <span class="keyword">not</span> right_:</span><br><span class="line">            <span class="keyword">return</span> left_</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> left_ <span class="keyword">and</span> right_:</span><br><span class="line">            <span class="keyword">return</span> right_</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>在递归中包含回溯的思想，这里的特例包括：</p><ol><li>根节点是p或q</li><li>p或q在根节点的左子树或右子树中<hr><br>递归三部曲：</li><li>确定递归函数的参数和返回值（root,p,q）</li><li>确定终止条件（root &#x3D;&#x3D; p or root &#x3D;&#x3D; q or root &#x3D;&#x3D; None）</li><li>确定单层递归的逻辑（左子树和右子树的遍历）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉搜索树的最小绝对差&quot;&gt;&lt;a href=&quot;#二叉搜索树的最小绝对差&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的最小绝对差&quot;&gt;&lt;/a&gt;二叉搜索树的最小绝对差&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/probl</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day18</title>
    <link href="http://example.com/2026/01/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day18/"/>
    <id>http://example.com/2026/01/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day18/</id>
    <published>2026-01-03T12:07:24.000Z</published>
    <updated>2026-01-03T14:39:50.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h1><p><a href="https://leetcode.cn/problems/maximum-binary-tree/description/">654. 最大二叉树</a></p><blockquote><p>给定一个不含重复元素的整数数组 nums 。 你需要从 nums 中找出最大的数，将其作为二叉树的根节点，然后递归地构建左子树和右子树。<br>左子树的构建过程是从数组中 最大值左边 的 子数组中 构建出最大二叉树 。<br>右子树的构建过程是从数组中 最大值右边 的 子数组中 构建出最大二叉树 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructMaximumBinaryTree</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:     <span class="comment">#只有一个点就创建以这个为点的树</span></span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">        node = TreeNode(<span class="number">0</span>) <span class="comment">#创建节点设置值为零</span></span><br><span class="line">        max_n = <span class="number">0</span></span><br><span class="line">        index_n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; max_n:</span><br><span class="line">                max_n =nums[i]</span><br><span class="line">                index_n = i</span><br><span class="line">        node.val = max_n</span><br><span class="line">        <span class="keyword">if</span> index_n &gt; <span class="number">0</span>:</span><br><span class="line">            left_num = nums[<span class="number">0</span>:index_n]</span><br><span class="line">            node.left = <span class="variable language_">self</span>.constructMaximumBinaryTree(left_num)</span><br><span class="line">        <span class="keyword">if</span> index_n &lt; <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">            right_num = nums[index_n+<span class="number">1</span>:]</span><br><span class="line">            node.right = <span class="variable language_">self</span>.constructMaximumBinaryTree(right_num)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p>递归法，递归三部曲：</p><ol><li>确定递归函数的参数和返回值（nums）</li><li>确定递归的终止条件（数组长度为1）</li><li>确定单层递归的逻辑（找到最大值和索引，创建节点，递归左子树和右子树）</li></ol><h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617. 合并二叉树</a></p><blockquote><p>给你两棵二叉树： root1 和 root2 。想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。<br>返回合并后的二叉树。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> root2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        root1.val += root2.val</span><br><span class="line">        root1.left = <span class="variable language_">self</span>.mergeTrees(root1.left,root2.left)</span><br><span class="line">        root1.right = <span class="variable language_">self</span>.mergeTrees(root1.right,root2.right)</span><br><span class="line">        <span class="keyword">return</span> root1</span><br></pre></td></tr></table></figure><p>递归法，递归三部曲：</p><ol><li>确定递归函数的参数和返回值（root1,root2）</li><li>确定递归的终止条件（root1为空返回root2，root2为空返回root1）(包含都为空的情况)</li><li>确定单层递归的逻辑（将root2的值加到root1上，递归左子树和右子树）</li></ol><h1 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h1><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">700. 二叉搜索树中的搜索</a></p><blockquote><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。你需要在 BST 中找到节点值等于 val 的节点。返回以该节点为根的子树。如果节点不存在，则返回 null 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.searchBST(root.left,val)</span><br><span class="line">        <span class="keyword">if</span> val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.searchBST(root.right,val)</span><br></pre></td></tr></table></figure><p>递归法，递归三部曲：</p><ol><li>确定递归函数的参数和返回值（root,val）(注意题目要求的返回值是节点（值为val的节点）)</li><li>确定递归的终止条件（root为空返回None，root值等于val返回root）</li><li>确定单层递归的逻辑（如果val小于root值，递归左子树，否则递归右子树）</li></ol><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">                root=root.left</span><br><span class="line">            <span class="keyword">elif</span> val &gt; root.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>迭代法，循环遍历二叉搜索树，找到值为val的节点，返回该节点。如果遍历完整个树都没有找到，返回None。</p><h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98. 验证二叉搜索树</a></p><blockquote><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<br>有效 二叉搜索树定义如下：<br>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        left = <span class="variable language_">self</span>.isValidBST(root.left)</span><br><span class="line">        <span class="keyword">if</span>  <span class="variable language_">self</span>.pre <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="variable language_">self</span>.pre.val &gt;= root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="variable language_">self</span>.pre = root</span><br><span class="line">        right = <span class="variable language_">self</span>.isValidBST(root.right)</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure><p>递归法，递归三部曲：</p><ol><li>确定递归函数的参数和返回值（root）(注意题目要求的返回值是布尔值)</li><li>确定递归的终止条件（root为空返回True）</li><li>确定单层递归的逻辑（中序遍历，判断当前节点是否大于前一个节点，递归左子树和右子树）<br>在这道题我遇到了个很有意思的错误，就是我把self.pre &#x3D; None放在isValidBST里面，欸，产生了一直返回True的情况，按照以前ai教我的，把这个放在里面按道理是防止污染，是好的，我仔细思考了一下，因为在这道题pre是不可以被重新初始化的，放在isValidBST里面会导致每次递归都重新初始化pre，所以会一直返回True。所以再__init__里面创建一次最好</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最大二叉树&quot;&gt;&lt;a href=&quot;#最大二叉树&quot; class=&quot;headerlink&quot; title=&quot;最大二叉树&quot;&gt;&lt;/a&gt;最大二叉树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/maximum-binary-tree/</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day17</title>
    <link href="http://example.com/2026/01/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day17/"/>
    <id>http://example.com/2026/01/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day17/</id>
    <published>2026-01-02T01:45:54.000Z</published>
    <updated>2026-01-02T04:56:48.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="找二叉树的左下角的值"><a href="#找二叉树的左下角的值" class="headerlink" title="找二叉树的左下角的值"></a>找二叉树的左下角的值</h1><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">513. 找树左下角的值</a></p><blockquote><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。<br>假设二叉树中至少有一个节点。</p></blockquote><h2 id="找二叉树的左下角的值-递归"><a href="#找二叉树的左下角的值-递归" class="headerlink" title="找二叉树的左下角的值-递归"></a>找二叉树的左下角的值-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="variable language_">self</span>.max_ = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.result = []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,node,depth</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">if</span> depth &gt; <span class="variable language_">self</span>.max_:</span><br><span class="line">                <span class="variable language_">self</span>.max_ = depth</span><br><span class="line">                <span class="variable language_">self</span>.result = node.val</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.dfs(node.left,depth)</span><br><span class="line">            depth -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.dfs(node.right,depth)</span><br><span class="line">            depth -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>递归法，并且结合了回溯的思想。<br>这里递归三部曲：</p><ol><li>确定递归函数的参数和返回值（node,depth）</li><li>确定递归的终止条件（到达叶子节点）</li><li>确定单层递归的逻辑（更新最大深度和结果值，递归左右子树）<br>我原本一直在想为啥–完不会回去循环，因为递归是一种自顶向下的过程，每次递归调用都进入到下一层，而不是回到上一层。（栈？）</li></ol><h1 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h1><p><a href="https://leetcode.cn/problems/path-sum/description/">112. 路径总和</a></p><blockquote><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。<br>叶子节点 是指没有子节点的节点。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.dfs(root,targetSum-root.val)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,node,targetSum</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> targetSum == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> targetSum != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            targetSum -= node.left.val</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.dfs(node.left,targetSum):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            targetSum += node.left.val</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            targetSum -= node.right.val</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.dfs(node.right,targetSum):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            targetSum += node.right.val</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>递归法，回溯，<br>判断是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和。<br>这里递归三部曲：</p><ol><li>确定递归函数的参数和返回值（node,targetSum）（bool,并且一直向上返回）</li><li>确定递归的终止条件（到达叶子节点）(目标和为0则返回True，否则返回False)</li><li>确定单层递归的逻辑（判断是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和）</li></ol><h1 id="路径总和-路径"><a href="#路径总和-路径" class="headerlink" title="路径总和-路径"></a>路径总和-路径</h1><p><a href="https://leetcode.cn/problems/path-sum-ii/description/">113. 路径总和 II</a></p><blockquote><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。<br>叶子节点 是指没有子节点的节点。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.result = []</span><br><span class="line">        <span class="variable language_">self</span>.path = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br><span class="line">        <span class="variable language_">self</span>.path.append(root.val)</span><br><span class="line">        <span class="variable language_">self</span>.dfs(root,targetSum-root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,node,targetSum</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> targetSum == <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.result.append(<span class="variable language_">self</span>.path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            <span class="variable language_">self</span>.path.append(node.left.val)</span><br><span class="line">            targetSum -= node.left.val</span><br><span class="line">            <span class="variable language_">self</span>.dfs(node.left,targetSum)</span><br><span class="line">            targetSum += node.left.val</span><br><span class="line">            <span class="variable language_">self</span>.path.pop() </span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            <span class="variable language_">self</span>.path.append(node.right.val)</span><br><span class="line">            targetSum -= node.right.val</span><br><span class="line">            <span class="variable language_">self</span>.dfs(node.right,targetSum)</span><br><span class="line">            targetSum += node.right.val</span><br><span class="line">            <span class="variable language_">self</span>.path.pop()</span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>递归法，回溯，<br>判断是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和。<br>这里递归三部曲：</p><ol><li>确定递归函数的参数和返回值（node,targetSum）</li><li>确定递归的终止条件（到达叶子节点）</li><li>确定单层递归的逻辑（判断是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和）<ol><li>如果存在左子树，递归左子树，路径上添加左子节点值，目标和减去左子节点值。</li><li>如果存在右子树，递归右子树，路径上添加右子节点值，目标和减去右子节点值。</li><li>如果到达叶子节点且目标和为0，将当前路径添加到结果中。</li><li>如果到达叶子节点且目标和不为0，返回False。</li></ol></li></ol><hr><p>这里我遇到了一个有意思的问题<br>self.result.append(self.path[:])我写成了self.result.append(self.path)，然后path只有一个返回值,如果是self.result.append(self.path[])则直接报错，为啥呢</p><ul><li><code>self.result.append(self.path) (错误)</code>这是添加引用。<br><code>self.result</code> 里保存的是指向<code>self.path</code>的指针。后续对<code> self.path</code> 的任何修改（比如 <code>pop()</code>）都会影响到 <code>self.result</code> 里的内容。</li><li><code>self.result.append(self.path[]) (完全错误)</code><br>只写了方括号，但没有告诉 Python 你要索引哪个位置，或者要切片哪个范围。这就像你对别人说 “请把书从书架上拿下来”，但没说拿哪一本，对方无法执行你的指令。</li><li><code>self.result.append(self.path[:]) (正确)</code><br>这会创建一个 <code>self.path</code> 的副本，然后将这个副本添加到 <code>self.result</code> 中。这个副本是一个独立的新列表，它的内容在被添加时就固定了。后续对 <code>self.path</code> 的回溯修改（<code>pop()</code>）不会影响到已经存入 <code>self.result</code> 的这个副本。<hr><br>我的理解是，[:]是拷贝一份，然后修改原列表不会影响到拷贝的列表，而直接<code>self.path</code>是(类似指针)会修改原列表，会影响到<code>self.result</code>里的内容。</li></ul><h1 id="从中序和后序遍历构造二叉树"><a href="#从中序和后序遍历构造二叉树" class="headerlink" title="从中序和后序遍历构造二叉树"></a>从中序和后序遍历构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树</a></p><blockquote><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = postorder[-<span class="number">1</span>]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line"></span><br><span class="line">        mid_index = inorder.index(root_val)</span><br><span class="line"></span><br><span class="line">        left_in = inorder[:mid_index]</span><br><span class="line">        right_in = inorder[mid_index+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        left_po = postorder[:mid_index]</span><br><span class="line">        right_po = postorder[mid_index:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        root.left = <span class="variable language_">self</span>.buildTree(left_in,left_po)</span><br><span class="line">        root.right = <span class="variable language_">self</span>.buildTree(right_in,right_po)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>right_po &#x3D; postorder[mid_index:-1]最开始我记错了，写成right_po &#x3D; postorder[mid_index:-2]，因为我以为-1是最后也取，但实际上-1表示最后一个不取，因为后序遍历的最后一个是根节点。</p><h1 id="从前序和中序遍历构造二叉树"><a href="#从前序和中序遍历构造二叉树" class="headerlink" title="从前序和中序遍历构造二叉树"></a>从前序和中序遍历构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105. 从前序与中序遍历序列构造二叉树</a></p><blockquote><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造并返回这颗 二叉树 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = preorder[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        mid_index = inorder.index(root_val)</span><br><span class="line">        left_in = inorder[:mid_index] </span><br><span class="line">        right_in = inorder[mid_index+<span class="number">1</span>:]</span><br><span class="line">        left_pr = preorder[<span class="number">1</span>:mid_index+<span class="number">1</span>]</span><br><span class="line">        right_pr = preorder[mid_index+<span class="number">1</span>:]</span><br><span class="line">        root.left = <span class="variable language_">self</span>.buildTree(left_pr,left_in)</span><br><span class="line">        root.right = <span class="variable language_">self</span>.buildTree(right_pr,right_in)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>暂时先这样，吃个饭去</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;找二叉树的左下角的值&quot;&gt;&lt;a href=&quot;#找二叉树的左下角的值&quot; class=&quot;headerlink&quot; title=&quot;找二叉树的左下角的值&quot;&gt;&lt;/a&gt;找二叉树的左下角的值&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day15</title>
    <link href="http://example.com/2026/01/01/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day15/"/>
    <id>http://example.com/2026/01/01/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day15/</id>
    <published>2026-01-01T08:16:08.000Z</published>
    <updated>2026-01-01T13:58:06.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">平衡二叉树</a><br>给你一个二叉树的根节点 root ，判断它是否是平衡二叉树。</p><h2 id="平衡二叉树-递归"><a href="#平衡二叉树-递归" class="headerlink" title="平衡二叉树-递归"></a>平衡二叉树-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.get_h(root) == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_h</span>(<span class="params">self,node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_h = <span class="variable language_">self</span>.get_h(node.left)</span><br><span class="line">        <span class="keyword">if</span> left_h == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> (right_h := <span class="variable language_">self</span>.get_h(node.right)) == -<span class="number">1</span>: <span class="comment">#海象运算符</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">abs</span>(left_h - right_h)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_h,right_h)+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过后序遍历的方式计算每个节点的高度，并判断其左右子树的高度差是否超过1，若超过则返回-1表示不平衡，否则返回节点的高度。其中可以用海象运算符（:&#x3D;）来简化代码，避免重复计算。</p><h1 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h1><p><a href="https://leetcode.cn/problems/binary-tree-paths/description/">二叉树的所有路径</a><br>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p><h2 id="二叉树的所有路径-递归"><a href="#二叉树的所有路径-递归" class="headerlink" title="二叉树的所有路径-递归"></a>二叉树的所有路径-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,cur,path,result</span>):</span><br><span class="line">        path.append(cur.val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">            result.append(<span class="string">&quot;-&gt;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,path)))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> cur.left:</span><br><span class="line">            <span class="variable language_">self</span>.dfs(cur.left,path,result)</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">if</span> cur.right:</span><br><span class="line">            <span class="variable language_">self</span>.dfs(cur.right,path,result)</span><br><span class="line">            path.pop()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        path = []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(root,path,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>因为是从根节点出发查找路径，很容易想到用前序遍历的方式来实现。<br>在递归中其实是包含了回溯的过程，每次递归结束后，都需要将当前节点从路径中弹出，以确保路径的正确性。</p><h1 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h1><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">左叶子之和</a><br>给你二叉树的根节点 root ，返回所有左叶子节点的和。</p><h2 id="左叶子之和-递归"><a href="#左叶子之和-递归" class="headerlink" title="左叶子之和-递归"></a>左叶子之和-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftnum = <span class="variable language_">self</span>.sumOfLeftLeaves(root.left)</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.right:</span><br><span class="line">            leftnum = root.left.val</span><br><span class="line">        rightnum = <span class="variable language_">self</span>.sumOfLeftLeaves(root.right)</span><br><span class="line">        sum_val = leftnum + rightnum</span><br><span class="line">        <span class="keyword">return</span> sum_val</span><br></pre></td></tr></table></figure><p>采用后序遍历的方式，先计算左子树的左叶子节点之和，再计算右子树的左叶子节点之和，最后将它们相加即可。<br>判断当前节点的左子节点是否为左叶子节点（即左子节点没有左右子节点），若为左叶子节点，则将其值加入左子树的左叶子节点之和中。</p><h1 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h1><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">完全二叉树的节点个数</a><br>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><h2 id="完全二叉树的节点个数-递归"><a href="#完全二叉树的节点个数-递归" class="headerlink" title="完全二叉树的节点个数-递归"></a>完全二叉树的节点个数-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = root.left</span><br><span class="line">        right= root.right</span><br><span class="line">        ld = <span class="number">0</span></span><br><span class="line">        rd = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left:</span><br><span class="line">            left = left.left</span><br><span class="line">            ld += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            right = right.right</span><br><span class="line">            rd += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> ld==rd:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>**(ld+<span class="number">1</span>)-<span class="number">1</span></span><br><span class="line">        leftnum = <span class="variable language_">self</span>.countNodes(root.left)</span><br><span class="line">        rightnum = <span class="variable language_">self</span>.countNodes(root.right)</span><br><span class="line">        result = leftnum + rightnum + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>通过计算左子树和右子树的深度，判断当前节点是否为满二叉树的根节点。如果是，则直接计算节点数（2^（ld+1）-1）；否则递归计算左右子树的节点数并相加。这个方法其实是找满二叉树的根节点，满二叉树的节点数为2^（ld+1）-1。从而减少时间复杂度。<br>也可以用普通后序遍历的方式来实现，但是时间复杂度会高一些。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;平衡二叉树&quot;&gt;&lt;a href=&quot;#平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;&lt;/a&gt;平衡二叉树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/balanced-binary-tree</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>2026的第一篇blog</title>
    <link href="http://example.com/2026/01/01/2026%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/"/>
    <id>http://example.com/2026/01/01/2026%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/</id>
    <published>2025-12-31T16:24:15.000Z</published>
    <updated>2025-12-31T16:29:30.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h1><p>  今天是2026年的第一天，这一年里给自己几个目标吧：</p><ol><li>完成代码随想录打卡任务的所有题目</li><li>每个月跑100km</li><li>每天坚持背单词</li><li>通过英语六级</li><li>蓝桥杯获奖</li><li>跟上项目组的节奏，明年的人工智能比赛能有好的成绩</li><li>在kaggle上完成一个项目</li><li>找个对象（可能？）</li><li>希望看到这个blog的每一个人都能开开心心，如尝所愿！</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;新年快乐&quot;&gt;&lt;a href=&quot;#新年快乐&quot; class=&quot;headerlink&quot; title=&quot;新年快乐&quot;&gt;&lt;/a&gt;新年快乐&lt;/h1&gt;&lt;p&gt;  今天是2026年的第一天，这一年里给自己几个目标吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成代码随想录打卡任务的所有题目&lt;/li</summary>
      
    
    
    
    
    <category term="杂谈" scheme="http://example.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day14</title>
    <link href="http://example.com/2025/12/31/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day14/"/>
    <id>http://example.com/2025/12/31/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day14/</id>
    <published>2025-12-31T13:04:22.000Z</published>
    <updated>2025-12-31T16:13:48.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">翻转二叉树</a><br>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><h2 id="翻转二叉树-递归"><a href="#翻转二叉树-递归" class="headerlink" title="翻转二叉树-递归"></a>翻转二叉树-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            root.left,root.right = root.right,root.left</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>就是在前序遍历前交换左右子树</p><h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/description/">对称二叉树</a><br>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><h2 id="对称二叉树-递归"><a href="#对称二叉树-递归" class="headerlink" title="对称二叉树-递归"></a>对称二叉树-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.compare(root.left,root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">self,left,right</span>):</span><br><span class="line">        <span class="keyword">if</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> left.val != right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        outside = <span class="variable language_">self</span>.compare(left.left,right.right)</span><br><span class="line">        inside = <span class="variable language_">self</span>.compare(left.right,right.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inside <span class="keyword">and</span> outside</span><br></pre></td></tr></table></figure><p>在后续遍历的基础上，判断以 left 为根的子树和以 right 为根的子树，是否互为镜像，为了让两棵子树互为镜像，必须满足以下三个条件：<br>它们的根节点值必须相同。</p><ul><li>left 子树的左孩子，必须和 right 子树的右孩子互为镜像。</li><li>left 子树的右孩子，必须和 right 子树的左孩子互为镜像。</li></ul><h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">二叉树的最大深度</a><br>给你一个二叉树的根节点 root ，返回它的 最大深度 。</p><h2 id="二叉树的最大深度-递归"><a href="#二叉树的最大深度-递归" class="headerlink" title="二叉树的最大深度-递归"></a>二叉树的最大深度-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.getdeepth(root)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getdeepth</span>(<span class="params">self,node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftdeepth = <span class="variable language_">self</span>.getdeepth(node.left)</span><br><span class="line">        rightdeepth = <span class="variable language_">self</span>.getdeepth(node.right)</span><br><span class="line">        deepth = <span class="built_in">max</span>(leftdeepth,rightdeepth) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> deepth </span><br></pre></td></tr></table></figure><p>首先区分高度和深度</p><ul><li>高度：指的是从根节点到叶子节点的最长路径上的节点数。</li><li>深度：指的是从根节点到当前节点的路径上的节点数。<br>所以这里可以用根节点的高度来表示二叉树的最大深度，而求根节点的高度可以用后序遍历。<br>并且初始深度为0，当前节点的深度，等于其左右子树中较深的那一个的深度，再加上当前节点自己这一层</li></ul><h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">二叉树的最小深度</a><br>给你一个二叉树的根节点 root ，返回它的 最小深度 。</p><h2 id="二叉树的最小深度-递归"><a href="#二叉树的最小深度-递归" class="headerlink" title="二叉树的最小深度-递归"></a>二叉树的最小深度-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.getdep(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getdep</span>(<span class="params">self,node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftdpt = <span class="variable language_">self</span>.getdep(node.left)</span><br><span class="line">        rightdpt = <span class="variable language_">self</span>.getdep(node.right)</span><br><span class="line">        <span class="keyword">if</span> leftdpt == <span class="number">0</span> <span class="keyword">and</span> rightdpt:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightdpt</span><br><span class="line">        <span class="keyword">if</span> leftdpt <span class="keyword">and</span> rightdpt == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftdpt</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(rightdpt,leftdpt)+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里和最大深度的区别在于，当一个节点只有左子树或右子树时，最小深度是右子树或左子树的深度加1。因此要判断一下左右子树是否为空，为空则返回另一个子树的深度加1。然后将max替换为min即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;翻转二叉树&quot;&gt;&lt;a href=&quot;#翻转二叉树&quot; class=&quot;headerlink&quot; title=&quot;翻转二叉树&quot;&gt;&lt;/a&gt;翻转二叉树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/invert-binary-tree/d</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day13</title>
    <link href="http://example.com/2025/12/29/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day13/"/>
    <id>http://example.com/2025/12/29/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day13/</id>
    <published>2025-12-29T12:07:20.000Z</published>
    <updated>2025-12-30T15:09:07.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树的基本知识"><a href="#树的基本知识" class="headerlink" title="树的基本知识"></a>树的基本知识</h1><p>这个部分我暂时先空着，明天要考计算机组成原理与系统结构。</p><h1 id="树的遍历（前中后序）"><a href="#树的遍历（前中后序）" class="headerlink" title="树的遍历（前中后序）"></a>树的遍历（前中后序）</h1><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">二叉树的前序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">二叉树的中序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">二叉树的后序遍历</a><br>给你二叉树的根节点 root ，返回它节点值的 前序、中序、后序 遍历。</p><h2 id="树的遍历（前中后序）-递归"><a href="#树的遍历（前中后序）-递归" class="headerlink" title="树的遍历（前中后序）-递归"></a>树的遍历（前中后序）-递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            dfs(node.left)</span><br><span class="line">            dfs(node.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个是前序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(node.left)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            dfs(node.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个是中序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            dfs(node.left)</span><br><span class="line">            dfs(node.right)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个是后序</p><h2 id="树的遍历（前中后序）-迭代"><a href="#树的遍历（前中后序）-迭代" class="headerlink" title="树的遍历（前中后序）-迭代"></a>树的遍历（前中后序）-迭代</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result  </span><br></pre></td></tr></table></figure><p>这是前序的迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>这是后序的迭代 </p><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历</a></p><blockquote><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        que = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            in_ = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(que)):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                in_.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:    </span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            result.append(in_)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这是二叉树的层序遍历代码，使用队列实现。每一层记录个数，然后遍历这个个数，将当前层的节点值加入到结果中，并且将当前层的子节点加入到队列中，在下一次遍历的时候，就可以遍历到下一层的节点了。</p><h1 id="二叉树的层序遍历-II"><a href="#二叉树的层序遍历-II" class="headerlink" title="二叉树的层序遍历 II"></a>二叉树的层序遍历 II</h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">107. 二叉树的层序遍历 II</a></p><blockquote><p>给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        que = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            in_ = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(que)):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                in_.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            result.append(in_)</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>这是二叉树的层序遍历 II 代码，和层序遍历的代码只有一行不同，就是在返回结果的时候，将结果反转一下即可。(就多了个反转)</p><h1 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h1><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">199. 二叉树的右视图</a></p><blockquote><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result=[]</span><br><span class="line">        que = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            n=<span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> i == n-<span class="number">1</span>:</span><br><span class="line">                    result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>就是在每一层遍历的时候，只记录当前层的最后一个节点，将其加入到结果中即可。</p><h1 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h1><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">637. 二叉树的层平均值</a></p><blockquote><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        que = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            n=<span class="built_in">len</span>(que)</span><br><span class="line">            in_ = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = que.popleft()</span><br><span class="line">                in_ += cur.val</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    que.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    que.append(cur.right)</span><br><span class="line">            result.append(in_/n)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>就是在每一层遍历的时候，记录当前层的节点值的和，然后除以当前层的节点个数，即可得到当前层的平均值。<br>暂时到这里，明天开始就没课了，确实一旦松懈了一点就很麻烦了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树的基本知识&quot;&gt;&lt;a href=&quot;#树的基本知识&quot; class=&quot;headerlink&quot; title=&quot;树的基本知识&quot;&gt;&lt;/a&gt;树的基本知识&lt;/h1&gt;&lt;p&gt;这个部分我暂时先空着，明天要考计算机组成原理与系统结构。&lt;/p&gt;
&lt;h1 id=&quot;树的遍历（前中后序）&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="算法学习——树" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%91/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录-day11</title>
    <link href="http://example.com/2025/12/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day11/"/>
    <id>http://example.com/2025/12/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day11/</id>
    <published>2025-12-27T04:33:10.000Z</published>
    <updated>2025-12-27T07:58:11.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h1><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">题目链接</a><br>根据 逆波兰表示法，求表达式的值。<br>有效的运算符包括 + ,  - ,  * ,  &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：<br>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><ul><li>示例 1：<br>输入: [“2”, “1”, “+”, “3”, “ * “]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</li><li>示例 2：<br>输入: [“4”, “13”, “5”, “&#x2F;“, “+”]<br>输出: 6<br>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</li><li>示例 3：<br>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “ * “, “&#x2F;“, “ * “, “17”, “+”, “5”, “+”]<br>输出: 22<br>解释:该算式转化为常见的中缀算术表达式为：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((10 * (6 / ((9 + 3) * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5     </span><br><span class="line">= ((10 * 0) + 17) + 5     </span><br><span class="line">= (0 + 17) + 5    </span><br><span class="line">= 17 + 5    </span><br><span class="line">= 22    </span><br></pre></td></tr></table></figure><blockquote><p>逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。<br> 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br> 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。（是一种二叉数树的后续遍历）<br> 逆波兰表达式主要有以下两个优点：<br> 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br> 适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。<hr></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&quot;+&quot;</span> <span class="keyword">or</span> i == <span class="string">&#x27;-&#x27;</span> <span class="keyword">or</span> i == <span class="string">&#x27;*&#x27;</span> <span class="keyword">or</span> i == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                a = stack.pop()</span><br><span class="line">                b = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    stack.append(a+b)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    stack.append(b-a)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    stack.append(a*b)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(b/a)) <span class="comment"># 向零取整用int（b/a）直接截断小数部分</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                stack.append(<span class="built_in">int</span>(i))</span><br><span class="line">        <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure><p>使用栈来保存数字，遇到运算符就弹出栈顶的两个数字进行计算，然后把结果压回栈中。最后栈中剩下的数字就是结果。</p><h1 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">题目链接</a><br>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回滑动窗口中的最大值。</p><ul><li>示例 1：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><ul><li>示例 2：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> :</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (<span class="variable language_">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.que = deque()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self,value</span>): <span class="comment">#这里啥时候队列可能为空呢</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.que <span class="keyword">and</span> value == <span class="variable language_">self</span>.que[<span class="number">0</span>]:<span class="comment">#队列不为空且遍历的值等于队口</span></span><br><span class="line">            <span class="variable language_">self</span>.que.popleft()   <span class="comment">#弹的是最大（对头在左）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.que <span class="keyword">and</span> value &gt; <span class="variable language_">self</span>.que[-<span class="number">1</span>]:</span><br><span class="line">            <span class="variable language_">self</span>.que.pop()</span><br><span class="line">        <span class="variable language_">self</span>.que.append(value)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        que = Queue()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            que.push(nums[i])</span><br><span class="line">        result.append(que.get())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,<span class="built_in">len</span>(nums)):</span><br><span class="line">            que.pop(nums[i-k]) <span class="comment">#例如加入第四个元素前要移除第一个</span></span><br><span class="line">            que.push(nums[i])</span><br><span class="line">            result.append(que.get())</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>下面是ai的带注释的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonotonicQueue</span>:  <span class="comment"># 改名：明确是单调递减队列，避免语义混淆</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.que = deque()  <span class="comment"># 存储 nums 的元素（也可存索引，更灵活）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_left</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        滑动窗口移动时，移除窗口左边界的元素（仅当该元素是队首时，因为队首是最大值）</span></span><br><span class="line"><span class="string">        此时队列可能为空：必须先判断 self.que 非空</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.que <span class="keyword">and</span> value == <span class="variable language_">self</span>.que[<span class="number">0</span>]:  <span class="comment"># 队列非空 + 左边界元素是队首（最大值）</span></span><br><span class="line">            <span class="variable language_">self</span>.que.popleft()  <span class="comment"># 弹出队首（移除窗口外的最大值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        加入当前元素，维持队列单调递减：</span></span><br><span class="line"><span class="string">        移除队列中所有比当前元素小的元素（这些元素不可能成为后续窗口的最大值）</span></span><br><span class="line"><span class="string">        此时队列可能为空：空队列直接 append 即可</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.que <span class="keyword">and</span> <span class="variable language_">self</span>.que[-<span class="number">1</span>] &lt; value:  <span class="comment"># 队列非空 + 队尾元素 &lt; 当前元素</span></span><br><span class="line">            <span class="variable language_">self</span>.que.pop()  <span class="comment"># 移除队尾（从右弹出，deque.pop() 是O(1)）</span></span><br><span class="line">        <span class="variable language_">self</span>.que.append(value)  <span class="comment"># 加入当前元素，队列仍保持递减</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_max</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取当前窗口最大值（队首），必须保证调用前队列非空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        <span class="comment"># 边界情况处理（避免队列空时调用 get_max）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k == <span class="number">0</span> <span class="keyword">or</span> k &gt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        que = MonotonicQueue()</span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第一步：初始化第一个窗口（前 k 个元素）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            que.push(nums[i])</span><br><span class="line">        <span class="comment"># 第一个窗口的最大值加入结果（此时队列非空，因为 k&lt;=len(nums) 且 nums 非空）</span></span><br><span class="line">        result.append(que.get_max())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二步：滑动窗口（从第 k 个元素开始，到最后一个元素）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 1. 移除窗口左边界的元素（i-k 是当前窗口的左边界索引）</span></span><br><span class="line">            left_value = nums[i - k]  <span class="comment"># 窗口要移除的左边界元素</span></span><br><span class="line">            que.remove_left(left_value)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 2. 加入当前窗口的右边界元素（第 i 个元素）</span></span><br><span class="line">            que.push(nums[i])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 3. 记录当前窗口的最大值（队列非空）</span></span><br><span class="line">            result.append(que.get_max())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试案例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="built_in">print</span>(s.maxSlidingWindow([<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="number">3</span>))  <span class="comment"># 输出 [3,3,5,5,6,7]（正确）</span></span><br><span class="line">    <span class="built_in">print</span>(s.maxSlidingWindow([], <span class="number">3</span>))  <span class="comment"># 输出 []（边界处理）</span></span><br><span class="line">    <span class="built_in">print</span>(s.maxSlidingWindow([<span class="number">1</span>], <span class="number">1</span>))  <span class="comment"># 输出 [1]（边界处理）</span></span><br><span class="line">    <span class="built_in">print</span>(s.maxSlidingWindow([<span class="number">1</span>,-<span class="number">1</span>], <span class="number">2</span>))  <span class="comment"># 输出 [1]（边界处理）</span></span><br></pre></td></tr></table></figure><p>这道题是用单调队列来解决的，单调队列是指队列中的元素是单调递增或递减的。<br>那如何保证队列中的元素是单调递减的呢？<br>当有新元素加入时，我们将队列中所有比新元素小的元素都弹出，直到队列为空或者队列尾部的元素大于等于新元素为止。这样就保证了队列中的元素是单调递减的。</p><ul><li>关于我在视频弹幕上遇到的一个情况5231，其实解决这个的方式是在push方法中加入一个判断，当队列非空且队尾元素小于等于新元素时，弹出队尾元素，直到队列为空或者队列尾部的元素大于等于新元素为止。（这样3进去的之前2就被弹出了）<hr></li><li>为啥要判断队列非空？<br><br>初始阶段：刚实例化 Queue 时（<strong>init</strong> 后），self.que &#x3D; deque() 是空的，此时调用 pop&#x2F;get 都会操作空队列。<br><br>窗口滑动时移除元素后：比如窗口内所有元素都被 pop 方法移除（例如滑动窗口移动时，队首元素是前一个窗口的最大值，被弹出后队列无其他元素）。<br><br>nums 数组本身为空或 k&#x3D;0：当输入 nums &#x3D; [] 或 k&#x3D;0 时，循环不执行 push，队列始终为空。<hr></li></ul><h1 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h1><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">题目链接</a></p><blockquote><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p></blockquote><p>示例 1:</p><ul><li>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</li><li>输出: [1,2]<br></li></ul><p>示例 2:</p><ul><li>输入: nums &#x3D; [1], k &#x3D; 1</li><li>输出: [1]<br></li></ul><p>提示：</p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 $O(n \log n)$ , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="built_in">dir</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">dir</span>[nums[i]] = <span class="built_in">dir</span>.get(nums[i],<span class="number">0</span>) + <span class="number">1</span> <span class="comment">#key不存在就设为0，存在就加1</span></span><br><span class="line">        que = []</span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">dir</span>.items():</span><br><span class="line">            heapq.heappush(que,(value,key)) <span class="comment">#注意value在前，因为按照value排序的</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(que) &gt; k:</span><br><span class="line">                heapq.heappop(que)</span><br><span class="line">        result = [<span class="number">0</span>] * k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>): <span class="comment">#第一个-1取不到所以就是0开始</span></span><br><span class="line">            result[i] = heapq.heappop(que)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>使用哈希表统计每个元素的频率，然后使用小顶堆维护前 k 个高频元素。<br>小顶堆的大小为 k，每次加入一个元素后，如果堆的大小超过 k，就弹出堆顶元素。<br>解释一下堆，就是完全二叉树，每个节点的左右子树都是堆，且根节点是堆顶。<br>小顶堆的性质是，堆顶元素是堆中最小的元素。<br>大顶堆的性质是，堆顶元素是堆中最大的元素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逆波兰表达式求值&quot;&gt;&lt;a href=&quot;#逆波兰表达式求值&quot; class=&quot;headerlink&quot; title=&quot;逆波兰表达式求值&quot;&gt;&lt;/a&gt;逆波兰表达式求值&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/evaluate</summary>
      
    
    
    
    <category term="算法学习——栈和队列" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
    
    <category term="代码随想录" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
</feed>
