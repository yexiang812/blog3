[{"title":"LeetCode_1","url":"/2025/12/01/hello-world/","content":"  从这篇文章开始，我将会将我在算法练习中的所想和收获记录下来。\n1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。\n1.1 思路1  思路1是最简单的思路，就是遍历数组，对于每个元素，都去数组中查找是否有目标值减去当前值的元素。  时间复杂度为O(n^2)，空间复杂度为O(1)。  class Solution:  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:      for i in nums:          j = target - i          start_index = nums.index(i)          next_index = start_index + 1           nums_new = nums[next_index:]#对原数组进行切片，去掉当前元素之前的元素          if j in nums_new:              return [start_index,next_index+nums_new.index(j)]\n1.2 思路2(哈希表)  思路2是利用哈希表来解决问题。我们遍历数组，对于每个元素，都去哈希表中查找是否有目标值减去当前值的元素。  如果有，就返回当前元素的下标和哈希表中目标值减去当前值的元素的下标。  如果没有，就将当前元素和下标加入哈希表中。  时间复杂度为O(n)，空间复杂度为O(n)。用空间换时间  class Solution:  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:      dir=&#123;&#125;      for i in range(len(nums)): #遍历数组          if target-nums[i] not in dir: #如果目标值减去当前值不在字典中              dir[nums[i]] = i          else :              return [dir[target-nums[i]],i]\n","categories":["算法学习——哈希"],"tags":["leetcode"]},{"title":"代码随想录_day1","url":"/2025/12/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day1/","content":"可恶，今天有点拖拖拉拉的，博客只能水一点了\n二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n示例 1: 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2:\n\n 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间\nright=len(nums)        left=0        while left &lt; right:            middle = (left + right) // 2            if target &lt; nums[middle]:                right = middle            elif target &gt; nums[middle]:                left  = middle + 1            else :                return middle        return -1\n二分查找有点类似数学的二分法，来简化查找的次数，一个是左闭右闭，right就是指向真实的下标，然后更新的左右都不取到中间值，另一个是左闭右开，right指向数组的数量（实际加一），更新的右边都取到中间值。\n移除数组给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。\n\n示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n你不需要考虑数组中超出新长度后面的元素。\nclass Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        length=len(nums)        i = 0        while i &lt; length:            if nums[i]  == val:                for j in range(i,length-1):                    nums[j]=nums[j+1]                length -= 1            else:                i += 1        return length\n这个是暴力解法，双层循环\nslow = 0        for fast in range(len(nums)):            if  nums[fast] != val:                nums[slow]=nums[fast]                slow += 1        return slow\n这个是快慢指针讲一下思路，简单来说就是，设置两个指针，快的指针用来遍历原来的数组，慢的就用来表示新的数组的下标，然后比较快指针对应的和val一不一样，留下不一样的，一样的就跳过，最后返回慢指针的下标就是新数组的长度\n有序数组的平方给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n示例 1： 输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]\n\n 示例 2： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]\nclass Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        s1 = 0        k= s2 = len(nums)-1        nums_list=[0]*len(nums)        while s1 &lt;= s2:            if nums[s1]**2 &gt; nums[s2]**2:                nums_list[k] = nums[s1]**2                s1 += 1            else :                nums_list[k] = nums[s2]**2                 s2 -= 1            k -= 1        return nums_list\n这个是双指针的方法，设置两个指针，一个指向数组的头，一个指向数组的尾，然后比较两个指针指向的元素的平方，把大的那个放到新数组的最后面，然后相应的指针向中间移动，最后返回新数组\nreturn sorted(x*x for x in nums)\n无需多言，排序加推导式\n来不及了，要回宿舍了，下次不能拖拖拉拉了\n","categories":["算法学习——数组"],"tags":["代码"]},{"title":"python_入门练习","url":"/2025/12/09/python-%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0/","content":"  不得不说我的代码能力太弱了，只能先从简单的开始了。\n1.A+B问题I题目描述\n\n你的任务是计算a+b。输入描述输入包含一系列的a和b对，通过空格隔开。一对a和b占一行。输出描述如对于输入中的第二对a和b，  在输出中它们的和应该也在第二行。输入示例1 2  3 4输出示例3  7\n\n我的解法while True:    try:        a,b = map(int,input().split())        print(a+b)    except:        break\n好吧我承认我的代码能力是极差的。第一个问题如何保证一直接受用户输入，首先就要用一个一直循环的while语句，直到没有输入后跳出循环。可以用if判断啥时候输入为空，也可以用try except保证输入的合法性。然后就是map函数，这个函数的核心是对序列里面的每一个元素批量应用同一个处理规则，这里是将输入的字符串转换为整数。这里的.split()函数是将输入的字符串按照空格隔开，返回一个列表。哦，补充一下input函数输入的内容是字符串。\n2.A+B问题II题目描述\n\n计算a+b，但输入方式有所改变。输入描述第一行是一个整数N，表示后面会有N行a和b，通过空格隔开。输出描述对于输入的每对a和b，你需要在相应的行输出a、b的和。  如第二对a和b，对应的和也输出在第二行。输入示例2  2 4  9 21输出示例6  30提示信息注意，测试数据不仅仅一组。也就是说，会持续输入N以及后面的a和b\n\n解法1这道题和上一道题的区别在于，上一道题是一直接受用户输入，直到没有输入为止。这道题是先接受一个整数N，然后接受N行a和b，输出N行a+b。而且分组输入导致每一块都有组数N，就不能像上一道题一样无脑接收输入了。补充知识：.strip()函数是去掉字符串首尾的空格，包括换行符、制表符等。\nwhile True:    try:        N = int(input().strip())        for i in range(N):            a,b = map(int,input().split())            print(a+b)    except:        break\n解法2import sysfor line in sys.stdin:    N=int(line.strip())    for i in range(N):        a,b=map(int,sys.stdin.readline().strip().split())        print(a+b)\n\n导入sys模块后，通过for line in sys.stdin启动外层循环——这个循环的作用是逐个读取输入中“每组数据的开头行（即N所在的行）”。每次外层循环执行时：\n\n\n首先处理当前读取到的line：这行内容是当前组的分组信息（整数N），通过int(line.strip())转成整数后，明确“这一组需要处理N对a和b”。\n\n接着启动内层循环for _ in range(N)：这个循环的作用是主动读取当前组内的N行a和b数据。每次内层循环会通过sys.stdin.readline()读取一行新的输入（这行是a和b，用空格分隔），经过strip()清理空白、split()拆分、map(int, ...)转整数后，得到a和b的值，计算并输出它们的和。内层循环会严格执行N次，确保当前组的N对a和b全部被处理。\n\n内层循环结束后，外层循环才会继续执行：此时外层循环会自动读取下一行输入，而这一行恰好是“下一组数据的N”（因为内层循环已经主动读完了上一组的N行a和b，不会让外层循环误读这些行）。\n\n\n整个过程中，外层循环负责“按组拆分输入”（找到每一组的N），内层循环负责“按组内数量处理数据”（读完N对a和b），两层循环分工配合，既不会漏读数据，也不会错把a和b的行当成N处理，最终完美实现“持续处理多组N及对应a+b”的题目要求。sys.stdin():内置的标准输入流对象，用于从控制台或其他输入源读取数据。sys.stdin.readline()：读取输入的一行,从stdin中读取一行数据,包括换行符。\n","tags":["入门算法"]},{"title":"代码随想录-day2","url":"/2025/12/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day2/","content":"长度最小的子数组\n给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n\n示例：\n\n输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n\n提示：\n\n1 &lt;&#x3D; target &lt;&#x3D; 10^9\n1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5\n1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5\n\nclass Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        length = len(nums)        left = 0        right = 0  #左闭右闭        min_nums = length + 1        sum_n = 0        while right &lt; length:            sum_n += nums[right]            while sum_n &gt;= target:                min_nums = min(right - left + 1,min_nums)                sum_n -= nums[left]                left += 1            right += 1        return min_nums if min_nums != length + 1 else 0\n这道题可以用滑动窗口的方式来实现设置两个指针left和right，分别指向子数组的左右边界。初始的时候设置两个指针都是0，即指向数组的第一个元素。然后通过移动右指针来扩大子数组的大小直到子数组的和大于等于target。这个时候我们得到的就是在起点为0条件下获得的最小子数组长度。因此我们可以移动左指针的位置，一方面可以缩小子数组的长度，另一方面也是调整子数组的起点。如果减去初始的左指针指向的元素后子数组的和仍然大于等于target，那么我们就可以继续移动左指针，直到子数组的和小于target，当然在这过程中要更新最小数组长度。如果子数组的和小于target了那我们就继续移动右指针，扩大子数组的大小。重复这个过程到循环结束\nclass Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        length = len(nums)        min_nums = length + 1        for i in range(length):            sum_n = 0            for j in range(i,length):                sum_n += nums[j]                if sum_n &gt;= target:                    min_nums = min(min_nums,j-i+1)                    break        return min_nums if min_nums != length + 1 else 0\n暴力解法就是用两个for循环，一个for循环遍历数组的每个元素，另一个for循环遍历从当前元素开始的所有子数组，计算子数组的和是否大于等于target。超时了就是了\n螺旋矩阵II\n给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\n\n示例:\n\n输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]\n\nclass Solution:    def generateMatrix(self, n: int) -&gt; List[List[int]]:        nums=[[0]*n for _ in range(n)] # 创建一个n*n的空列表        start_x,start_y = 0,0 #每一圈的起始位置，注意是每一圈的，因此转完一圈后起始位置的x、y都要加一 ,x表示行数，y表示列数        count = 1 #表示转到哪个数字        offset = 1 #偏移量，其实我觉得也是圈数        while n // 2 &gt; offset-1: #转一圈消耗两层啦            for j in range(start_y,n-offset):                nums[start_x][j] = count                count += 1            for i in range(start_x,n-offset):                nums[i][n-offset] = count                count += 1            for j in range(n-offset,start_y,-1):                nums[n-offset][j] = count                count += 1            for i in range(n-offset,start_x,-1):                nums[i][start_y] = count                count += 1            start_x += 1            start_y += 1            offset += 1        if n %2 == 1:            nums[n//2][n//2] = count        return nums\n这道题目的核心在处理边界问题，特别在顶点的取否上，这里我们采用左闭右开的方式，然后明白转一圈消耗两层，然后每一圈更新起始位置和偏移量。\n扩展题看了思路，但是我自己还没憋出来，等晚上再试试\n","categories":["算法学习——数组"],"tags":["代码随想录"]}]