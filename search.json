[{"title":"python_入门练习","url":"/2025/12/09/python-%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0/","content":"  不得不说我的代码能力太弱了，只能先从简单的开始了。\n1.A+B问题I题目描述\n\n你的任务是计算a+b。输入描述输入包含一系列的a和b对，通过空格隔开。一对a和b占一行。输出描述如对于输入中的第二对a和b，  在输出中它们的和应该也在第二行。输入示例1 2  3 4输出示例3  7\n\n我的解法while True:    try:        a,b = map(int,input().split())        print(a+b)    except:        break\n好吧我承认我的代码能力是极差的。第一个问题如何保证一直接受用户输入，首先就要用一个一直循环的while语句，直到没有输入后跳出循环。可以用if判断啥时候输入为空，也可以用try except保证输入的合法性。然后就是map函数，这个函数的核心是对序列里面的每一个元素批量应用同一个处理规则，这里是将输入的字符串转换为整数。这里的.split()函数是将输入的字符串按照空格隔开，返回一个列表。哦，补充一下input函数输入的内容是字符串。\n2.A+B问题II题目描述\n\n计算a+b，但输入方式有所改变。输入描述第一行是一个整数N，表示后面会有N行a和b，通过空格隔开。输出描述对于输入的每对a和b，你需要在相应的行输出a、b的和。  如第二对a和b，对应的和也输出在第二行。输入示例2  2 4  9 21输出示例6  30提示信息注意，测试数据不仅仅一组。也就是说，会持续输入N以及后面的a和b\n\n解法1这道题和上一道题的区别在于，上一道题是一直接受用户输入，直到没有输入为止。这道题是先接受一个整数N，然后接受N行a和b，输出N行a+b。而且分组输入导致每一块都有组数N，就不能像上一道题一样无脑接收输入了。补充知识：.strip()函数是去掉字符串首尾的空格，包括换行符、制表符等。\nwhile True:    try:        N = int(input().strip())        for i in range(N):            a,b = map(int,input().split())            print(a+b)    except:        break\n解法2import sysfor line in sys.stdin:    N=int(line.strip())    for i in range(N):        a,b=map(int,sys.stdin.readline().strip().split())        print(a+b)\n\n导入sys模块后，通过for line in sys.stdin启动外层循环——这个循环的作用是逐个读取输入中“每组数据的开头行（即N所在的行）”。每次外层循环执行时：\n\n\n首先处理当前读取到的line：这行内容是当前组的分组信息（整数N），通过int(line.strip())转成整数后，明确“这一组需要处理N对a和b”。\n\n接着启动内层循环for _ in range(N)：这个循环的作用是主动读取当前组内的N行a和b数据。每次内层循环会通过sys.stdin.readline()读取一行新的输入（这行是a和b，用空格分隔），经过strip()清理空白、split()拆分、map(int, ...)转整数后，得到a和b的值，计算并输出它们的和。内层循环会严格执行N次，确保当前组的N对a和b全部被处理。\n\n内层循环结束后，外层循环才会继续执行：此时外层循环会自动读取下一行输入，而这一行恰好是“下一组数据的N”（因为内层循环已经主动读完了上一组的N行a和b，不会让外层循环误读这些行）。\n\n\n整个过程中，外层循环负责“按组拆分输入”（找到每一组的N），内层循环负责“按组内数量处理数据”（读完N对a和b），两层循环分工配合，既不会漏读数据，也不会错把a和b的行当成N处理，最终完美实现“持续处理多组N及对应a+b”的题目要求。sys.stdin():内置的标准输入流对象，用于从控制台或其他输入源读取数据。sys.stdin.readline()：读取输入的一行,从stdin中读取一行数据,包括换行符。\n","tags":["入门算法"]},{"title":"week1_复盘","url":"/2025/12/21/week1-%E5%A4%8D%E7%9B%98/","content":"week1_复盘day1第一道题 第一道题是二分搜索，几个关键点是，二分搜索得是有序数组，通过数学的二分法实现。代码细节，一个是左闭右开，目标值小于mid，调整右指针到mid，注意右边是开的，因此mid&#x3D;right，如果目标值大于mid，调整左指针到mid+1，注意左边是闭的，因此left&#x3D;mid+1。当然如果是左闭右闭，代码细节就会有一些变化，目标值小于mid，调整右指针到mid-1，注意右边是闭的，因此right&#x3D;mid-1，如果目标值大于mid，调整左指针到mid+1，注意左边是闭的，因此left&#x3D;mid+1。\n第二题是移除元素，设置快慢指针，快指针用来遍历数组，慢指针用来指向新数组的位置。然后和目标值比较，如果不相等，慢指针加一，然后赋值为快指针的值。如果相等，快指针加一，继续遍历。\n第三题然后是有序数组的平方，因为数组是有序的，所以平方后的最大值一定在数组的两端，所以可以设置双指针，一个指向数组的头，一个指向数组的尾。然后比较两个指针指向的元素的平方，将较大的那个放到新数组的末尾，然后对应的指针向中间移动。当然也可以用python的推导式加上sort函数，实现有序数组的平方。\nday2第一题长度最小的子数组这道题是滑动窗口，设置左右指针，初始都指向数组的头，然后右指针向右移动，直到窗口内的元素和大于等于目标值，然后记录下窗口的长度，然后左指针向右移动，直到窗口内的元素和小于目标值，然后继续移动右指针满足条件后继续记录下窗口的长度，直到右指针到达数组的尾。\n第二题螺旋矩阵II这道题的关键是边界判定，四条边都用左闭右开的方式，最后一个点给下一条边，还有是循环条件是n&#x2F;&#x2F;2，转一圈掉两层，然后是偏移量，最开始是0 0 然后每次循环偏移量加一，然后是n为奇数时，最后一个点单独处理等于n。\n你看看果然不能托现在才想起来附加题没做\nday3第一题 移除链表元素这道题主要是考虑头节点被删除的情况，所以可以设置一个虚拟头节点，指向头节点，然后设置一个指针指向虚拟头节点，然后遍历链表，如果下一个节点的值等于目标值，就删除下一个节点，否则指针后移。最后返回虚拟头节点的下一个节点。\n第二题 设计链表这道题主要是考虑链表的基本操作，比如添加节点，删除节点，获取节点的值等。主要是index的处理，哦对链表没法用下标的方式来访问节点，所以需要遍历链表来找到目标节点。\n第三题 反转链表这道题是双指针一个cur节点加一个pre节点以及临时节点temp，初始时pre指向None，cur指向头节点，然后遍历链表，每次将cur的next指向pre，然后pre移动到cur，cur移动到temp，最后返回pre。然后递归，还是不会写\nday4第一题 两两交换链表中的节点这道题主要是找到前置节点，然后交换两个节点，然后移动指针到下一个位置，注意判断条件的先后，防止空指针异常。设置了两个temp节点，一个用来保存下一个节点，一个用来保存下下下一个节点。可以用画图帮助理解。\n第二题 删除链表的倒数第N个节点这道题是快慢指针，先让快指针移动n+1步，然后快慢指针同时移动，直到快指针到达链表尾部，然后删除慢指针的下一个节点。\n第三题 链表相交这道题是双指针法，设置两个指针分别指向两个链表的头节点，然后同时移动两个指针，当一个指针到达链表尾部时，移动到另一个链表的头节点，继续移动，直到两个指针相等或者都为None。这样就能找到链表的交点。然后我自己想的是用梯形的感觉。\n第四题 环形链表II这道题是快慢指针，快指针每次移动两步，慢指针每次移动一步，直到快指针追上慢指针，或者快指针到达链表尾部。如果追上了，说明链表有环，然后快指针从链表头开始，慢指针从相遇点开始，每次移动一步，直到再次相遇，相遇点就是环的入口。如果快指针到达链表尾部，说明链表没有环。然后在起点的相遇的位置两个快慢节点改成速度相同，再次相遇的位置就是环的入口。\n我自己的杂谈这一周要准备期末考，又要坚持学代码，压力挺大的其实。虽然感觉期末成绩对我没啥用，但是总害怕大家觉得我天天不在宿舍一定天天读书的那种压力，尽管生活没有那么多的观众就是了，但是这种自我暗示也算是让我进行期末准备了，其实我还有很多自己想做的是，想看鱼书，想学数学，当然ctf也是落下好久了，确实娱乐比以前少了，但是效率总是很低，欸，可能也是天赋的缘故吧。其实我本来有很多想说的，但是这个blog公开了，也是怪不好意思的，那就这样吧\n","categories":["杂谈"],"tags":["杂谈——复盘"]},{"title":"代码随想录_day1","url":"/2025/12/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day1/","content":"可恶，今天有点拖拖拉拉的，博客只能水一点了\n二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n示例 1: 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2:\n\n 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间\nright=len(nums)        left=0        while left &lt; right:            middle = (left + right) // 2            if target &lt; nums[middle]:                right = middle            elif target &gt; nums[middle]:                left  = middle + 1            else :                return middle        return -1\n二分查找有点类似数学的二分法，来简化查找的次数，一个是左闭右闭，right就是指向真实的下标，然后更新的左右都不取到中间值，另一个是左闭右开，right指向数组的数量（实际加一），更新的右边都取到中间值。\n移除数组给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。\n\n示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n你不需要考虑数组中超出新长度后面的元素。\nclass Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        length=len(nums)        i = 0        while i &lt; length:            if nums[i]  == val:                for j in range(i,length-1):                    nums[j]=nums[j+1]                length -= 1            else:                i += 1        return length\n这个是暴力解法，双层循环\nslow = 0        for fast in range(len(nums)):            if  nums[fast] != val:                nums[slow]=nums[fast]                slow += 1        return slow\n这个是快慢指针讲一下思路，简单来说就是，设置两个指针，快的指针用来遍历原来的数组，慢的就用来表示新的数组的下标，然后比较快指针对应的和val一不一样，留下不一样的，一样的就跳过，最后返回慢指针的下标就是新数组的长度\n有序数组的平方给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n示例 1： 输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]\n\n 示例 2： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]\nclass Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        s1 = 0        k= s2 = len(nums)-1        nums_list=[0]*len(nums)        while s1 &lt;= s2:            if nums[s1]**2 &gt; nums[s2]**2:                nums_list[k] = nums[s1]**2                s1 += 1            else :                nums_list[k] = nums[s2]**2                 s2 -= 1            k -= 1        return nums_list\n这个是双指针的方法，设置两个指针，一个指向数组的头，一个指向数组的尾，然后比较两个指针指向的元素的平方，把大的那个放到新数组的最后面，然后相应的指针向中间移动，最后返回新数组\nreturn sorted(x*x for x in nums)\n无需多言，排序加推导式\n来不及了，要回宿舍了，下次不能拖拖拉拉了\n","categories":["算法学习——数组"],"tags":["代码随想录"]},{"title":"代码随想录-day2","url":"/2025/12/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day2/","content":"长度最小的子数组\n给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n\n示例：\n\n输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n\n提示：\n\n1 &lt;&#x3D; target &lt;&#x3D; 10^9\n1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5\n1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5\n\nclass Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        length = len(nums)        left = 0        right = 0  #左闭右闭        min_nums = length + 1        sum_n = 0        while right &lt; length:            sum_n += nums[right]            while sum_n &gt;= target:                min_nums = min(right - left + 1,min_nums)                sum_n -= nums[left]                left += 1            right += 1        return min_nums if min_nums != length + 1 else 0\n这道题可以用滑动窗口的方式来实现设置两个指针left和right，分别指向子数组的左右边界。初始的时候设置两个指针都是0，即指向数组的第一个元素。然后通过移动右指针来扩大子数组的大小直到子数组的和大于等于target。这个时候我们得到的就是在起点为0条件下获得的最小子数组长度。因此我们可以移动左指针的位置，一方面可以缩小子数组的长度，另一方面也是调整子数组的起点。如果减去初始的左指针指向的元素后子数组的和仍然大于等于target，那么我们就可以继续移动左指针，直到子数组的和小于target，当然在这过程中要更新最小数组长度。如果子数组的和小于target了那我们就继续移动右指针，扩大子数组的大小。重复这个过程到循环结束\nclass Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        length = len(nums)        min_nums = length + 1        for i in range(length):            sum_n = 0            for j in range(i,length):                sum_n += nums[j]                if sum_n &gt;= target:                    min_nums = min(min_nums,j-i+1)                    break        return min_nums if min_nums != length + 1 else 0\n暴力解法就是用两个for循环，一个for循环遍历数组的每个元素，另一个for循环遍历从当前元素开始的所有子数组，计算子数组的和是否大于等于target。超时了就是了\n螺旋矩阵II\n给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\n\n示例:\n\n输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]\n\nclass Solution:    def generateMatrix(self, n: int) -&gt; List[List[int]]:        nums=[[0]*n for _ in range(n)] # 创建一个n*n的空列表        start_x,start_y = 0,0 #每一圈的起始位置，注意是每一圈的，因此转完一圈后起始位置的x、y都要加一 ,x表示行数，y表示列数        count = 1 #表示转到哪个数字        offset = 1 #偏移量，其实我觉得也是圈数        while n // 2 &gt; offset-1: #转一圈消耗两层啦            for j in range(start_y,n-offset):                nums[start_x][j] = count                count += 1            for i in range(start_x,n-offset):                nums[i][n-offset] = count                count += 1            for j in range(n-offset,start_y,-1):                nums[n-offset][j] = count                count += 1            for i in range(n-offset,start_x,-1):                nums[i][start_y] = count                count += 1            start_x += 1            start_y += 1            offset += 1        if n %2 == 1:            nums[n//2][n//2] = count        return nums\n这道题目的核心在处理边界问题，特别在顶点的取否上，这里我们采用左闭右开的方式，然后明白转一圈消耗两层，然后每一圈更新起始位置和偏移量。\n扩展题看了思路，但是我自己还没憋出来，等晚上再试试\n","categories":["算法学习——数组"],"tags":["代码随想录"]},{"title":"代码随想录day-4","url":"/2025/12/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day4/","content":"两两交换链表中的节点给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\nclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        dummy_head = ListNode(next=head)        current = dummy_head        while current.next and current.next.next: #注意先后顺序防止空指针异常            temp1 = current.next            temp2 = temp1.next.next            current.next = current.next.next            current.next.next = temp1            temp1.next = temp2            current = current.next.next        return dummy_head.next\n有点像昨天的反转列表，也采用了temp指针来保存数据，这道题核心在与两两交换前需要先找到前置节点，并且在循环判断的条件中要注意先后顺序防止空指针异常，当然指针确实有点绕，画个图还是很有帮助的。\n删除链表的倒数第N个节点给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。进阶：你能尝试使用一趟扫描实现吗？\n\n输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2 输出：[1,2,3,5]  示例 2：  输入：head &#x3D; [1], n &#x3D; 1 输出：[]  示例 3：  输入：head &#x3D; [1,2], n &#x3D; 1 输出：[1]\n\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        dummy_head = ListNode(next=head)        slow = dummy_head        fast = dummy_head        n += 1        while n and fast :            n -= 1            fast = fast.next         while fast:            fast = fast.next            slow = slow.next        slow.next = slow.next.next        return dummy_head.next\n这道题就是快慢指针，要想找到倒数第二个n，那就先让fast指针移动n+1步，然后再让slow指针和fast指针同时移动，直到fast指针指向None，这时候slow指针就指向了倒数第二个n前一个的位置。只有找到倒二的前一个位置，才能进行删除操作。\n链表相交给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。图示两个链表在节点 c1 开始相交：题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        count1 = 0        count2 = 0        cur1 = headA        cur2 = headB        while cur1 :            count1 += 1            cur1 = cur1.next        cur1 = headA        while cur2:            count2 += 1            cur2 = cur2.next        cur2 = headB        less = count1 - count2        if less &gt; 0:            for i in range(less):                cur1 = cur1.next            while cur1 != cur2:                cur1 = cur1.next                cur2 = cur2.next            return cur1        else :            less = -less            for i in range(less):                cur2 = cur2.next            while cur1 != cur2:                cur1 = cur1.next                cur2 = cur2.next            return cur2\n这是我一开始的想法，先找到两个链表的长度，然后让长的链表先移动长度差的步数，然后再让两个链表同时移动，直到找到相交的节点。实际上我找了非常有意思的解法，就是让两个链表同时移动，当其中一个链表到达末尾时，让它指向另一个链表的头节点，然后继续移动，当两个链表相交时，它们会在相交点相遇。\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        if not headA or not headB:            return None        cura = headA        curb = headB        while cura != curb:            cura = cura.next if cura else headB            curb = curb.next if curb else headA        return cura\n一种类似算梯形面积的方法，把短的和长的拼在一起，简单来说，就是我让两条链表同时移动，当其中一个链表到达末尾时，让它指向另一个链表的头节点，然后继续移动，当两个链表相交时，它们会在相交点相遇。（感觉这么说有点抽象），那就假设相同部分长度c，不相同部分长的a，短的b。第一条先走a+c，第二条走b+c，此时让一再走b，二再走a，这时候两条都是a+b+c，欸刚好到相同长度，并且接下来走的是相同的部分\n环形链表II题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        fast = head        slow = head        while fast and fast.next:            fast = fast.next.next            slow = slow.next            if slow == fast:                index = slow                index_s = head                while index != index_s:                    index = index.next                    index_s = index_s.next                return index        return None\n还是快慢指针，快指针每次移动两步，慢指针每次移动一步，当它们相遇时，说明链表有环。（因为不是环肯定不会相遇，快指针早就跑远了）这时候就是判断环的入口了，让一个指针从相遇点开始移动，另一个指针从链表头开始移动，当它们相遇时，就是环的入口。（数学：假设head到环入口是a，环入口到相遇点是b，相遇点到环入口是c，那么快指针走的距离是a+b+n（b+c），慢指针走的距离是a+b，因为快指针每次移动两步，慢指针每次移动一步，所以快指针走的距离是慢指针的两倍，即2(a+b) &#x3D; a+b+n（b+c），所以a &#x3D; （n-1）（b+c）+c，b+c就是一圈，转一圈也会回到起点，所以两个指针再次出发就会在入口相遇）但，实际上不需要index，在python里面直接让慢指针回到起点，然后快指针再相遇的位置继续走，速度和慢指针相同，当它们再次相遇时，就是环的入口。\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        fast = head        slow = head        while fast and fast.next:            fast = fast.next.next            slow = slow.next            if slow == fast:                fast = head                while slow != fast:                    slow = slow.next                    fast = fast.next                return fast        return None","categories":["算法学习——链表"],"tags":["代码随想录"]},{"title":"代码随想录-day6","url":"/2025/12/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day6/","content":"有效的字母异位词\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。-示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true-示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false说明: 你可以假设字符串只包含小写字母。\n\nclass Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        hash = [0] * 26        for i in s:            hash[ord(i) - ord(&#x27;a&#x27;)] += 1        for t_ in t:            hash[ord(t_) - ord(&#x27;a&#x27;)] -= 1        for h in hash:            if h != 0:                return False        return True\n这道题的思路是：用一个长度为26的数组来存储每个字母出现的次数，遍历字符串s时，对应字母的位置加1，遍历字符串t时，对应字母的位置减1。最后遍历数组，如果数组里面的元素都为0，说明两个字符串是字母异位词，返回True，否则返回False。讲一下我觉得比较有意思的地方就是这个下标转化的方式，通过减去a的ascll值得到一个在0-25之间的下标，对应数组的位置，这样就可以统计每个字母出现的次数。（有点像凯撒密码，也算是一种哈希函数的实现）\n两个数组的交集题意：给定两个数组，编写一个函数来计算它们的交集。说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。\nclass Solution:    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        hash_set = set()        hash_list = set()        for i in nums1:            hash_set.add(i)        for i in nums2:            if i in hash_set:                hash_list.add(i)        return list(hash_list)\n也是用哈希表来存储数组里面的元素，然后存放在集合里面，因为集合里面要求元素是唯一的，再把数组1里集合元素和数组2里元素进行对比，如果存在就放到另一个集合里面，最后返回集合转换为列表即可。\n快乐数\n编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。\n\n\n示例：输入：19输出：true解释：1^2 + 9^2 &#x3D; 828^2 + 2^2 &#x3D; 686^2 + 8^2 &#x3D; 1001^2 + 0^2 + 0^2 &#x3D; 1\n\nclass Solution:    def isHappy(self, n: int) -&gt; bool:        set_=set()        while True:            if n == 1:                return True            n = self.self_sum(n)            if n in set_:                return False            else :                set_.add(n)             def self_sum(self,n):           new_n = 0        while n :            n1 = n % 10            n = n // 10            new_n += n1 ** 2         return new_n\n这道题的思路是：用一个集合来存储每次计算得到的结果，如果结果重复出现，说明进入了循环，不是快乐数。如果结果为1，说明是快乐数。利用哈希表来存储每次计算的结果，一旦出现重复的结果，说明进入了循环，不是快乐数。\n两数之和\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n\n示例:给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1]\n\ndir=&#123;&#125;      for i in range(len(nums)): #遍历数组          if target-nums[i] not in dir: #如果目标值减去当前值不在字典中              dir[nums[i]] = i          else :              return [dir[target-nums[i]],i]\n这道题在我的第一篇blog有，感兴趣的可以去看看，这道题是哈希表里面map的应用\n","categories":["算法学习——哈希表"],"tags":["代码随想录"]},{"title":"代码随想录-day3","url":"/2025/12/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day3/","content":"移除链表元素\n题意：删除链表中等于给定值 val 的所有节点。\n\n\n示例 1： 输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6 输出：[1,2,3,4,5]\n示例 2： 输入：head &#x3D; [], val &#x3D; 1 输出：[]\n示例 3： 输入：head &#x3D; [7,7,7,7], val &#x3D; 7 输出：[]\n\n解法一：虚拟头节点\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        dummy_head = ListNode(next = head)        cur_node = dummy_head        while cur_node.next:            if cur_node.next.val == val:                cur_node.next = cur_node.next.next            else :                cur_node = cur_node.next        return dummy_head.next #关于为啥要.next,因为这个节点是我们创建的虚拟的，它指向的才是头节点\n首先，在删除值为val的节点的时候我们要考虑头节点的情况，而且如果连续的多个节点等于val且在头节点的后面的时候，我们要用循环删去，总而言之，这种分类讨论的方法比较麻烦，为了解决这个问题我们可以采用虚拟头结点的方式。创建虚拟头节点dummy_head，指向头节点head。然后设置一个指针current，指向dummy_head。遍历链表，当current.next的值等于val时，删除current.next节点，否则current指针后移。（循环条件用current.next，到达尾端的时候指向None，循环结束）最后返回dummy_head.next，因为dummy_head本身是我们创造的虚拟的，而dummy_head.next才是真正的头节点。解法二：不使用虚拟头节点\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        while head and head.val == val :            head = head.next        current = head        while current and current.next:            while current.next and current.next.val == val:                current.next = current.next.next            current = current.next        return head\n我只说我最开始没考虑的情况，例如111123，假设val&#x3D;1，连续的1，当时我是用if的情况，条件满足头节点指向下一个，但是如果连续的val在头节点的后面，就会出错。后面1233244441111232，我又用if，还是没删干净，我粘一下我的错误的代码，大家以此为戒，也可以看看我的错误代码思考我的问题。\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        current = head        while current and current.next:            if current.val == val:                head = current.next            if current.next.val == val:                current.next = current.next.next            else :                current = current.next        return head     \n\n设计链表\n题意：  在链表类中实现这些功能：\n\n\nget(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\naddAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\naddAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\naddAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\ndeleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\n\nclass ListNode:    def __init__(self,val=0,next=None):        self.val = val        self.next = nextclass MyLinkedList:    def __init__(self):           self.dummy_node = ListNode()        self.size = 0    def get(self, index: int) -&gt; int:        if index &gt;= self.size or index &lt; 0:   #为啥不能取等，类似数组下标从零开始            return -1        current = self.dummy_node.next # 有效节点从虚拟节点下一个开始        for i in range(index):#这里循环用来找目标，链表的查找是要遍历的，不像数组用下标就行            current = current.next        return current.val    def addAtHead(self, val: int) -&gt; None:        self.dummy_node.next = ListNode(val,self.dummy_node.next) #从右往左，先创建新的节点，且新节点的下个节点指向原来虚拟头的next，然后再让虚拟头指向新节点        self.size += 1    def addAtTail(self, val: int) -&gt; None:        current = self.dummy_node        while current.next:            current = current.next        current.next = ListNode(val)        self.size += 1    def addAtIndex(self, index: int, val: int) -&gt; None:        if index &lt; 0 or index &gt; self.size:            return -1         current = self.dummy_node        for i in range(index):            current = current.next        current.next = ListNode(val,current.next)        self.size += 1    def deleteAtIndex(self, index: int) -&gt; None:        if index &lt; 0 or index &gt;= self.size:            return        current = self.dummy_node        for i in range(index):            current = current.next        current.next = current.next.next        self.size -= 1\n我做过卡码网的链表的基本操作，期末考完我把卡码网我做过的题也记录到这个blog里额，就是index合法性检查，然后增加删除的基本操作\n反转链表题意：反转一个单链表。\n\n示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL方法一：双指针法\n\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        pre = None        current = head        while current:            temp = current.next            current.next = pre            pre = current            current = temp        return pre\n通过设置当前指针，pre指针来实现，每次循环都让当前指针指向前一个节点，然后pre指针移动到当前指针，当前指针移动到下一个节点，直到当前指针为空，返回pre指针。但是只是这样会丢失current.next的节点，因此需要temp指针来暂存current.next的节点，然后让current指针指向前一个节点，pre指针移动到current指针，current指针移动到temp指针，直到current指针为空，返回pre指针。\n方法二：递归法\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        return self.reverse(head,None)        def reverse(self,current,pre) :        if current == None:            return pre        temp = current.next        current.next = pre        return self.reverse(temp,current)\n实话实话，让我再写一遍我写不出递归，我再捣鼓捣鼓吧，视频看懂了但又好像没看懂\n","categories":["算法学习——链表"],"tags":["代码随想录"]},{"title":"代码随想录-day7","url":"/2025/12/23/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day7/","content":"四数相加II\n给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。\n\n\n例如:输入:A &#x3D; [ 1, 2]B &#x3D; [-2,-1]C &#x3D; [-1, 2]D &#x3D; [ 0, 2]输出:2解释:两个元组如下:(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0\n\nclass Solution:    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:        t_set = &#123;&#125;        count = 0        for i in nums1:            for j in nums2:                t_set[i+j] = t_set.get(i+j,0) + 1        for i in nums3:            for j in nums4:                if 0-(i+j) in t_set.keys():                    count += t_set[0-(i+j)]        return count\n这道题就是将四个数分成两组前两个数一组，并把他们的和作为key，出现的次数作为value，存到一个哈希表中。然后遍历后两个数的组合，判断0-(i+j)是否在哈希表中，如果在，就把出现的次数加到count中（注意加的是value的值不是一，原因是不用去重）。\n赎金信\n给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\n\n\n例如:输入: ransomNote &#x3D; “a”, magazine &#x3D; “b”输出: false输入: ransomNote &#x3D; “aa”, magazine &#x3D; “ab”输出: false输入: ransomNote &#x3D; “aa”, magazine &#x3D; “aab”输出: true\n\nclass Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        a_hash = [0] * 26        for i in magazine:            a_hash[ord(i)-ord(&#x27;a&#x27;)] += 1        for i in ransomNote:            if a_hash[ord(i)-ord(&#x27;a&#x27;)] == 0:                return False            else :                a_hash[ord(i)-ord(&#x27;a&#x27;)] -= 1        return True\n这道题就是用一个哈希表来记录 magazine 中的字符出现的次数，然后遍历 ransomNote 中的字符，判断是否在哈希表中，如果在，就把哈希表中对应的值减一。直到遇到了0，就说明 magazine 中的字符不能构成 ransomNote 中的字符，返回 False。跟昨天第一题很像\n三数之和\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。注意： 答案中不可以包含重复的三元组。\n\n\n示例：给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]\n\nclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        result = []        nums.sort()        for i in range(len(nums)):            if nums[i] &gt; 0 :                return result            if i &gt; 0 and nums[i] == nums[i-1]:                continue            left = i + 1            right = len(nums) - 1            while left &lt; right:                if nums[i] + nums[left] + nums[right] &gt; 0:                    right -= 1                elif nums[i] + nums[left] + nums[right] &lt; 0:                    left += 1                else:                    result.append([nums[i],nums[left],nums[right]])                    while left &lt; right and nums[left] == nums[left + 1]:                        left += 1                    while left &lt; right and right &lt; len(nums)-1 and nums[right] == nums[right - 1]:                        right -= 1                    right -= 1                    left += 1        return result\n用了双指针的思路首先先对数组排序，然后for循环用i作为第一个数，left作为第二个数，right作为第三个数，三个数求和判断是否等于0，如果等于0，就把这三个数加入到结果中。如果大于0，就把right减一，如果小于0，就把left加一。直到left大于等于right，就说明这个数组合完了，就可以继续下一个数了。注意点去重操作是i和i-1比较，left和left+1比较，right和right-1比较，为啥这样的，因为i是基准，如果i和i+1判断，把下一个i跳了，i就像边界一样，left就指不到被跳的i的那个位置了，比如-2 -1 -1 0 2，但是i继续加一以后，发现和之前的i一样，这个i就可去掉了，这里不会重复是上一组的i已经用过这个顺序了，例如-1 -1 0 0 1 2，然后left和right就是和自己的下一个数比较即可，而且不会遗漏，哪怕有连续的left挑掉，right也会移动过去，不像i是基准\n四数之和\n题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。\n\n\n示例： 给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]\n\nclass Solution:    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:        result = []        nums.sort()        for i in range(len(nums)):            if nums[i]&gt;0 and nums[i] &gt; target//4 :                break #这里不能return result            if i&gt;0 and nums[i] == nums[i-1]:                continue            for j in range(i+1,len(nums)):                if nums[i] + nums[j] &gt; target and target &gt; 0:                     break                if j &gt; i+1 and nums[j] == nums[j-1]:                    continue                left,right = j+1,len(nums)-1                while left &lt; right:                    sum_=nums[i]+nums[j]+nums[left]+nums[right]                    if sum_ == target:                        result.append([nums[i],nums[j],nums[left],nums[right]])                        while left &lt; right and nums[left] == nums[left+1]:                            left += 1                        while right &gt; left and nums[right] == nums[right-1]:                            right -= 1                        left += 1                        right -= 1                    elif sum_ &gt; target    :                        right -= 1                    else :                        left += 1        return result\n就是在i的基础上加了一个j也作为基准，然后在i和j的基础上用双指针的思路，left和right作为第三个数和第四个数，判断是否等于target，如果等于0，就把这四个数加入到结果中。我再思考一下\n","categories":["算法学习——哈希表"],"tags":["代码随想录"]},{"title":"python中我遇到的语法问题","url":"/2025/12/23/python%E4%B8%AD%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98/","content":"字典1.python中查询key是否存在直接用key in dict，并且时间复杂度为O(1)因为字典底层是哈希表实现的。2.字典的get方法可以设置默认值，比如dict.get(key, default_value)，如果key不存在则返回default_value。3.分别使用dict.keys()、dict.values()、dict.items()可以获取字典的所有key、value、key-value对。注意，这三个都是方法，括号别忘了写。\n数组1.空数组的创建可以用[]或者list()，比如a = []或者a = list()。如果设置初值可以用a = [0]*n或者a = list([0]*n)。2. 数组的切片可以用array[start:end:step]，比如a[1:3]表示获取数组a中索引从1到2的元素（不包括3），a[::-1]表示将数组a反转。3. Python 中切片赋值时，右侧的赋值对象必须是可迭代对象，字符串 “number” 会被自动拆解为单个字符的可迭代序列，再逐个赋值到切片对应的位置(res[new_index-5:new_index+1] &#x3D; “number”)\n排序\npython中排序可以用list.sort()或者sorted(list)，前者是在原数组上排序，后者是返回一个新的排序后的数组。\n排序默认是升序排序，如果要降序排序可以用list.sort(reverse=True)或者sorted(list, reverse=True)。\n\n字符串\npython中字符串是不可变的，所以如果要修改字符串中的某个字符，只能先将字符串转换为列表，修改后再转换为字符串。\n字符串的拼接可以用+号，也可以用join()方法，比如&#39;a&#39;+&#39;b&#39;或者&#39;a&#39;.join([&#39;b&#39;, &#39;c&#39;])。\n判断字符串是否只包含数字可以用str.isdigit()方法，比如&#39;123&#39;.isdigit()返回True，&#39;123a&#39;.isdigit()返回False。\n\n表达式\n生成器表达式是一种简洁的创建生成器的方式，它的语法和列表推导式类似，但是用圆括号括起来，比如(x for x in range(5))。\n\n","tags":["笔记"]},{"title":"LeetCode_1","url":"/2025/12/01/hello-world/","content":"  从这篇文章开始，我将会将我在算法练习中的所想和收获记录下来。\n1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。\n1.1 思路1  思路1是最简单的思路，就是遍历数组，对于每个元素，都去数组中查找是否有目标值减去当前值的元素。  时间复杂度为O(n^2)，空间复杂度为O(1)。  class Solution:  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:      for i in nums:          j = target - i          start_index = nums.index(i)          next_index = start_index + 1           nums_new = nums[next_index:]#对原数组进行切片，去掉当前元素之前的元素          if j in nums_new:              return [start_index,next_index+nums_new.index(j)]\n1.2 思路2(哈希表)  思路2是利用哈希表来解决问题。我们遍历数组，对于每个元素，都去哈希表中查找是否有目标值减去当前值的元素。  如果有，就返回当前元素的下标和哈希表中目标值减去当前值的元素的下标。  如果没有，就将当前元素和下标加入哈希表中。  时间复杂度为O(n)，空间复杂度为O(n)。用空间换时间  class Solution:  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:      dir=&#123;&#125;      for i in range(len(nums)): #遍历数组          if target-nums[i] not in dir: #如果目标值减去当前值不在字典中              dir[nums[i]] = i          else :              return [dir[target-nums[i]],i]\n9. 回文数  给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。  回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。  例如，121 是回文，而 123 不是。(负数不是回文数)\n9.1 思路1  思路1是将整数%10，得到最后一位数，然后将整数&#x2F;&#x2F;10，去掉最后一位数，重复这个过程，直到整数变成0。  每次得到的数都乘以10，最后得到的数就是整数的倒序。  时间复杂度为O(logn)，空间复杂度为O(1)。  if (x&lt;0):          return False      else :          a = x          num = 0          while(a!=0):              num =10 * num + a % 10              a = a // 10          if (x == num):              return True          else:              return False\n","categories":["算法学习——哈希"],"tags":["leetcode"]},{"title":"代码随想录-day9","url":"/2025/12/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day9/","content":"翻转字符串里的单词\n给定一个字符串，逐个翻转字符串中的每个单词。\n\n\n示例 1：输入: “the sky is blue”输出: “blue is sky the”\n示例 2：输入: “  hello world!  “输出: “world! hello”解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n示例 3：输入: “a good   example”输出: “example good a”解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。方法一：split()分割加列表反转\n\nclass Solution:    def reverseWords(self, s: str) -&gt; str:        s_list = s.split()        s_list = s_list[::-1]        return &quot; &quot;.join(s_list)\n方法二：双指针法\nclass Solution:    def reverseWords(self, s: str) -&gt; str:        class Solution:    def reverseWords(self, s: str) -&gt; str:        s = s.split()        left,right = 0,len(s)-1        while left &lt; right:            s[left],s[right]=s[right],s[left]            left += 1            right -= 1        return &quot; &quot;.join(s)\n视频的方法今天有点来不及\n右旋字符串\n字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。输出：输出共一行，为进行了右旋转操作后的字符串。\n\n\n样例输入：2abcdefg样例输出：fgabcde\n\n数据范围：1 &lt;&#x3D; k &lt; 10000, 1 &lt;&#x3D; s.length &lt; 10000\nn=int(input())s=input()print(s[-n:]+s[:-n])\n额，今天考马原上午都在看马原，额，但是不得不说，python真的太刁了，字符串切片操作真的是太方便了，但是我还是要提醒一下，字符串是不可变的，所以切片操作不会改变原字符串，而是返回一个新的字符串。\n日记感觉马原要挂科。明明我背那么久了，结果全背错了，张冠李戴给我玩明白了，我服了。一想到考研要考政治我就绝望\n","categories":["算法学习——字符串"],"tags":["代码随想录"]},{"title":"代码随想录-day8","url":"/2025/12/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day8/","content":"反转字符串\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n\n\n示例 1：输入：[“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”]\n示例 2：输入：[“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”]\n\nclass Solution:    def reverseString(self, s: List[str]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify s in-place instead.        &quot;&quot;&quot;        j=len(s)-1        for i in range(len(s)//2):            s[i],s[j] = s[j],s[i]            j -= 1\n这道题的思路是用双指针的方式，分别指向头尾，然后交换位置，循环判断条件就到中间位置（比长度的一半小）。\n反转字符串IIleetcode链接\n\n给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n\n\n示例:输入: s &#x3D; “abcdefg”, k &#x3D; 2输出: “bacdfeg”\n\nclass Solution:    def reverseStr(self, s: str, k: int) -&gt; str:        def c_r(s_):            left,right = 0,len(s_)-1            while left &lt; right:                s_[left],s_[right]=s_[right],s_[left]                left += 1                right -= 1            return s_        i=0        s_list=list(s)        while i &lt; len(s):            s_list[i:i+k] = c_r(s_list[i:i+k])            i += 2 * k        return &quot;&quot;.join(s_list)\nclass Solution:    def reverseStr(self, s: str, k: int) -&gt; str:        s = list(s)        for i in range(0, len(s), 2*k):            s[i:i+k] = s[i:i+k][::-1]        return &#x27;&#x27;.join(s)\n这道题的主要特点是切片的方式是以2k为步长，每次取k个字符进行反转。并且python的切片操作是可以超出索引范围的，会自动截断为有效范围。（Python 切片的容错特性：无需判断剩余字符长度，i:i+k 自动截断为有效范围，让 “反转前 k 个 &#x2F; 反转全部剩余” 的要求自然满足），i相当于一个指针，每次移动2k个位置，只要能移动在下一次循环就进行切片。\n替换数字\n给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。\n\n\n例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。对于输入字符串 “a5b”，函数应该将其转换为 “anumberb”输入：一个字符串 s,s 仅包含小写字母和数字字符。输出：打印一个新的字符串，其中每个数字字符都被替换为了number样例输入：a1b2c3样例输出：anumberbnumbercnumber数据范围：1 &lt;&#x3D; s.length &lt; 10000。\n\nn = input()count_num = sum(1 for i in n if i.isdigit())count = count_num * 5 + len(n) #记得count_num是数字字符的个数，每个数字字符替换为number后会增加5个字符，所以是*5n_list = [&#x27;&#x27;] * counto_p = len(n)- 1n_p = count - 1while o_p &gt;= 0:    if n[o_p].isdigit():        n_list[n_p-5:n_p+1] = &quot;number&quot; #注意切片是位置到位置，不能直接[n_p-5:6]这种操作        n_p -= 6    else :        n_list[n_p]=n[o_p]        n_p -= 1    o_p -= 1print(&quot;&quot;.join(n_list))\n这道题还是用双指针的方式，一个指向原字符串的尾，一个指向新字符串的尾，根据是否为数字字符来判断是否需要替换。如果是c语言从后向前可以避免每次替换后需要移动后面的字符的问题。python因为字符串是不可变的，所以需要先将字符串转换为列表，修改后再转换为字符串。然后就是要两个指针一一对应，一个指向原字符串的当前字符，一个指向新字符串的当前位置。\n","categories":["算法学习——字符串"],"tags":["代码随想录"]}]