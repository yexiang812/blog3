[{"title":"python中我遇到的语法问题","url":"/2025/12/23/python%E4%B8%AD%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98/","content":"字典1.python中查询key是否存在直接用key in dict，并且时间复杂度为O(1)因为字典底层是哈希表实现的。2.字典的get方法可以设置默认值，比如dict.get(key, default_value)，如果key不存在则返回default_value。3.分别使用dict.keys()、dict.values()、dict.items()可以获取字典的所有key、value、key-value对。注意，这三个都是方法，括号别忘了写。\n数组1.空数组的创建可以用[]或者list()，比如a = []或者a = list()。如果设置初值可以用a = [0]*n或者a = list([0]*n)。2. 数组的切片可以用array[start:end:step]，比如a[1:3]表示获取数组a中索引从1到2的元素（不包括3），a[::-1]表示将数组a反转。3. Python 中切片赋值时，右侧的赋值对象必须是可迭代对象，字符串 “number” 会被自动拆解为单个字符的可迭代序列，再逐个赋值到切片对应的位置(res[new_index-5:new_index+1] &#x3D; “number”)\n排序\npython中排序可以用list.sort()或者sorted(list)，前者是在原数组上排序，后者是返回一个新的排序后的数组。\n排序默认是升序排序，如果要降序排序可以用list.sort(reverse=True)或者sorted(list, reverse=True)。\n\n字符串\npython中字符串是不可变的，所以如果要修改字符串中的某个字符，只能先将字符串转换为列表，修改后再转换为字符串。\n字符串的拼接可以用+号，也可以用join()方法，比如&#39;a&#39;+&#39;b&#39;或者&#39;a&#39;.join([&#39;b&#39;, &#39;c&#39;])。\n判断字符串是否只包含数字可以用str.isdigit()方法，比如&#39;123&#39;.isdigit()返回True，&#39;123a&#39;.isdigit()返回False。\n\n表达式\n生成器表达式是一种简洁的创建生成器的方式，它的语法和列表推导式类似，但是用圆括号括起来，比如(x for x in range(5))。\n\n队列\ndeque（发音：deck），它是 Python 标准库 collections 中的「双端队列」，实现了在队列两端高效插入和删除元素的功能。相比于列表，deque 在头尾操作时具有更好的性能表现，时间复杂度为 O(1)。\n\ndeque 提供了 append()、appendleft()、pop()、popleft() 等方法，分别用于在队列的右端插入元素、左端插入元素、从右端删除元素、从左端删除元素。\n\ndeque 支持索引访问，比如deque[0]表示获取队列的队头元素，deque[-1]表示获取队列的队尾元素。\n\n\n","tags":["笔记"]},{"title":"python_入门练习","url":"/2025/12/09/python-%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0/","content":"  不得不说我的代码能力太弱了，只能先从简单的开始了。\n1.A+B问题I题目描述\n\n你的任务是计算a+b。输入描述输入包含一系列的a和b对，通过空格隔开。一对a和b占一行。输出描述如对于输入中的第二对a和b，  在输出中它们的和应该也在第二行。输入示例1 2  3 4输出示例3  7\n\n我的解法while True:    try:        a,b = map(int,input().split())        print(a+b)    except:        break\n好吧我承认我的代码能力是极差的。第一个问题如何保证一直接受用户输入，首先就要用一个一直循环的while语句，直到没有输入后跳出循环。可以用if判断啥时候输入为空，也可以用try except保证输入的合法性。然后就是map函数，这个函数的核心是对序列里面的每一个元素批量应用同一个处理规则，这里是将输入的字符串转换为整数。这里的.split()函数是将输入的字符串按照空格隔开，返回一个列表。哦，补充一下input函数输入的内容是字符串。\n2.A+B问题II题目描述\n\n计算a+b，但输入方式有所改变。输入描述第一行是一个整数N，表示后面会有N行a和b，通过空格隔开。输出描述对于输入的每对a和b，你需要在相应的行输出a、b的和。  如第二对a和b，对应的和也输出在第二行。输入示例2  2 4  9 21输出示例6  30提示信息注意，测试数据不仅仅一组。也就是说，会持续输入N以及后面的a和b\n\n解法1这道题和上一道题的区别在于，上一道题是一直接受用户输入，直到没有输入为止。这道题是先接受一个整数N，然后接受N行a和b，输出N行a+b。而且分组输入导致每一块都有组数N，就不能像上一道题一样无脑接收输入了。补充知识：.strip()函数是去掉字符串首尾的空格，包括换行符、制表符等。\nwhile True:    try:        N = int(input().strip())        for i in range(N):            a,b = map(int,input().split())            print(a+b)    except:        break\n解法2import sysfor line in sys.stdin:    N=int(line.strip())    for i in range(N):        a,b=map(int,sys.stdin.readline().strip().split())        print(a+b)\n\n导入sys模块后，通过for line in sys.stdin启动外层循环——这个循环的作用是逐个读取输入中“每组数据的开头行（即N所在的行）”。每次外层循环执行时：\n\n\n首先处理当前读取到的line：这行内容是当前组的分组信息（整数N），通过int(line.strip())转成整数后，明确“这一组需要处理N对a和b”。\n\n接着启动内层循环for _ in range(N)：这个循环的作用是主动读取当前组内的N行a和b数据。每次内层循环会通过sys.stdin.readline()读取一行新的输入（这行是a和b，用空格分隔），经过strip()清理空白、split()拆分、map(int, ...)转整数后，得到a和b的值，计算并输出它们的和。内层循环会严格执行N次，确保当前组的N对a和b全部被处理。\n\n内层循环结束后，外层循环才会继续执行：此时外层循环会自动读取下一行输入，而这一行恰好是“下一组数据的N”（因为内层循环已经主动读完了上一组的N行a和b，不会让外层循环误读这些行）。\n\n\n整个过程中，外层循环负责“按组拆分输入”（找到每一组的N），内层循环负责“按组内数量处理数据”（读完N对a和b），两层循环分工配合，既不会漏读数据，也不会错把a和b的行当成N处理，最终完美实现“持续处理多组N及对应a+b”的题目要求。sys.stdin():内置的标准输入流对象，用于从控制台或其他输入源读取数据。sys.stdin.readline()：读取输入的一行,从stdin中读取一行数据,包括换行符。\n","tags":["入门算法"]},{"title":"一些关于编程语言的知识","url":"/2025/12/26/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%9F%A5%E8%AF%86/","content":"以下内容来自ai（豆包），为了我自己的学习，我把它记录下来。\nSTL一、STL 到底是什么？STL 是 Standard Template Library（标准模板库） 的缩写，是 C++ 标准库的核心组成部分，本质是一套 通用、可复用的模板类&#x2F;函数库。\n简单说：\n\n它是 C++ 官方提供的“工具集”，不用自己写基础数据结构（比如栈、队列、数组、链表）和算法（比如排序、查找、遍历），直接调用就行；\n核心优势是 模板化（跨数据类型通用，比如一个 vector 既可以存 int，也能存 string）、高效（底层用最优算法实现）、标准化（所有符合 C++ 标准的编译器都支持，比如 GCC、Clang、MSVC）。\n\nSTL 主要包含 6 大组件，日常开发最常用的是前 4 个：\n\n\n\n组件\n作用\n\n\n\n容器（Container）\n存储数据的“容器”（比如 vector 动态数组、list 链表、stack 栈、map 字典）\n\n\n算法（Algorithm）\n操作容器数据的算法（比如 sort 排序、find 查找、reverse 反转）\n\n\n迭代器（Iterator）\n连接容器和算法的“桥梁”（类似指针，遍历容器数据）\n\n\n适配器（Adaptor）\n对现有容器“包装改造”，改变其接口（比如 stack 就是对其他容器的适配器）\n\n\n函数对象（Functor）\n行为类似函数的对象（配合算法使用，比如自定义排序规则）\n\n\n分配器（Allocator）\n负责容器的内存分配&#x2F;释放（底层细节，用户一般不用关心）\n\n\n二、STL 中 stack 的实现原理stack（栈）的核心特性是 LIFO（后进先出）：只能从“栈顶”插入（push）、删除（pop）和访问（top）数据，不能随机访问中间元素。\n关键结论：stack 不是独立的容器，而是「容器适配器」STL 的 stack 本身不存储数据，它是对一个 底层容器（Underlying Container） 进行“包装”，限制了其接口（只暴露栈需要的 push/pop/top 等），底层数据的存储、内存管理全靠这个“被包装的容器”。\n1. 默认底层容器是什么？C++ 标准规定，stack 的 默认底层容器是 deque（双端队列）。选择 deque 的原因很简单：deque 支持 两端高效插入&#x2F;删除（时间复杂度 O(1)），而栈只需要操作“一端”（栈顶），用 deque 刚好匹配，且 deque 没有 vector 扩容时的拷贝开销，效率更高。\n2. 可以自定义底层容器吗？可以！stack 是模板类，允许用户指定底层容器，只要这个容器支持以下 3 个核心操作即可：\n\npush_back()：在尾部插入元素（栈顶对应容器尾部）；\npop_back()：删除尾部元素；\nback()：访问尾部元素。\n\n满足条件的容器有 vector、list、deque，比如：\n#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;list&gt;// 1. 默认底层容器：dequestd::stack&lt;int&gt; st1;// 2. 自定义底层容器为 vectorstd::stack&lt;int, std::vector&lt;int&gt;&gt; st2;// 3. 自定义底层容器为 liststd::stack&lt;int, std::list&lt;int&gt;&gt; st3;\n\n3. stack 的核心接口实现（伪代码）stack 的接口非常简单，本质就是“转发”到底层容器的对应操作，伪代码能直观体现：\ntemplate &lt;typename T, typename Container = std::deque&lt;T&gt;&gt;class stack &#123;private:    Container c;  // 底层容器（被包装的对象）public:    // 入栈：调用底层容器的 push_back()    void push(const T&amp; x) &#123; c.push_back(x); &#125;        // 出栈：调用底层容器的 pop_back()（注意：不返回元素）    void pop() &#123; c.pop_back(); &#125;        // 访问栈顶：调用底层容器的 back()    T&amp; top() &#123; return c.back(); &#125;        // 栈是否为空：调用底层容器的 empty()    bool empty() const &#123; return c.empty(); &#125;        // 栈的大小：调用底层容器的 size()    size_t size() const &#123; return c.size(); &#125;&#125;;\n\n从伪代码能看出来：stack 没有自己的“数据存储逻辑”，所有操作都依赖底层容器，它只做了一件事——隐藏底层容器的其他接口（比如 vector 的 operator[] 随机访问），只暴露栈需要的 LIFO 接口。\n三、补充：stack 为什么不叫“容器”而叫“适配器”？\n容器（比如 vector、list）：是“原始存储容器”，支持完整的元素访问&#x2F;操作（比如 vector 可以随机访问、list 可以双向遍历）；\n适配器（比如 stack、queue）：是“包装器”，不提供原始存储，而是基于现有容器，通过“限制接口”来实现特定的数据结构行为（栈的 LIFO、队列的 FIFO）。\n\n简单说：适配器是“改造现有容器”，而容器是“原生存储数据”。\n总结\nSTL 是 C++ 标准库的核心，是通用的模板工具集，包含容器、算法、迭代器等组件；\nSTL 的 stack 是 容器适配器，底层不存数据，依赖其他容器实现；\n默认底层容器是 deque，也可指定 vector 或 list（需支持 push_back/pop_back/back）；\nstack 的所有接口（push/pop/top）都是转发到底层容器的对应操作，核心是实现 LIFO 特性。\n\ndequefrom collections import deque 是 Python 中导入内置容器类 deque 的标准语法，以下是关于 deque 的详细解析、用法和场景说明：\n一、核心基础：什么是 deque？\n全称：Double-Ended Queue（双端队列）\n本质：Python 标准库 collections 模块提供的高效双端队列数据结构，支持两端（队首&#x2F;队尾）的快速插入和删除操作。\n与 list 的区别：\nlist 基于数组实现，队首插入&#x2F;删除（如 list.insert(0, x)、list.pop(0)）时间复杂度为 O(n)（需移动所有元素）；\ndeque 基于双向链表（或类似优化结构）实现，两端操作时间复杂度均为 O(1)，效率远超 list。\n\n\n\n二、基本用法（需先导入 deque）1. 初始化 dequefrom collections import deque# 1. 空队列dq = deque()# 2. 从可迭代对象（列表、字符串、元组等）初始化dq1 = deque([1, 2, 3])       # deque([1, 2, 3])dq2 = deque(&quot;abc&quot;)           # deque([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])dq3 = deque((4, 5, 6), maxlen=5)  # 限制最大长度为5（超出会自动丢弃另一端元素）\n\n2. 两端插入操作（核心优势）\n\n\n方法\n功能\n示例\n结果\n\n\n\nappend(x)\n队尾添加元素 x\ndq1.append(4)\ndeque([1, 2, 3, 4])\n\n\nappendleft(x)\n队首添加元素 x\ndq1.appendleft(0)\ndeque([0, 1, 2, 3, 4])\n\n\nextend(iterable)\n队尾批量添加可迭代对象\ndq1.extend([5, 6])\ndeque([0,1,2,3,4,5,6])\n\n\nextendleft(iterable)\n队首批量添加（逆序插入）\ndq1.extendleft([-2, -1])\ndeque([-1, -2, 0,1,2,3,4,5,6])\n\n\n\n注意 extendleft：会将可迭代对象的元素逆序插入队首（如 extendleft([a,b]) 等价于 appendleft(b) 后 appendleft(a)）。\n\n3. 两端删除操作\n\n\n方法\n功能\n示例\n结果\n\n\n\npop()\n队尾删除并返回元素\ndq1.pop()\n返回 6，队列变为 deque([-1,-2,0,1,2,3,4,5])\n\n\npopleft()\n队首删除并返回元素\ndq1.popleft()\n返回 -1，队列变为 deque([-2,0,1,2,3,4,5])\n\n\nclear()\n清空队列\ndq1.clear()\ndeque([])\n\n\n4. 其他常用方法\nmaxlen 属性：获取队列最大长度（初始化时指定，不可修改）\ndq = deque([1,2,3], maxlen=3)print(dq.maxlen)  # 3dq.append(4)      # 超出maxlen，队首元素1被自动丢弃print(dq)         # deque([2, 3, 4])\n\nrotate(n)：队列旋转（默认 n=1，队尾元素移到队首；n=-1 则队首元素移到队尾）\ndq = deque([1,2,3,4])dq.rotate(1)   # 右旋转1位：4→队首print(dq)      # deque([4, 1, 2, 3])dq.rotate(-2)  # 左旋转2位：4、1→队尾print(dq)      # deque([2, 3, 4, 1])\n\ncount(x)：统计元素 x 的出现次数\ndeque([1,2,2,3]).count(2)  # 2\n\nremove(x)：删除第一个出现的元素 x（不存在则抛 ValueError）\ndq = deque([1,2,3,2])dq.remove(2)print(dq)  # deque([1, 3, 2])\n\n三、典型应用场景1. 实现队列（FIFO：先进先出）from collections import dequequeue = deque()# 入队（队尾添加）queue.append(&quot;a&quot;)queue.append(&quot;b&quot;)# 出队（队首删除）print(queue.popleft())  # &quot;a&quot;print(queue.popleft())  # &quot;b&quot;\n\n2. 实现栈（LIFO：后进先出）（直接用 append() 和 pop()，等价于栈的压栈&#x2F;出栈）\nstack = deque()stack.append(1)stack.append(2)print(stack.pop())  # 2（后进先出）print(stack.pop())  # 1\n\n3. 滑动窗口问题（利用 maxlen 自动维护窗口大小）例如：求数组中每个位置的前 k 个元素的平均值\nfrom collections import dequedef sliding_average(nums, k):    dq = deque(maxlen=k)    averages = []    for num in nums:        dq.append(num)        if len(dq) == k:  # 窗口满了才计算平均值            averages.append(sum(dq)/k)    return averagesprint(sliding_average([1,2,3,4,5,6], 3))  # [2.0, 3.0, 4.0, 5.0]\n\n4. 广度优先搜索（BFS）BFS 算法的核心是用队列存储待访问节点，deque 的 popleft() 效率远高于 list.pop(0)：\nfrom collections import dequedef bfs(root):    if not root:        return []    queue = deque([root])    result = []    while queue:        node = queue.popleft()  # 队首出队        result.append(node.val)        # 子节点入队        if node.left:            queue.append(node.left)        if node.right:            queue.append(node.right)    return result\n\n\n四、总结\ndeque 是 Python 中高效双端队列，核心优势是两端插入&#x2F;删除 O(1) 时间复杂度；\n功能覆盖队列、栈、滑动窗口等场景，比 list 更适合频繁操作两端的场景；\n需通过 from collections import deque 导入，支持 maxlen、rotate 等实用功能，是 Python 开发中高频使用的容器类。\n\n","tags":["笔记"]},{"title":"week1_复盘","url":"/2025/12/21/week1-%E5%A4%8D%E7%9B%98/","content":"week1_复盘day1第一道题 第一道题是二分搜索，几个关键点是，二分搜索得是有序数组，通过数学的二分法实现。代码细节，一个是左闭右开，目标值小于mid，调整右指针到mid，注意右边是开的，因此mid&#x3D;right，如果目标值大于mid，调整左指针到mid+1，注意左边是闭的，因此left&#x3D;mid+1。当然如果是左闭右闭，代码细节就会有一些变化，目标值小于mid，调整右指针到mid-1，注意右边是闭的，因此right&#x3D;mid-1，如果目标值大于mid，调整左指针到mid+1，注意左边是闭的，因此left&#x3D;mid+1。\n第二题是移除元素，设置快慢指针，快指针用来遍历数组，慢指针用来指向新数组的位置。然后和目标值比较，如果不相等，慢指针加一，然后赋值为快指针的值。如果相等，快指针加一，继续遍历。\n第三题然后是有序数组的平方，因为数组是有序的，所以平方后的最大值一定在数组的两端，所以可以设置双指针，一个指向数组的头，一个指向数组的尾。然后比较两个指针指向的元素的平方，将较大的那个放到新数组的末尾，然后对应的指针向中间移动。当然也可以用python的推导式加上sort函数，实现有序数组的平方。\nday2第一题长度最小的子数组这道题是滑动窗口，设置左右指针，初始都指向数组的头，然后右指针向右移动，直到窗口内的元素和大于等于目标值，然后记录下窗口的长度，然后左指针向右移动，直到窗口内的元素和小于目标值，然后继续移动右指针满足条件后继续记录下窗口的长度，直到右指针到达数组的尾。\n第二题螺旋矩阵II这道题的关键是边界判定，四条边都用左闭右开的方式，最后一个点给下一条边，还有是循环条件是n&#x2F;&#x2F;2，转一圈掉两层，然后是偏移量，最开始是0 0 然后每次循环偏移量加一，然后是n为奇数时，最后一个点单独处理等于n。\n你看看果然不能托现在才想起来附加题没做\nday3第一题 移除链表元素这道题主要是考虑头节点被删除的情况，所以可以设置一个虚拟头节点，指向头节点，然后设置一个指针指向虚拟头节点，然后遍历链表，如果下一个节点的值等于目标值，就删除下一个节点，否则指针后移。最后返回虚拟头节点的下一个节点。\n第二题 设计链表这道题主要是考虑链表的基本操作，比如添加节点，删除节点，获取节点的值等。主要是index的处理，哦对链表没法用下标的方式来访问节点，所以需要遍历链表来找到目标节点。\n第三题 反转链表这道题是双指针一个cur节点加一个pre节点以及临时节点temp，初始时pre指向None，cur指向头节点，然后遍历链表，每次将cur的next指向pre，然后pre移动到cur，cur移动到temp，最后返回pre。然后递归，还是不会写\nday4第一题 两两交换链表中的节点这道题主要是找到前置节点，然后交换两个节点，然后移动指针到下一个位置，注意判断条件的先后，防止空指针异常。设置了两个temp节点，一个用来保存下一个节点，一个用来保存下下下一个节点。可以用画图帮助理解。\n第二题 删除链表的倒数第N个节点这道题是快慢指针，先让快指针移动n+1步，然后快慢指针同时移动，直到快指针到达链表尾部，然后删除慢指针的下一个节点。\n第三题 链表相交这道题是双指针法，设置两个指针分别指向两个链表的头节点，然后同时移动两个指针，当一个指针到达链表尾部时，移动到另一个链表的头节点，继续移动，直到两个指针相等或者都为None。这样就能找到链表的交点。然后我自己想的是用梯形的感觉。\n第四题 环形链表II这道题是快慢指针，快指针每次移动两步，慢指针每次移动一步，直到快指针追上慢指针，或者快指针到达链表尾部。如果追上了，说明链表有环，然后快指针从链表头开始，慢指针从相遇点开始，每次移动一步，直到再次相遇，相遇点就是环的入口。如果快指针到达链表尾部，说明链表没有环。然后在起点的相遇的位置两个快慢节点改成速度相同，再次相遇的位置就是环的入口。\n我自己的杂谈这一周要准备期末考，又要坚持学代码，压力挺大的其实。虽然感觉期末成绩对我没啥用，但是总害怕大家觉得我天天不在宿舍一定天天读书的那种压力，尽管生活没有那么多的观众就是了，但是这种自我暗示也算是让我进行期末准备了，其实我还有很多自己想做的是，想看鱼书，想学数学，当然ctf也是落下好久了，确实娱乐比以前少了，但是效率总是很低，欸，可能也是天赋的缘故吧。其实我本来有很多想说的，但是这个blog公开了，也是怪不好意思的，那就这样吧\n","categories":["杂谈"],"tags":["杂谈——复盘"]},{"title":"LeetCode_1","url":"/2025/12/01/hello-world/","content":"  从这篇文章开始，我将会将我在算法练习中的所想和收获记录下来。\n1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。\n1.1 思路1  思路1是最简单的思路，就是遍历数组，对于每个元素，都去数组中查找是否有目标值减去当前值的元素。  时间复杂度为O(n^2)，空间复杂度为O(1)。  class Solution:  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:      for i in nums:          j = target - i          start_index = nums.index(i)          next_index = start_index + 1           nums_new = nums[next_index:]#对原数组进行切片，去掉当前元素之前的元素          if j in nums_new:              return [start_index,next_index+nums_new.index(j)]\n1.2 思路2(哈希表)  思路2是利用哈希表来解决问题。我们遍历数组，对于每个元素，都去哈希表中查找是否有目标值减去当前值的元素。  如果有，就返回当前元素的下标和哈希表中目标值减去当前值的元素的下标。  如果没有，就将当前元素和下标加入哈希表中。  时间复杂度为O(n)，空间复杂度为O(n)。用空间换时间  class Solution:  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:      dir=&#123;&#125;      for i in range(len(nums)): #遍历数组          if target-nums[i] not in dir: #如果目标值减去当前值不在字典中              dir[nums[i]] = i          else :              return [dir[target-nums[i]],i]\n9. 回文数  给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。  回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。  例如，121 是回文，而 123 不是。(负数不是回文数)\n9.1 思路1  思路1是将整数%10，得到最后一位数，然后将整数&#x2F;&#x2F;10，去掉最后一位数，重复这个过程，直到整数变成0。  每次得到的数都乘以10，最后得到的数就是整数的倒序。  时间复杂度为O(logn)，空间复杂度为O(1)。  if (x&lt;0):          return False      else :          a = x          num = 0          while(a!=0):              num =10 * num + a % 10              a = a // 10          if (x == num):              return True          else:              return False\n","categories":["算法学习——哈希"],"tags":["leetcode"]},{"title":"代码随想录_day1","url":"/2025/12/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day1/","content":"可恶，今天有点拖拖拉拉的，博客只能水一点了\n二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n示例 1: 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2:\n\n 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间\nright=len(nums)        left=0        while left &lt; right:            middle = (left + right) // 2            if target &lt; nums[middle]:                right = middle            elif target &gt; nums[middle]:                left  = middle + 1            else :                return middle        return -1\n二分查找有点类似数学的二分法，来简化查找的次数，一个是左闭右闭，right就是指向真实的下标，然后更新的左右都不取到中间值，另一个是左闭右开，right指向数组的数量（实际加一），更新的右边都取到中间值。\n移除数组给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。\n\n示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n你不需要考虑数组中超出新长度后面的元素。\nclass Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        length=len(nums)        i = 0        while i &lt; length:            if nums[i]  == val:                for j in range(i,length-1):                    nums[j]=nums[j+1]                length -= 1            else:                i += 1        return length\n这个是暴力解法，双层循环\nslow = 0        for fast in range(len(nums)):            if  nums[fast] != val:                nums[slow]=nums[fast]                slow += 1        return slow\n这个是快慢指针讲一下思路，简单来说就是，设置两个指针，快的指针用来遍历原来的数组，慢的就用来表示新的数组的下标，然后比较快指针对应的和val一不一样，留下不一样的，一样的就跳过，最后返回慢指针的下标就是新数组的长度\n有序数组的平方给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n示例 1： 输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]\n\n 示例 2： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]\nclass Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        s1 = 0        k= s2 = len(nums)-1        nums_list=[0]*len(nums)        while s1 &lt;= s2:            if nums[s1]**2 &gt; nums[s2]**2:                nums_list[k] = nums[s1]**2                s1 += 1            else :                nums_list[k] = nums[s2]**2                 s2 -= 1            k -= 1        return nums_list\n这个是双指针的方法，设置两个指针，一个指向数组的头，一个指向数组的尾，然后比较两个指针指向的元素的平方，把大的那个放到新数组的最后面，然后相应的指针向中间移动，最后返回新数组\nreturn sorted(x*x for x in nums)\n无需多言，排序加推导式\n来不及了，要回宿舍了，下次不能拖拖拉拉了\n","categories":["算法学习——数组"],"tags":["代码随想录"]},{"title":"代码随想录-day10","url":"/2025/12/26/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day10/","content":"用栈实现队列题目链接\n\n使用栈实现队列的下列操作：push(x) – 将一个元素放入队列的尾部。pop() – 从队列首部移除元素。peek() – 返回队列首部的元素。empty() – 返回队列是否为空。示例:\n\nMyQueue queue = new MyQueue();queue.push(1);queue.push(2);queue.peek();  // 返回 1queue.pop();   // 返回 1queue.empty(); // 返回 false\n说明:你只能使用标准的栈操作 – 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\nclass MyQueue:    def __init__(self):        self.stack_in = []        self.stack_out = []    def push(self, x: int) -&gt; None:        self.stack_in.append(x)    def pop(self) -&gt; int:        if self.empty():            return None        if self.stack_out :            return self.stack_out.pop()        else:            for i in range(len(self.stack_in)):                self.stack_out.append(self.stack_in.pop())            return self.stack_out.pop()    def peek(self) -&gt; int:        result = self.pop()        self.stack_out.append(result)        return result    def empty(self) -&gt; bool:        return not  (self.stack_in or self.stack_out)\n由于栈是先进后出，队列是先进先出，所以需要两个栈来实现队列的功能。实现负负得正。然后查看头节点可以用出队列的代码复用，得到后记得再入栈\n用队列实现栈题目链接\n\n使用队列实现栈的下列操作：\n\n\npush(x) – 元素 x 入栈\npop() – 移除栈顶元素\ntop() – 获取栈顶元素\nempty() – 返回栈是否为空\n\n注意:\n\n你只能使用队列的基本操作– 也就是 push to back, peek&#x2F;pop from front, size, 和 is empty 这些操作是合法的。\n你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。\n\nclass MyStack:    def __init__(self):        self.deq = deque()    def push(self, x: int) -&gt; None:        self.deq.append(x)    def pop(self) -&gt; int:        if self.empty():            return None        else :            for i in range(len(self.deq)-1):                self.deq.append(self.deq.popleft())            return self.deq.popleft()    def top(self) -&gt; int:        if self.empty():            return None        return self.deq[-1]    def empty(self) -&gt; bool:        return not self.deq\n使用一个队列来实现栈的功能。入栈直接入队列即可。出栈需要将队列中的元素依次出队列再入队列，直到只剩下最后一个元素，这个元素就是栈顶元素，直接出队列即可。\n有效的括号题目链接\n\n给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。有效字符串需满足：\n\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n每个右括号都有一个对应的相同类型的左括号。示例 1：\n\n输入：s = &quot;()&quot;输出：true\n示例 2：\n输入：s = &quot;()[]&#123;&#125;&quot;输出：true\n示例 3：\n输入：s = &quot;(]&quot;输出：false\nclass Solution:    def isValid(self, s: str) -&gt; bool:        stack = []        if len(s) %2 == 1:            return False        for i in s:            if i == &quot;(&quot;:                stack.append(&quot;)&quot;)            elif i == &quot;[&quot;:                stack.append(&quot;]&quot;)            elif i == &#x27;&#123;&#x27;:                stack.append(&quot;&#125;&quot;)            elif not stack or i != stack[-1]:                return False            else:                stack.pop()        return True  if not stack else False\n这道题是用栈来实现的，遍历字符串，遇到左括号就入栈，遇到右括号就出栈，判断是否匹配。提前为空、栈顶元素不匹配、字符串遍历完成后栈不为空，这三种情况都是无效的。我遇到了一个很有意思的错误elif not stack or i != stack.pop():原先我的代码是这样的，但是报错确实在十六行告诉我空栈不能pop，我原本以为是因为python的判断条件是左右会都判断，哪怕左边已经为真了，但其实问题是我在判断栈顶元素是否匹配时，直接用了pop方法，提前把最后一元素出栈这会导致栈为空后续没法pop。\n删除字符串中的所有相邻重复项题目链接\n\n给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n\n\n示例：\n\n输入：”abbaca”\n\n输出：”ca”\n\n解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。提示：\n\n1 &lt;&#x3D; S.length &lt;&#x3D; 20000\n\nS 仅由小写英文字母组成。\n\n\nclass Solution:    def removeDuplicates(self, s: str) -&gt; str:        stack = []        for i in s:            if stack and i == stack[-1]:                stack.pop()            else :                stack.append(i)        return &quot;&quot;.join(stack)\n这道题是用栈来实现的，遍历字符串，遇到字符就入栈，遇到和栈顶元素相同的字符就出栈。最后栈中的元素就是没有重复项的字符串。\n","categories":["算法学习——栈和队列"],"tags":["代码随想录"]},{"title":"代码随想录-day2","url":"/2025/12/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day2/","content":"长度最小的子数组\n给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n\n示例：\n\n输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n\n提示：\n\n1 &lt;&#x3D; target &lt;&#x3D; 10^9\n1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5\n1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5\n\nclass Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        length = len(nums)        left = 0        right = 0  #左闭右闭        min_nums = length + 1        sum_n = 0        while right &lt; length:            sum_n += nums[right]            while sum_n &gt;= target:                min_nums = min(right - left + 1,min_nums)                sum_n -= nums[left]                left += 1            right += 1        return min_nums if min_nums != length + 1 else 0\n这道题可以用滑动窗口的方式来实现设置两个指针left和right，分别指向子数组的左右边界。初始的时候设置两个指针都是0，即指向数组的第一个元素。然后通过移动右指针来扩大子数组的大小直到子数组的和大于等于target。这个时候我们得到的就是在起点为0条件下获得的最小子数组长度。因此我们可以移动左指针的位置，一方面可以缩小子数组的长度，另一方面也是调整子数组的起点。如果减去初始的左指针指向的元素后子数组的和仍然大于等于target，那么我们就可以继续移动左指针，直到子数组的和小于target，当然在这过程中要更新最小数组长度。如果子数组的和小于target了那我们就继续移动右指针，扩大子数组的大小。重复这个过程到循环结束\nclass Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        length = len(nums)        min_nums = length + 1        for i in range(length):            sum_n = 0            for j in range(i,length):                sum_n += nums[j]                if sum_n &gt;= target:                    min_nums = min(min_nums,j-i+1)                    break        return min_nums if min_nums != length + 1 else 0\n暴力解法就是用两个for循环，一个for循环遍历数组的每个元素，另一个for循环遍历从当前元素开始的所有子数组，计算子数组的和是否大于等于target。超时了就是了\n螺旋矩阵II\n给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\n\n示例:\n\n输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]\n\nclass Solution:    def generateMatrix(self, n: int) -&gt; List[List[int]]:        nums=[[0]*n for _ in range(n)] # 创建一个n*n的空列表        start_x,start_y = 0,0 #每一圈的起始位置，注意是每一圈的，因此转完一圈后起始位置的x、y都要加一 ,x表示行数，y表示列数        count = 1 #表示转到哪个数字        offset = 1 #偏移量，其实我觉得也是圈数        while n // 2 &gt; offset-1: #转一圈消耗两层啦            for j in range(start_y,n-offset):                nums[start_x][j] = count                count += 1            for i in range(start_x,n-offset):                nums[i][n-offset] = count                count += 1            for j in range(n-offset,start_y,-1):                nums[n-offset][j] = count                count += 1            for i in range(n-offset,start_x,-1):                nums[i][start_y] = count                count += 1            start_x += 1            start_y += 1            offset += 1        if n %2 == 1:            nums[n//2][n//2] = count        return nums\n这道题目的核心在处理边界问题，特别在顶点的取否上，这里我们采用左闭右开的方式，然后明白转一圈消耗两层，然后每一圈更新起始位置和偏移量。\n扩展题看了思路，但是我自己还没憋出来，等晚上再试试\n","categories":["算法学习——数组"],"tags":["代码随想录"]},{"title":"代码随想录day-4","url":"/2025/12/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day4/","content":"两两交换链表中的节点给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\nclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        dummy_head = ListNode(next=head)        current = dummy_head        while current.next and current.next.next: #注意先后顺序防止空指针异常            temp1 = current.next            temp2 = temp1.next.next            current.next = current.next.next            current.next.next = temp1            temp1.next = temp2            current = current.next.next        return dummy_head.next\n有点像昨天的反转列表，也采用了temp指针来保存数据，这道题核心在与两两交换前需要先找到前置节点，并且在循环判断的条件中要注意先后顺序防止空指针异常，当然指针确实有点绕，画个图还是很有帮助的。\n删除链表的倒数第N个节点给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。进阶：你能尝试使用一趟扫描实现吗？\n\n输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2 输出：[1,2,3,5]  示例 2：  输入：head &#x3D; [1], n &#x3D; 1 输出：[]  示例 3：  输入：head &#x3D; [1,2], n &#x3D; 1 输出：[1]\n\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        dummy_head = ListNode(next=head)        slow = dummy_head        fast = dummy_head        n += 1        while n and fast :            n -= 1            fast = fast.next         while fast:            fast = fast.next            slow = slow.next        slow.next = slow.next.next        return dummy_head.next\n这道题就是快慢指针，要想找到倒数第二个n，那就先让fast指针移动n+1步，然后再让slow指针和fast指针同时移动，直到fast指针指向None，这时候slow指针就指向了倒数第二个n前一个的位置。只有找到倒二的前一个位置，才能进行删除操作。\n链表相交给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。图示两个链表在节点 c1 开始相交：题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        count1 = 0        count2 = 0        cur1 = headA        cur2 = headB        while cur1 :            count1 += 1            cur1 = cur1.next        cur1 = headA        while cur2:            count2 += 1            cur2 = cur2.next        cur2 = headB        less = count1 - count2        if less &gt; 0:            for i in range(less):                cur1 = cur1.next            while cur1 != cur2:                cur1 = cur1.next                cur2 = cur2.next            return cur1        else :            less = -less            for i in range(less):                cur2 = cur2.next            while cur1 != cur2:                cur1 = cur1.next                cur2 = cur2.next            return cur2\n这是我一开始的想法，先找到两个链表的长度，然后让长的链表先移动长度差的步数，然后再让两个链表同时移动，直到找到相交的节点。实际上我找了非常有意思的解法，就是让两个链表同时移动，当其中一个链表到达末尾时，让它指向另一个链表的头节点，然后继续移动，当两个链表相交时，它们会在相交点相遇。\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        if not headA or not headB:            return None        cura = headA        curb = headB        while cura != curb:            cura = cura.next if cura else headB            curb = curb.next if curb else headA        return cura\n一种类似算梯形面积的方法，把短的和长的拼在一起，简单来说，就是我让两条链表同时移动，当其中一个链表到达末尾时，让它指向另一个链表的头节点，然后继续移动，当两个链表相交时，它们会在相交点相遇。（感觉这么说有点抽象），那就假设相同部分长度c，不相同部分长的a，短的b。第一条先走a+c，第二条走b+c，此时让一再走b，二再走a，这时候两条都是a+b+c，欸刚好到相同长度，并且接下来走的是相同的部分\n环形链表II题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        fast = head        slow = head        while fast and fast.next:            fast = fast.next.next            slow = slow.next            if slow == fast:                index = slow                index_s = head                while index != index_s:                    index = index.next                    index_s = index_s.next                return index        return None\n还是快慢指针，快指针每次移动两步，慢指针每次移动一步，当它们相遇时，说明链表有环。（因为不是环肯定不会相遇，快指针早就跑远了）这时候就是判断环的入口了，让一个指针从相遇点开始移动，另一个指针从链表头开始移动，当它们相遇时，就是环的入口。（数学：假设head到环入口是a，环入口到相遇点是b，相遇点到环入口是c，那么快指针走的距离是a+b+n（b+c），慢指针走的距离是a+b，因为快指针每次移动两步，慢指针每次移动一步，所以快指针走的距离是慢指针的两倍，即2(a+b) &#x3D; a+b+n（b+c），所以a &#x3D; （n-1）（b+c）+c，b+c就是一圈，转一圈也会回到起点，所以两个指针再次出发就会在入口相遇）但，实际上不需要index，在python里面直接让慢指针回到起点，然后快指针再相遇的位置继续走，速度和慢指针相同，当它们再次相遇时，就是环的入口。\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        fast = head        slow = head        while fast and fast.next:            fast = fast.next.next            slow = slow.next            if slow == fast:                fast = head                while slow != fast:                    slow = slow.next                    fast = fast.next                return fast        return None","categories":["算法学习——链表"],"tags":["代码随想录"]},{"title":"代码随想录-day11","url":"/2025/12/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day11/","content":"逆波兰表达式求值题目链接根据 逆波兰表示法，求表达式的值。有效的运算符包括 + ,  - ,  * ,  &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。说明：整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\n\n示例 1：输入: [“2”, “1”, “+”, “3”, “ * “]输出: 9解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9\n示例 2：输入: [“4”, “13”, “5”, “&#x2F;“, “+”]输出: 6解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6\n示例 3：输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “ * “, “&#x2F;“, “ * “, “17”, “+”, “5”, “+”]输出: 22解释:该算式转化为常见的中缀算术表达式为：\n\n((10 * (6 / ((9 + 3) * -11))) + 17) + 5       = ((10 * (6 / (12 * -11))) + 17) + 5       = ((10 * (6 / -132)) + 17) + 5     = ((10 * 0) + 17) + 5     = (0 + 17) + 5    = 17 + 5    = 22    \n\n逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。（是一种二叉数树的后续遍历） 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。\n\nclass Solution:    def evalRPN(self, tokens: List[str]) -&gt; int:        stack = []        for i in tokens:            if i == &quot;+&quot; or i == &#x27;-&#x27; or i == &#x27;*&#x27; or i == &quot;/&quot;:                a = stack.pop()                b = stack.pop()                if i == &quot;+&quot;:                    stack.append(a+b)                elif i == &quot;-&quot;:                    stack.append(b-a)                elif i == &quot;*&quot;:                    stack.append(a*b)                elif i == &quot;/&quot;:                    stack.append(int(b/a)) # 向零取整用int（b/a）直接截断小数部分            else :                stack.append(int(i))        return stack.pop()\n使用栈来保存数字，遇到运算符就弹出栈顶的两个数字进行计算，然后把结果压回栈中。最后栈中剩下的数字就是结果。\n滑动窗口最大值题目链接给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。\n\n示例 1：\n\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7\n\n\n示例 2：\n\n输入：nums = [1], k = 1输出：[1]\nfrom collections import dequeclass Queue :    def __init__ (self):        self.que = deque()        def pop(self,value): #这里啥时候队列可能为空呢        if self.que and value == self.que[0]:#队列不为空且遍历的值等于队口            self.que.popleft()   #弹的是最大（对头在左）    def push(self,value):        while self.que and value &gt; self.que[-1]:            self.que.pop()        self.que.append(value)    def get(self):        return self.que[0]class Solution:    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:        que = Queue()        result = []        for i in range(k):            que.push(nums[i])        result.append(que.get())        for i in range(k,len(nums)):            que.pop(nums[i-k]) #例如加入第四个元素前要移除第一个            que.push(nums[i])            result.append(que.get())        return result\n下面是ai的带注释的\nfrom collections import dequeclass MonotonicQueue:  # 改名：明确是单调递减队列，避免语义混淆    def __init__(self):        self.que = deque()  # 存储 nums 的元素（也可存索引，更灵活）        def remove_left(self, value):        &quot;&quot;&quot;        滑动窗口移动时，移除窗口左边界的元素（仅当该元素是队首时，因为队首是最大值）        此时队列可能为空：必须先判断 self.que 非空        &quot;&quot;&quot;        if self.que and value == self.que[0]:  # 队列非空 + 左边界元素是队首（最大值）            self.que.popleft()  # 弹出队首（移除窗口外的最大值）        def push(self, value):        &quot;&quot;&quot;        加入当前元素，维持队列单调递减：        移除队列中所有比当前元素小的元素（这些元素不可能成为后续窗口的最大值）        此时队列可能为空：空队列直接 append 即可        &quot;&quot;&quot;        while self.que and self.que[-1] &lt; value:  # 队列非空 + 队尾元素 &lt; 当前元素            self.que.pop()  # 移除队尾（从右弹出，deque.pop() 是O(1)）        self.que.append(value)  # 加入当前元素，队列仍保持递减        def get_max(self):        &quot;&quot;&quot;获取当前窗口最大值（队首），必须保证调用前队列非空&quot;&quot;&quot;        return self.que[0]class Solution:    def maxSlidingWindow(self, nums, k):        # 边界情况处理（避免队列空时调用 get_max）        if not nums or k == 0 or k &gt; len(nums):            return []                que = MonotonicQueue()        result = []                # 第一步：初始化第一个窗口（前 k 个元素）        for i in range(k):            que.push(nums[i])        # 第一个窗口的最大值加入结果（此时队列非空，因为 k&lt;=len(nums) 且 nums 非空）        result.append(que.get_max())                # 第二步：滑动窗口（从第 k 个元素开始，到最后一个元素）        for i in range(k, len(nums)):            # 1. 移除窗口左边界的元素（i-k 是当前窗口的左边界索引）            left_value = nums[i - k]  # 窗口要移除的左边界元素            que.remove_left(left_value)                        # 2. 加入当前窗口的右边界元素（第 i 个元素）            que.push(nums[i])                        # 3. 记录当前窗口的最大值（队列非空）            result.append(que.get_max())                return result# 测试案例if __name__ == &quot;__main__&quot;:    s = Solution()    print(s.maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3))  # 输出 [3,3,5,5,6,7]（正确）    print(s.maxSlidingWindow([], 3))  # 输出 []（边界处理）    print(s.maxSlidingWindow([1], 1))  # 输出 [1]（边界处理）    print(s.maxSlidingWindow([1,-1], 2))  # 输出 [1]（边界处理）\n这道题是用单调队列来解决的，单调队列是指队列中的元素是单调递增或递减的。那如何保证队列中的元素是单调递减的呢？当有新元素加入时，我们将队列中所有比新元素小的元素都弹出，直到队列为空或者队列尾部的元素大于等于新元素为止。这样就保证了队列中的元素是单调递减的。\n\n关于我在视频弹幕上遇到的一个情况5231，其实解决这个的方式是在push方法中加入一个判断，当队列非空且队尾元素小于等于新元素时，弹出队尾元素，直到队列为空或者队列尾部的元素大于等于新元素为止。（这样3进去的之前2就被弹出了）\n为啥要判断队列非空？初始阶段：刚实例化 Queue 时（init 后），self.que &#x3D; deque() 是空的，此时调用 pop&#x2F;get 都会操作空队列。窗口滑动时移除元素后：比如窗口内所有元素都被 pop 方法移除（例如滑动窗口移动时，队首元素是前一个窗口的最大值，被弹出后队列无其他元素）。nums 数组本身为空或 k&#x3D;0：当输入 nums &#x3D; [] 或 k&#x3D;0 时，循环不执行 push，队列始终为空。\n\n前 K 个高频元素题目链接\n\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n\n示例 1:\n\n输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2\n输出: [1,2]\n\n示例 2:\n\n输入: nums &#x3D; [1], k &#x3D; 1\n输出: [1]\n\n提示：\n\n你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。\n你的算法的时间复杂度必须优于 $O(n \\log n)$ , n 是数组的大小。\n题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。\n你可以按任意顺序返回答案。\n\nclass Solution:    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:        dir = &#123;&#125;        for i in range(len(nums)):            dir[nums[i]] = dir.get(nums[i],0) + 1 #key不存在就设为0，存在就加1        que = []        for key,value in dir.items():            heapq.heappush(que,(value,key)) #注意value在前，因为按照value排序的            if len(que) &gt; k:                heapq.heappop(que)        result = [0] * k        for i in range(k-1,-1,-1): #第一个-1取不到所以就是0开始            result[i] = heapq.heappop(que)[1]        return result\n使用哈希表统计每个元素的频率，然后使用小顶堆维护前 k 个高频元素。小顶堆的大小为 k，每次加入一个元素后，如果堆的大小超过 k，就弹出堆顶元素。解释一下堆，就是完全二叉树，每个节点的左右子树都是堆，且根节点是堆顶。小顶堆的性质是，堆顶元素是堆中最小的元素。大顶堆的性质是，堆顶元素是堆中最大的元素。\n","categories":["算法学习——栈和队列"],"tags":["代码随想录"]},{"title":"代码随想录-day3","url":"/2025/12/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day3/","content":"移除链表元素\n题意：删除链表中等于给定值 val 的所有节点。\n\n\n示例 1： 输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6 输出：[1,2,3,4,5]\n示例 2： 输入：head &#x3D; [], val &#x3D; 1 输出：[]\n示例 3： 输入：head &#x3D; [7,7,7,7], val &#x3D; 7 输出：[]\n\n解法一：虚拟头节点\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        dummy_head = ListNode(next = head)        cur_node = dummy_head        while cur_node.next:            if cur_node.next.val == val:                cur_node.next = cur_node.next.next            else :                cur_node = cur_node.next        return dummy_head.next #关于为啥要.next,因为这个节点是我们创建的虚拟的，它指向的才是头节点\n首先，在删除值为val的节点的时候我们要考虑头节点的情况，而且如果连续的多个节点等于val且在头节点的后面的时候，我们要用循环删去，总而言之，这种分类讨论的方法比较麻烦，为了解决这个问题我们可以采用虚拟头结点的方式。创建虚拟头节点dummy_head，指向头节点head。然后设置一个指针current，指向dummy_head。遍历链表，当current.next的值等于val时，删除current.next节点，否则current指针后移。（循环条件用current.next，到达尾端的时候指向None，循环结束）最后返回dummy_head.next，因为dummy_head本身是我们创造的虚拟的，而dummy_head.next才是真正的头节点。解法二：不使用虚拟头节点\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        while head and head.val == val :            head = head.next        current = head        while current and current.next:            while current.next and current.next.val == val:                current.next = current.next.next            current = current.next        return head\n我只说我最开始没考虑的情况，例如111123，假设val&#x3D;1，连续的1，当时我是用if的情况，条件满足头节点指向下一个，但是如果连续的val在头节点的后面，就会出错。后面1233244441111232，我又用if，还是没删干净，我粘一下我的错误的代码，大家以此为戒，也可以看看我的错误代码思考我的问题。\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        current = head        while current and current.next:            if current.val == val:                head = current.next            if current.next.val == val:                current.next = current.next.next            else :                current = current.next        return head     \n\n设计链表\n题意：  在链表类中实现这些功能：\n\n\nget(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\naddAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\naddAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\naddAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\ndeleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\n\nclass ListNode:    def __init__(self,val=0,next=None):        self.val = val        self.next = nextclass MyLinkedList:    def __init__(self):           self.dummy_node = ListNode()        self.size = 0    def get(self, index: int) -&gt; int:        if index &gt;= self.size or index &lt; 0:   #为啥不能取等，类似数组下标从零开始            return -1        current = self.dummy_node.next # 有效节点从虚拟节点下一个开始        for i in range(index):#这里循环用来找目标，链表的查找是要遍历的，不像数组用下标就行            current = current.next        return current.val    def addAtHead(self, val: int) -&gt; None:        self.dummy_node.next = ListNode(val,self.dummy_node.next) #从右往左，先创建新的节点，且新节点的下个节点指向原来虚拟头的next，然后再让虚拟头指向新节点        self.size += 1    def addAtTail(self, val: int) -&gt; None:        current = self.dummy_node        while current.next:            current = current.next        current.next = ListNode(val)        self.size += 1    def addAtIndex(self, index: int, val: int) -&gt; None:        if index &lt; 0 or index &gt; self.size:            return -1         current = self.dummy_node        for i in range(index):            current = current.next        current.next = ListNode(val,current.next)        self.size += 1    def deleteAtIndex(self, index: int) -&gt; None:        if index &lt; 0 or index &gt;= self.size:            return        current = self.dummy_node        for i in range(index):            current = current.next        current.next = current.next.next        self.size -= 1\n我做过卡码网的链表的基本操作，期末考完我把卡码网我做过的题也记录到这个blog里额，就是index合法性检查，然后增加删除的基本操作\n反转链表题意：反转一个单链表。\n\n示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL方法一：双指针法\n\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        pre = None        current = head        while current:            temp = current.next            current.next = pre            pre = current            current = temp        return pre\n通过设置当前指针，pre指针来实现，每次循环都让当前指针指向前一个节点，然后pre指针移动到当前指针，当前指针移动到下一个节点，直到当前指针为空，返回pre指针。但是只是这样会丢失current.next的节点，因此需要temp指针来暂存current.next的节点，然后让current指针指向前一个节点，pre指针移动到current指针，current指针移动到temp指针，直到current指针为空，返回pre指针。\n方法二：递归法\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        return self.reverse(head,None)        def reverse(self,current,pre) :        if current == None:            return pre        temp = current.next        current.next = pre        return self.reverse(temp,current)\n实话实话，让我再写一遍我写不出递归，我再捣鼓捣鼓吧，视频看懂了但又好像没看懂\n","categories":["算法学习——链表"],"tags":["代码随想录"]},{"title":"代码随想录-day6","url":"/2025/12/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day6/","content":"有效的字母异位词\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。-示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true-示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false说明: 你可以假设字符串只包含小写字母。\n\nclass Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        hash = [0] * 26        for i in s:            hash[ord(i) - ord(&#x27;a&#x27;)] += 1        for t_ in t:            hash[ord(t_) - ord(&#x27;a&#x27;)] -= 1        for h in hash:            if h != 0:                return False        return True\n这道题的思路是：用一个长度为26的数组来存储每个字母出现的次数，遍历字符串s时，对应字母的位置加1，遍历字符串t时，对应字母的位置减1。最后遍历数组，如果数组里面的元素都为0，说明两个字符串是字母异位词，返回True，否则返回False。讲一下我觉得比较有意思的地方就是这个下标转化的方式，通过减去a的ascll值得到一个在0-25之间的下标，对应数组的位置，这样就可以统计每个字母出现的次数。（有点像凯撒密码，也算是一种哈希函数的实现）\n两个数组的交集题意：给定两个数组，编写一个函数来计算它们的交集。说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。\nclass Solution:    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        hash_set = set()        hash_list = set()        for i in nums1:            hash_set.add(i)        for i in nums2:            if i in hash_set:                hash_list.add(i)        return list(hash_list)\n也是用哈希表来存储数组里面的元素，然后存放在集合里面，因为集合里面要求元素是唯一的，再把数组1里集合元素和数组2里元素进行对比，如果存在就放到另一个集合里面，最后返回集合转换为列表即可。\n快乐数\n编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。\n\n\n示例：输入：19输出：true解释：1^2 + 9^2 &#x3D; 828^2 + 2^2 &#x3D; 686^2 + 8^2 &#x3D; 1001^2 + 0^2 + 0^2 &#x3D; 1\n\nclass Solution:    def isHappy(self, n: int) -&gt; bool:        set_=set()        while True:            if n == 1:                return True            n = self.self_sum(n)            if n in set_:                return False            else :                set_.add(n)             def self_sum(self,n):           new_n = 0        while n :            n1 = n % 10            n = n // 10            new_n += n1 ** 2         return new_n\n这道题的思路是：用一个集合来存储每次计算得到的结果，如果结果重复出现，说明进入了循环，不是快乐数。如果结果为1，说明是快乐数。利用哈希表来存储每次计算的结果，一旦出现重复的结果，说明进入了循环，不是快乐数。\n两数之和\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n\n示例:给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1]\n\ndir=&#123;&#125;      for i in range(len(nums)): #遍历数组          if target-nums[i] not in dir: #如果目标值减去当前值不在字典中              dir[nums[i]] = i          else :              return [dir[target-nums[i]],i]\n这道题在我的第一篇blog有，感兴趣的可以去看看，这道题是哈希表里面map的应用\n","categories":["算法学习——哈希表"],"tags":["代码随想录"]},{"title":"代码随想录-day7","url":"/2025/12/23/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day7/","content":"四数相加II\n给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。\n\n\n例如:输入:A &#x3D; [ 1, 2]B &#x3D; [-2,-1]C &#x3D; [-1, 2]D &#x3D; [ 0, 2]输出:2解释:两个元组如下:(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0\n\nclass Solution:    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:        t_set = &#123;&#125;        count = 0        for i in nums1:            for j in nums2:                t_set[i+j] = t_set.get(i+j,0) + 1        for i in nums3:            for j in nums4:                if 0-(i+j) in t_set.keys():                    count += t_set[0-(i+j)]        return count\n这道题就是将四个数分成两组前两个数一组，并把他们的和作为key，出现的次数作为value，存到一个哈希表中。然后遍历后两个数的组合，判断0-(i+j)是否在哈希表中，如果在，就把出现的次数加到count中（注意加的是value的值不是一，原因是不用去重）。\n赎金信\n给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\n\n\n例如:输入: ransomNote &#x3D; “a”, magazine &#x3D; “b”输出: false输入: ransomNote &#x3D; “aa”, magazine &#x3D; “ab”输出: false输入: ransomNote &#x3D; “aa”, magazine &#x3D; “aab”输出: true\n\nclass Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        a_hash = [0] * 26        for i in magazine:            a_hash[ord(i)-ord(&#x27;a&#x27;)] += 1        for i in ransomNote:            if a_hash[ord(i)-ord(&#x27;a&#x27;)] == 0:                return False            else :                a_hash[ord(i)-ord(&#x27;a&#x27;)] -= 1        return True\n这道题就是用一个哈希表来记录 magazine 中的字符出现的次数，然后遍历 ransomNote 中的字符，判断是否在哈希表中，如果在，就把哈希表中对应的值减一。直到遇到了0，就说明 magazine 中的字符不能构成 ransomNote 中的字符，返回 False。跟昨天第一题很像\n三数之和\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。注意： 答案中不可以包含重复的三元组。\n\n\n示例：给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]\n\nclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        result = []        nums.sort()        for i in range(len(nums)):            if nums[i] &gt; 0 :                return result            if i &gt; 0 and nums[i] == nums[i-1]:                continue            left = i + 1            right = len(nums) - 1            while left &lt; right:                if nums[i] + nums[left] + nums[right] &gt; 0:                    right -= 1                elif nums[i] + nums[left] + nums[right] &lt; 0:                    left += 1                else:                    result.append([nums[i],nums[left],nums[right]])                    while left &lt; right and nums[left] == nums[left + 1]:                        left += 1                    while left &lt; right and right &lt; len(nums)-1 and nums[right] == nums[right - 1]:                        right -= 1                    right -= 1                    left += 1        return result\n用了双指针的思路首先先对数组排序，然后for循环用i作为第一个数，left作为第二个数，right作为第三个数，三个数求和判断是否等于0，如果等于0，就把这三个数加入到结果中。如果大于0，就把right减一，如果小于0，就把left加一。直到left大于等于right，就说明这个数组合完了，就可以继续下一个数了。注意点去重操作是i和i-1比较，left和left+1比较，right和right-1比较，为啥这样的，因为i是基准，如果i和i+1判断，把下一个i跳了，i就像边界一样，left就指不到被跳的i的那个位置了，比如-2 -1 -1 0 2，但是i继续加一以后，发现和之前的i一样，这个i就可去掉了，这里不会重复是上一组的i已经用过这个顺序了，例如-1 -1 0 0 1 2，然后left和right就是和自己的下一个数比较即可，而且不会遗漏，哪怕有连续的left挑掉，right也会移动过去，不像i是基准\n四数之和\n题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。\n\n\n示例： 给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]\n\nclass Solution:    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:        result = []        nums.sort()        for i in range(len(nums)):            if nums[i]&gt;0 and nums[i] &gt; target//4 :                break #这里不能return result            if i&gt;0 and nums[i] == nums[i-1]:                continue            for j in range(i+1,len(nums)):                if nums[i] + nums[j] &gt; target and target &gt; 0:                     break                if j &gt; i+1 and nums[j] == nums[j-1]:                    continue                left,right = j+1,len(nums)-1                while left &lt; right:                    sum_=nums[i]+nums[j]+nums[left]+nums[right]                    if sum_ == target:                        result.append([nums[i],nums[j],nums[left],nums[right]])                        while left &lt; right and nums[left] == nums[left+1]:                            left += 1                        while right &gt; left and nums[right] == nums[right-1]:                            right -= 1                        left += 1                        right -= 1                    elif sum_ &gt; target    :                        right -= 1                    else :                        left += 1        return result\n就是在i的基础上加了一个j也作为基准，然后在i和j的基础上用双指针的思路，left和right作为第三个数和第四个数，判断是否等于target，如果等于0，就把这四个数加入到结果中。我再思考一下\n","categories":["算法学习——哈希表"],"tags":["代码随想录"]},{"title":"代码随想录-day8","url":"/2025/12/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day8/","content":"反转字符串\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n\n\n示例 1：输入：[“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”]\n示例 2：输入：[“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”]\n\nclass Solution:    def reverseString(self, s: List[str]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify s in-place instead.        &quot;&quot;&quot;        j=len(s)-1        for i in range(len(s)//2):            s[i],s[j] = s[j],s[i]            j -= 1\n这道题的思路是用双指针的方式，分别指向头尾，然后交换位置，循环判断条件就到中间位置（比长度的一半小）。\n反转字符串IIleetcode链接\n\n给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n\n\n示例:输入: s &#x3D; “abcdefg”, k &#x3D; 2输出: “bacdfeg”\n\nclass Solution:    def reverseStr(self, s: str, k: int) -&gt; str:        def c_r(s_):            left,right = 0,len(s_)-1            while left &lt; right:                s_[left],s_[right]=s_[right],s_[left]                left += 1                right -= 1            return s_        i=0        s_list=list(s)        while i &lt; len(s):            s_list[i:i+k] = c_r(s_list[i:i+k])            i += 2 * k        return &quot;&quot;.join(s_list)\nclass Solution:    def reverseStr(self, s: str, k: int) -&gt; str:        s = list(s)        for i in range(0, len(s), 2*k):            s[i:i+k] = s[i:i+k][::-1]        return &#x27;&#x27;.join(s)\n这道题的主要特点是切片的方式是以2k为步长，每次取k个字符进行反转。并且python的切片操作是可以超出索引范围的，会自动截断为有效范围。（Python 切片的容错特性：无需判断剩余字符长度，i:i+k 自动截断为有效范围，让 “反转前 k 个 &#x2F; 反转全部剩余” 的要求自然满足），i相当于一个指针，每次移动2k个位置，只要能移动在下一次循环就进行切片。\n替换数字\n给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。\n\n\n例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。对于输入字符串 “a5b”，函数应该将其转换为 “anumberb”输入：一个字符串 s,s 仅包含小写字母和数字字符。输出：打印一个新的字符串，其中每个数字字符都被替换为了number样例输入：a1b2c3样例输出：anumberbnumbercnumber数据范围：1 &lt;&#x3D; s.length &lt; 10000。\n\nn = input()count_num = sum(1 for i in n if i.isdigit())count = count_num * 5 + len(n) #记得count_num是数字字符的个数，每个数字字符替换为number后会增加5个字符，所以是*5n_list = [&#x27;&#x27;] * counto_p = len(n)- 1n_p = count - 1while o_p &gt;= 0:    if n[o_p].isdigit():        n_list[n_p-5:n_p+1] = &quot;number&quot; #注意切片是位置到位置，不能直接[n_p-5:6]这种操作        n_p -= 6    else :        n_list[n_p]=n[o_p]        n_p -= 1    o_p -= 1print(&quot;&quot;.join(n_list))\n这道题还是用双指针的方式，一个指向原字符串的尾，一个指向新字符串的尾，根据是否为数字字符来判断是否需要替换。如果是c语言从后向前可以避免每次替换后需要移动后面的字符的问题。python因为字符串是不可变的，所以需要先将字符串转换为列表，修改后再转换为字符串。然后就是要两个指针一一对应，一个指向原字符串的当前字符，一个指向新字符串的当前位置。\n","categories":["算法学习——字符串"],"tags":["代码随想录"]},{"title":"代码随想录-day9","url":"/2025/12/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day9/","content":"翻转字符串里的单词\n给定一个字符串，逐个翻转字符串中的每个单词。\n\n\n示例 1：输入: “the sky is blue”输出: “blue is sky the”\n示例 2：输入: “  hello world!  “输出: “world! hello”解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n示例 3：输入: “a good   example”输出: “example good a”解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。方法一：split()分割加列表反转\n\nclass Solution:    def reverseWords(self, s: str) -&gt; str:        s_list = s.split()        s_list = s_list[::-1]        return &quot; &quot;.join(s_list)\n方法二：双指针法\nclass Solution:    def reverseWords(self, s: str) -&gt; str:        class Solution:    def reverseWords(self, s: str) -&gt; str:        s = s.split()        left,right = 0,len(s)-1        while left &lt; right:            s[left],s[right]=s[right],s[left]            left += 1            right -= 1        return &quot; &quot;.join(s)\n视频的方法今天有点来不及\n右旋字符串\n字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。输出：输出共一行，为进行了右旋转操作后的字符串。\n\n\n样例输入：2abcdefg样例输出：fgabcde\n\n数据范围：1 &lt;&#x3D; k &lt; 10000, 1 &lt;&#x3D; s.length &lt; 10000\nn=int(input())s=input()print(s[-n:]+s[:-n])\n额，今天考马原上午都在看马原，额，但是不得不说，python真的太刁了，字符串切片操作真的是太方便了，但是我还是要提醒一下，字符串是不可变的，所以切片操作不会改变原字符串，而是返回一个新的字符串。\n日记感觉马原要挂科。明明我背那么久了，结果全背错了，张冠李戴给我玩明白了，我服了。一想到考研要考政治我就绝望\n","categories":["算法学习——字符串"],"tags":["代码随想录"]}]