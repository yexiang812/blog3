[{"title":"2026的第一篇blog","url":"/2026/01/01/2026%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/","content":"新年快乐  今天是2026年的第一天，这一年里给自己几个目标吧：\n\n完成代码随想录打卡任务的所有题目\n每个月跑100km\n每天坚持背单词\n通过英语六级\n蓝桥杯获奖\n跟上项目组的节奏，明年的人工智能比赛能有好的成绩\n在kaggle上完成一个项目\n找个对象（可能？）\n希望看到这个blog的每一个人都能开开心心，如尝所愿！\n\n","tags":["杂谈"]},{"title":"LeetCode_1","url":"/2025/12/01/hello-world/","content":"  从这篇文章开始，我将会将我在算法练习中的所想和收获记录下来。\n1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。\n1.1 思路1  思路1是最简单的思路，就是遍历数组，对于每个元素，都去数组中查找是否有目标值减去当前值的元素。  时间复杂度为O(n^2)，空间复杂度为O(1)。  class Solution:  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:      for i in nums:          j = target - i          start_index = nums.index(i)          next_index = start_index + 1           nums_new = nums[next_index:]#对原数组进行切片，去掉当前元素之前的元素          if j in nums_new:              return [start_index,next_index+nums_new.index(j)]\n1.2 思路2(哈希表)  思路2是利用哈希表来解决问题。我们遍历数组，对于每个元素，都去哈希表中查找是否有目标值减去当前值的元素。  如果有，就返回当前元素的下标和哈希表中目标值减去当前值的元素的下标。  如果没有，就将当前元素和下标加入哈希表中。  时间复杂度为O(n)，空间复杂度为O(n)。用空间换时间  class Solution:  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:      dir=&#123;&#125;      for i in range(len(nums)): #遍历数组          if target-nums[i] not in dir: #如果目标值减去当前值不在字典中              dir[nums[i]] = i          else :              return [dir[target-nums[i]],i]\n9. 回文数  给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。  回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。  例如，121 是回文，而 123 不是。(负数不是回文数)\n9.1 思路1  思路1是将整数%10，得到最后一位数，然后将整数&#x2F;&#x2F;10，去掉最后一位数，重复这个过程，直到整数变成0。  每次得到的数都乘以10，最后得到的数就是整数的倒序。  时间复杂度为O(logn)，空间复杂度为O(1)。  if (x&lt;0):          return False      else :          a = x          num = 0          while(a!=0):              num =10 * num + a % 10              a = a // 10          if (x == num):              return True          else:              return False\n","categories":["算法学习——哈希"],"tags":["leetcode"]},{"title":"python_入门练习","url":"/2025/12/09/python-%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0/","content":"  不得不说我的代码能力太弱了，只能先从简单的开始了。\n1.A+B问题I题目描述\n\n你的任务是计算a+b。输入描述输入包含一系列的a和b对，通过空格隔开。一对a和b占一行。输出描述如对于输入中的第二对a和b，  在输出中它们的和应该也在第二行。输入示例1 2  3 4输出示例3  7\n\n我的解法while True:    try:        a,b = map(int,input().split())        print(a+b)    except:        break\n好吧我承认我的代码能力是极差的。第一个问题如何保证一直接受用户输入，首先就要用一个一直循环的while语句，直到没有输入后跳出循环。可以用if判断啥时候输入为空，也可以用try except保证输入的合法性。然后就是map函数，这个函数的核心是对序列里面的每一个元素批量应用同一个处理规则，这里是将输入的字符串转换为整数。这里的.split()函数是将输入的字符串按照空格隔开，返回一个列表。哦，补充一下input函数输入的内容是字符串。\n2.A+B问题II题目描述\n\n计算a+b，但输入方式有所改变。输入描述第一行是一个整数N，表示后面会有N行a和b，通过空格隔开。输出描述对于输入的每对a和b，你需要在相应的行输出a、b的和。  如第二对a和b，对应的和也输出在第二行。输入示例2  2 4  9 21输出示例6  30提示信息注意，测试数据不仅仅一组。也就是说，会持续输入N以及后面的a和b\n\n解法1这道题和上一道题的区别在于，上一道题是一直接受用户输入，直到没有输入为止。这道题是先接受一个整数N，然后接受N行a和b，输出N行a+b。而且分组输入导致每一块都有组数N，就不能像上一道题一样无脑接收输入了。补充知识：.strip()函数是去掉字符串首尾的空格，包括换行符、制表符等。\nwhile True:    try:        N = int(input().strip())        for i in range(N):            a,b = map(int,input().split())            print(a+b)    except:        break\n解法2import sysfor line in sys.stdin:    N=int(line.strip())    for i in range(N):        a,b=map(int,sys.stdin.readline().strip().split())        print(a+b)\n\n导入sys模块后，通过for line in sys.stdin启动外层循环——这个循环的作用是逐个读取输入中“每组数据的开头行（即N所在的行）”。每次外层循环执行时：\n\n\n首先处理当前读取到的line：这行内容是当前组的分组信息（整数N），通过int(line.strip())转成整数后，明确“这一组需要处理N对a和b”。\n\n接着启动内层循环for _ in range(N)：这个循环的作用是主动读取当前组内的N行a和b数据。每次内层循环会通过sys.stdin.readline()读取一行新的输入（这行是a和b，用空格分隔），经过strip()清理空白、split()拆分、map(int, ...)转整数后，得到a和b的值，计算并输出它们的和。内层循环会严格执行N次，确保当前组的N对a和b全部被处理。\n\n内层循环结束后，外层循环才会继续执行：此时外层循环会自动读取下一行输入，而这一行恰好是“下一组数据的N”（因为内层循环已经主动读完了上一组的N行a和b，不会让外层循环误读这些行）。\n\n\n整个过程中，外层循环负责“按组拆分输入”（找到每一组的N），内层循环负责“按组内数量处理数据”（读完N对a和b），两层循环分工配合，既不会漏读数据，也不会错把a和b的行当成N处理，最终完美实现“持续处理多组N及对应a+b”的题目要求。sys.stdin():内置的标准输入流对象，用于从控制台或其他输入源读取数据。sys.stdin.readline()：读取输入的一行,从stdin中读取一行数据,包括换行符。\n","tags":["入门算法"]},{"title":"week1_复盘","url":"/2025/12/21/week1-%E5%A4%8D%E7%9B%98/","content":"week1_复盘day1第一道题 第一道题是二分搜索，几个关键点是，二分搜索得是有序数组，通过数学的二分法实现。代码细节，一个是左闭右开，目标值小于mid，调整右指针到mid，注意右边是开的，因此mid&#x3D;right，如果目标值大于mid，调整左指针到mid+1，注意左边是闭的，因此left&#x3D;mid+1。当然如果是左闭右闭，代码细节就会有一些变化，目标值小于mid，调整右指针到mid-1，注意右边是闭的，因此right&#x3D;mid-1，如果目标值大于mid，调整左指针到mid+1，注意左边是闭的，因此left&#x3D;mid+1。\n第二题是移除元素，设置快慢指针，快指针用来遍历数组，慢指针用来指向新数组的位置。然后和目标值比较，如果不相等，慢指针加一，然后赋值为快指针的值。如果相等，快指针加一，继续遍历。\n第三题然后是有序数组的平方，因为数组是有序的，所以平方后的最大值一定在数组的两端，所以可以设置双指针，一个指向数组的头，一个指向数组的尾。然后比较两个指针指向的元素的平方，将较大的那个放到新数组的末尾，然后对应的指针向中间移动。当然也可以用python的推导式加上sort函数，实现有序数组的平方。\nday2第一题长度最小的子数组这道题是滑动窗口，设置左右指针，初始都指向数组的头，然后右指针向右移动，直到窗口内的元素和大于等于目标值，然后记录下窗口的长度，然后左指针向右移动，直到窗口内的元素和小于目标值，然后继续移动右指针满足条件后继续记录下窗口的长度，直到右指针到达数组的尾。\n第二题螺旋矩阵II这道题的关键是边界判定，四条边都用左闭右开的方式，最后一个点给下一条边，还有是循环条件是n&#x2F;&#x2F;2，转一圈掉两层，然后是偏移量，最开始是0 0 然后每次循环偏移量加一，然后是n为奇数时，最后一个点单独处理等于n。\n你看看果然不能托现在才想起来附加题没做\nday3第一题 移除链表元素这道题主要是考虑头节点被删除的情况，所以可以设置一个虚拟头节点，指向头节点，然后设置一个指针指向虚拟头节点，然后遍历链表，如果下一个节点的值等于目标值，就删除下一个节点，否则指针后移。最后返回虚拟头节点的下一个节点。\n第二题 设计链表这道题主要是考虑链表的基本操作，比如添加节点，删除节点，获取节点的值等。主要是index的处理，哦对链表没法用下标的方式来访问节点，所以需要遍历链表来找到目标节点。\n第三题 反转链表这道题是双指针一个cur节点加一个pre节点以及临时节点temp，初始时pre指向None，cur指向头节点，然后遍历链表，每次将cur的next指向pre，然后pre移动到cur，cur移动到temp，最后返回pre。然后递归，还是不会写\nday4第一题 两两交换链表中的节点这道题主要是找到前置节点，然后交换两个节点，然后移动指针到下一个位置，注意判断条件的先后，防止空指针异常。设置了两个temp节点，一个用来保存下一个节点，一个用来保存下下下一个节点。可以用画图帮助理解。\n第二题 删除链表的倒数第N个节点这道题是快慢指针，先让快指针移动n+1步，然后快慢指针同时移动，直到快指针到达链表尾部，然后删除慢指针的下一个节点。\n第三题 链表相交这道题是双指针法，设置两个指针分别指向两个链表的头节点，然后同时移动两个指针，当一个指针到达链表尾部时，移动到另一个链表的头节点，继续移动，直到两个指针相等或者都为None。这样就能找到链表的交点。然后我自己想的是用梯形的感觉。\n第四题 环形链表II这道题是快慢指针，快指针每次移动两步，慢指针每次移动一步，直到快指针追上慢指针，或者快指针到达链表尾部。如果追上了，说明链表有环，然后快指针从链表头开始，慢指针从相遇点开始，每次移动一步，直到再次相遇，相遇点就是环的入口。如果快指针到达链表尾部，说明链表没有环。然后在起点的相遇的位置两个快慢节点改成速度相同，再次相遇的位置就是环的入口。\n我自己的杂谈这一周要准备期末考，又要坚持学代码，压力挺大的其实。虽然感觉期末成绩对我没啥用，但是总害怕大家觉得我天天不在宿舍一定天天读书的那种压力，尽管生活没有那么多的观众就是了，但是这种自我暗示也算是让我进行期末准备了，其实我还有很多自己想做的是，想看鱼书，想学数学，当然ctf也是落下好久了，确实娱乐比以前少了，但是效率总是很低，欸，可能也是天赋的缘故吧。其实我本来有很多想说的，但是这个blog公开了，也是怪不好意思的，那就这样吧\n","categories":["杂谈"],"tags":["杂谈——复盘"]},{"title":"一些关于编程语言的知识","url":"/2025/12/26/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%9F%A5%E8%AF%86/","content":"以下内容来自ai（豆包），为了我自己的学习，我把它记录下来。\nSTL一、STL 到底是什么？STL 是 Standard Template Library（标准模板库） 的缩写，是 C++ 标准库的核心组成部分，本质是一套 通用、可复用的模板类&#x2F;函数库。\n简单说：\n\n它是 C++ 官方提供的“工具集”，不用自己写基础数据结构（比如栈、队列、数组、链表）和算法（比如排序、查找、遍历），直接调用就行；\n核心优势是 模板化（跨数据类型通用，比如一个 vector 既可以存 int，也能存 string）、高效（底层用最优算法实现）、标准化（所有符合 C++ 标准的编译器都支持，比如 GCC、Clang、MSVC）。\n\nSTL 主要包含 6 大组件，日常开发最常用的是前 4 个：\n\n\n\n组件\n作用\n\n\n\n容器（Container）\n存储数据的“容器”（比如 vector 动态数组、list 链表、stack 栈、map 字典）\n\n\n算法（Algorithm）\n操作容器数据的算法（比如 sort 排序、find 查找、reverse 反转）\n\n\n迭代器（Iterator）\n连接容器和算法的“桥梁”（类似指针，遍历容器数据）\n\n\n适配器（Adaptor）\n对现有容器“包装改造”，改变其接口（比如 stack 就是对其他容器的适配器）\n\n\n函数对象（Functor）\n行为类似函数的对象（配合算法使用，比如自定义排序规则）\n\n\n分配器（Allocator）\n负责容器的内存分配&#x2F;释放（底层细节，用户一般不用关心）\n\n\n二、STL 中 stack 的实现原理stack（栈）的核心特性是 LIFO（后进先出）：只能从“栈顶”插入（push）、删除（pop）和访问（top）数据，不能随机访问中间元素。\n关键结论：stack 不是独立的容器，而是「容器适配器」STL 的 stack 本身不存储数据，它是对一个 底层容器（Underlying Container） 进行“包装”，限制了其接口（只暴露栈需要的 push/pop/top 等），底层数据的存储、内存管理全靠这个“被包装的容器”。\n1. 默认底层容器是什么？C++ 标准规定，stack 的 默认底层容器是 deque（双端队列）。选择 deque 的原因很简单：deque 支持 两端高效插入&#x2F;删除（时间复杂度 O(1)），而栈只需要操作“一端”（栈顶），用 deque 刚好匹配，且 deque 没有 vector 扩容时的拷贝开销，效率更高。\n2. 可以自定义底层容器吗？可以！stack 是模板类，允许用户指定底层容器，只要这个容器支持以下 3 个核心操作即可：\n\npush_back()：在尾部插入元素（栈顶对应容器尾部）；\npop_back()：删除尾部元素；\nback()：访问尾部元素。\n\n满足条件的容器有 vector、list、deque，比如：\n#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;list&gt;// 1. 默认底层容器：dequestd::stack&lt;int&gt; st1;// 2. 自定义底层容器为 vectorstd::stack&lt;int, std::vector&lt;int&gt;&gt; st2;// 3. 自定义底层容器为 liststd::stack&lt;int, std::list&lt;int&gt;&gt; st3;\n\n3. stack 的核心接口实现（伪代码）stack 的接口非常简单，本质就是“转发”到底层容器的对应操作，伪代码能直观体现：\ntemplate &lt;typename T, typename Container = std::deque&lt;T&gt;&gt;class stack &#123;private:    Container c;  // 底层容器（被包装的对象）public:    // 入栈：调用底层容器的 push_back()    void push(const T&amp; x) &#123; c.push_back(x); &#125;        // 出栈：调用底层容器的 pop_back()（注意：不返回元素）    void pop() &#123; c.pop_back(); &#125;        // 访问栈顶：调用底层容器的 back()    T&amp; top() &#123; return c.back(); &#125;        // 栈是否为空：调用底层容器的 empty()    bool empty() const &#123; return c.empty(); &#125;        // 栈的大小：调用底层容器的 size()    size_t size() const &#123; return c.size(); &#125;&#125;;\n\n从伪代码能看出来：stack 没有自己的“数据存储逻辑”，所有操作都依赖底层容器，它只做了一件事——隐藏底层容器的其他接口（比如 vector 的 operator[] 随机访问），只暴露栈需要的 LIFO 接口。\n三、补充：stack 为什么不叫“容器”而叫“适配器”？\n容器（比如 vector、list）：是“原始存储容器”，支持完整的元素访问&#x2F;操作（比如 vector 可以随机访问、list 可以双向遍历）；\n适配器（比如 stack、queue）：是“包装器”，不提供原始存储，而是基于现有容器，通过“限制接口”来实现特定的数据结构行为（栈的 LIFO、队列的 FIFO）。\n\n简单说：适配器是“改造现有容器”，而容器是“原生存储数据”。\n总结\nSTL 是 C++ 标准库的核心，是通用的模板工具集，包含容器、算法、迭代器等组件；\nSTL 的 stack 是 容器适配器，底层不存数据，依赖其他容器实现；\n默认底层容器是 deque，也可指定 vector 或 list（需支持 push_back/pop_back/back）；\nstack 的所有接口（push/pop/top）都是转发到底层容器的对应操作，核心是实现 LIFO 特性。\n\ndequefrom collections import deque 是 Python 中导入内置容器类 deque 的标准语法，以下是关于 deque 的详细解析、用法和场景说明：\n一、核心基础：什么是 deque？\n全称：Double-Ended Queue（双端队列）\n本质：Python 标准库 collections 模块提供的高效双端队列数据结构，支持两端（队首&#x2F;队尾）的快速插入和删除操作。\n与 list 的区别：\nlist 基于数组实现，队首插入&#x2F;删除（如 list.insert(0, x)、list.pop(0)）时间复杂度为 O(n)（需移动所有元素）；\ndeque 基于双向链表（或类似优化结构）实现，两端操作时间复杂度均为 O(1)，效率远超 list。\n\n\n\n二、基本用法（需先导入 deque）1. 初始化 dequefrom collections import deque# 1. 空队列dq = deque()# 2. 从可迭代对象（列表、字符串、元组等）初始化dq1 = deque([1, 2, 3])       # deque([1, 2, 3])dq2 = deque(&quot;abc&quot;)           # deque([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])dq3 = deque((4, 5, 6), maxlen=5)  # 限制最大长度为5（超出会自动丢弃另一端元素）\n\n2. 两端插入操作（核心优势）\n\n\n方法\n功能\n示例\n结果\n\n\n\nappend(x)\n队尾添加元素 x\ndq1.append(4)\ndeque([1, 2, 3, 4])\n\n\nappendleft(x)\n队首添加元素 x\ndq1.appendleft(0)\ndeque([0, 1, 2, 3, 4])\n\n\nextend(iterable)\n队尾批量添加可迭代对象\ndq1.extend([5, 6])\ndeque([0,1,2,3,4,5,6])\n\n\nextendleft(iterable)\n队首批量添加（逆序插入）\ndq1.extendleft([-2, -1])\ndeque([-1, -2, 0,1,2,3,4,5,6])\n\n\n\n注意 extendleft：会将可迭代对象的元素逆序插入队首（如 extendleft([a,b]) 等价于 appendleft(b) 后 appendleft(a)）。\n\n3. 两端删除操作\n\n\n方法\n功能\n示例\n结果\n\n\n\npop()\n队尾删除并返回元素\ndq1.pop()\n返回 6，队列变为 deque([-1,-2,0,1,2,3,4,5])\n\n\npopleft()\n队首删除并返回元素\ndq1.popleft()\n返回 -1，队列变为 deque([-2,0,1,2,3,4,5])\n\n\nclear()\n清空队列\ndq1.clear()\ndeque([])\n\n\n4. 其他常用方法\nmaxlen 属性：获取队列最大长度（初始化时指定，不可修改）\ndq = deque([1,2,3], maxlen=3)print(dq.maxlen)  # 3dq.append(4)      # 超出maxlen，队首元素1被自动丢弃print(dq)         # deque([2, 3, 4])\n\nrotate(n)：队列旋转（默认 n=1，队尾元素移到队首；n=-1 则队首元素移到队尾）\ndq = deque([1,2,3,4])dq.rotate(1)   # 右旋转1位：4→队首print(dq)      # deque([4, 1, 2, 3])dq.rotate(-2)  # 左旋转2位：4、1→队尾print(dq)      # deque([2, 3, 4, 1])\n\ncount(x)：统计元素 x 的出现次数\ndeque([1,2,2,3]).count(2)  # 2\n\nremove(x)：删除第一个出现的元素 x（不存在则抛 ValueError）\ndq = deque([1,2,3,2])dq.remove(2)print(dq)  # deque([1, 3, 2])\n\n三、典型应用场景1. 实现队列（FIFO：先进先出）from collections import dequequeue = deque()# 入队（队尾添加）queue.append(&quot;a&quot;)queue.append(&quot;b&quot;)# 出队（队首删除）print(queue.popleft())  # &quot;a&quot;print(queue.popleft())  # &quot;b&quot;\n\n2. 实现栈（LIFO：后进先出）（直接用 append() 和 pop()，等价于栈的压栈&#x2F;出栈）\nstack = deque()stack.append(1)stack.append(2)print(stack.pop())  # 2（后进先出）print(stack.pop())  # 1\n\n3. 滑动窗口问题（利用 maxlen 自动维护窗口大小）例如：求数组中每个位置的前 k 个元素的平均值\nfrom collections import dequedef sliding_average(nums, k):    dq = deque(maxlen=k)    averages = []    for num in nums:        dq.append(num)        if len(dq) == k:  # 窗口满了才计算平均值            averages.append(sum(dq)/k)    return averagesprint(sliding_average([1,2,3,4,5,6], 3))  # [2.0, 3.0, 4.0, 5.0]\n\n4. 广度优先搜索（BFS）BFS 算法的核心是用队列存储待访问节点，deque 的 popleft() 效率远高于 list.pop(0)：\nfrom collections import dequedef bfs(root):    if not root:        return []    queue = deque([root])    result = []    while queue:        node = queue.popleft()  # 队首出队        result.append(node.val)        # 子节点入队        if node.left:            queue.append(node.left)        if node.right:            queue.append(node.right)    return result\n\n\n四、总结\ndeque 是 Python 中高效双端队列，核心优势是两端插入&#x2F;删除 O(1) 时间复杂度；\n功能覆盖队列、栈、滑动窗口等场景，比 list 更适合频繁操作两端的场景；\n需通过 from collections import deque 导入，支持 maxlen、rotate 等实用功能，是 Python 开发中高频使用的容器类。\n\n","tags":["笔记"]},{"title":"代码随想录-day10","url":"/2025/12/26/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day10/","content":"用栈实现队列题目链接\n\n使用栈实现队列的下列操作：push(x) – 将一个元素放入队列的尾部。pop() – 从队列首部移除元素。peek() – 返回队列首部的元素。empty() – 返回队列是否为空。示例:\n\nMyQueue queue = new MyQueue();queue.push(1);queue.push(2);queue.peek();  // 返回 1queue.pop();   // 返回 1queue.empty(); // 返回 false\n说明:你只能使用标准的栈操作 – 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\nclass MyQueue:    def __init__(self):        self.stack_in = []        self.stack_out = []    def push(self, x: int) -&gt; None:        self.stack_in.append(x)    def pop(self) -&gt; int:        if self.empty():            return None        if self.stack_out :            return self.stack_out.pop()        else:            for i in range(len(self.stack_in)):                self.stack_out.append(self.stack_in.pop())            return self.stack_out.pop()    def peek(self) -&gt; int:        result = self.pop()        self.stack_out.append(result)        return result    def empty(self) -&gt; bool:        return not  (self.stack_in or self.stack_out)\n由于栈是先进后出，队列是先进先出，所以需要两个栈来实现队列的功能。实现负负得正。然后查看头节点可以用出队列的代码复用，得到后记得再入栈\n用队列实现栈题目链接\n\n使用队列实现栈的下列操作：\n\n\npush(x) – 元素 x 入栈\npop() – 移除栈顶元素\ntop() – 获取栈顶元素\nempty() – 返回栈是否为空\n\n注意:\n\n你只能使用队列的基本操作– 也就是 push to back, peek&#x2F;pop from front, size, 和 is empty 这些操作是合法的。\n你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。\n\nclass MyStack:    def __init__(self):        self.deq = deque()    def push(self, x: int) -&gt; None:        self.deq.append(x)    def pop(self) -&gt; int:        if self.empty():            return None        else :            for i in range(len(self.deq)-1):                self.deq.append(self.deq.popleft())            return self.deq.popleft()    def top(self) -&gt; int:        if self.empty():            return None        return self.deq[-1]    def empty(self) -&gt; bool:        return not self.deq\n使用一个队列来实现栈的功能。入栈直接入队列即可。出栈需要将队列中的元素依次出队列再入队列，直到只剩下最后一个元素，这个元素就是栈顶元素，直接出队列即可。\n有效的括号题目链接\n\n给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。有效字符串需满足：\n\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n每个右括号都有一个对应的相同类型的左括号。示例 1：\n\n输入：s = &quot;()&quot;输出：true\n示例 2：\n输入：s = &quot;()[]&#123;&#125;&quot;输出：true\n示例 3：\n输入：s = &quot;(]&quot;输出：false\nclass Solution:    def isValid(self, s: str) -&gt; bool:        stack = []        if len(s) %2 == 1:            return False        for i in s:            if i == &quot;(&quot;:                stack.append(&quot;)&quot;)            elif i == &quot;[&quot;:                stack.append(&quot;]&quot;)            elif i == &#x27;&#123;&#x27;:                stack.append(&quot;&#125;&quot;)            elif not stack or i != stack[-1]:                return False            else:                stack.pop()        return True  if not stack else False\n这道题是用栈来实现的，遍历字符串，遇到左括号就入栈，遇到右括号就出栈，判断是否匹配。提前为空、栈顶元素不匹配、字符串遍历完成后栈不为空，这三种情况都是无效的。我遇到了一个很有意思的错误elif not stack or i != stack.pop():原先我的代码是这样的，但是报错确实在十六行告诉我空栈不能pop，我原本以为是因为python的判断条件是左右会都判断，哪怕左边已经为真了，但其实问题是我在判断栈顶元素是否匹配时，直接用了pop方法，提前把最后一元素出栈这会导致栈为空后续没法pop。\n删除字符串中的所有相邻重复项题目链接\n\n给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n\n\n示例：\n\n输入：”abbaca”\n\n输出：”ca”\n\n解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。提示：\n\n1 &lt;&#x3D; S.length &lt;&#x3D; 20000\n\nS 仅由小写英文字母组成。\n\n\nclass Solution:    def removeDuplicates(self, s: str) -&gt; str:        stack = []        for i in s:            if stack and i == stack[-1]:                stack.pop()            else :                stack.append(i)        return &quot;&quot;.join(stack)\n这道题是用栈来实现的，遍历字符串，遇到字符就入栈，遇到和栈顶元素相同的字符就出栈。最后栈中的元素就是没有重复项的字符串。\n","categories":["算法学习——栈和队列"],"tags":["代码随想录"]},{"title":"python中我遇到的语法问题","url":"/2025/12/23/python%E4%B8%AD%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98/","content":"字典1.python中查询key是否存在直接用key in dict，并且时间复杂度为O(1)因为字典底层是哈希表实现的。2.字典的get方法可以设置默认值，比如dict.get(key, default_value)，如果key不存在则返回default_value。3.分别使用dict.keys()、dict.values()、dict.items()可以获取字典的所有key、value、key-value对。注意，这三个都是方法，括号别忘了写。\n数组1.空数组的创建可以用[]或者list()，比如a = []或者a = list()。如果设置初值可以用a = [0]*n或者a = list([0]*n)。2. 数组的切片可以用array[start:end:step]，比如a[1:3]表示获取数组a中索引从1到2的元素（不包括3），a[::-1]表示将数组a反转。3. Python 中切片赋值时，右侧的赋值对象必须是可迭代对象，字符串 “number” 会被自动拆解为单个字符的可迭代序列，再逐个赋值到切片对应的位置(res[new_index-5:new_index+1] &#x3D; “number”)\n排序\npython中排序可以用list.sort()或者sorted(list)，前者是在原数组上排序，后者是返回一个新的排序后的数组。\n排序默认是升序排序，如果要降序排序可以用list.sort(reverse=True)或者sorted(list, reverse=True)。\n\nPython 列表自定义排序笔记（按多维度排序）一、核心功能对包含二元组（或长度≥2的列表）的列表，实现「多维度自定义排序」，典型场景：先按第一个元素降序，再按第二个元素升序（可灵活扩展规则）。\n二、关键技术点1. 排序函数选择\n\n\n函数\n特点\n用法示例\n\n\n\nlist.sort()\n原地排序（修改原列表）\npeople.sort(key=lambda x: (...))\n\n\nsorted()\n非原地排序（返回新列表）\nnew_people = sorted(people, key=...)\n\n\n\n注：两者的 key 参数用法完全一致，仅是否修改原列表的区别。\n\n2. 排序依据：key=lambda x: (维度1, 维度2, ...)\nlambda x：匿名函数，x 代表列表中的单个元素（此处为二元组&#x2F;列表，如 (3, &#39;a&#39;)）。\n返回元组 (维度1, 维度2)：排序时优先按「维度1」比较，维度1相等时再按「维度2」比较，依次类推。\n\n维度排序规则控制\n\n\n需求\n实现方式\n示例（针对 x[0]）\n\n\n\n升序（默认）\n直接使用元素本身\nx[0]\n\n\n降序\n对数值类型加负号 -x[n]\n-x[0]\n\n\n字符串降序\n用 x[n][::-1] 反转字符串（或结合 reverse 参数）\nx[1][::-1]\n\n\n三、典型案例（先按第1元素降序，再按第2元素升序）1. 代码实现# 原始列表（元素为二元组/列表均可）people = [(2, &#x27;Alice&#x27;), (3, &#x27;Bob&#x27;), (2, &#x27;Charlie&#x27;), (3, &#x27;Anna&#x27;), (1, &#x27;David&#x27;)]# 原地排序（修改原列表）people.sort(key=lambda x: (-x[0], x[1]))# 非原地排序（返回新列表，不修改原列表）# sorted_people = sorted(people, key=lambda x: (-x[0], x[1]))print(people)# 输出：[(3, &#x27;Anna&#x27;), (3, &#x27;Bob&#x27;), (2, &#x27;Alice&#x27;), (2, &#x27;Charlie&#x27;), (1, &#x27;David&#x27;)]\n\n2. 排序逻辑拆解\n第一维度：-x[0]（按第一个元素降序）\n原始 x[0] 数值：2、3、2、3、1 → 加负号后：-2、-3、-2、-3、-1\n按负号后数值升序排列 → 对应原始数值降序：3 &gt; 2 &gt; 1\n\n\n第二维度：x[1]（按第二个元素升序）\n当 x[0] 相等时（如两个 3、两个 2），按字符串自然顺序升序：&#39;Anna&#39; &lt; &#39;Bob&#39;、&#39;Alice&#39; &lt; &#39;Charlie&#39;\n\n\n\n四、灵活扩展（修改排序规则）1. 场景1：先按第1元素升序，再按第2元素降序# 数值降序用 -x[1]，字符串降序用 x[1][::-1]people.sort(key=lambda x: (x[0], x[1][::-1]))# 示例输出：[(1, &#x27;David&#x27;), (2, &#x27;Charlie&#x27;), (2, &#x27;Alice&#x27;), (3, &#x27;Bob&#x27;), (3, &#x27;Anna&#x27;)]\n\n2. 场景2：三维度排序（先按第1元素降序，第2升序，第3降序）# 原始列表（三元组）data = [(5, &#x27;a&#x27;, 10), (3, &#x27;b&#x27;, 20), (5, &#x27;a&#x27;, 15), (3, &#x27;a&#x27;, 5)]data.sort(key=lambda x: (-x[0], x[1], -x[2]))print(data)# 输出：[(5, &#x27;a&#x27;, 15), (5, &#x27;a&#x27;, 10), (3, &#x27;a&#x27;, 5), (3, &#x27;b&#x27;, 20)]\n\n五、注意事项\n元素结构要求：列表中的元素必须是「可通过索引取值的类型」（元组、列表），且索引对应的元素支持比较（如数值、字符串）。\n字符串排序：字符串按 ASCII 码自然排序（大写字母 &lt; 小写字母，如 &#39;A&#39; &lt; &#39;a&#39;），降序需用反转或自定义逻辑。\n非数值类型降序：若第二维度是字符串，想实现降序，除了 x[1][::-1]，也可单独对该维度处理（如结合 sorted 的 reverse=True，但需注意多维度优先级）。\n\n字符串\npython中字符串是不可变的，所以如果要修改字符串中的某个字符，只能先将字符串转换为列表，修改后再转换为字符串。\n字符串的拼接可以用+号，也可以用join()方法，比如&#39;a&#39;+&#39;b&#39;或者&#39;a&#39;.join([&#39;b&#39;, &#39;c&#39;])。\n判断字符串是否只包含数字可以用str.isdigit()方法，比如&#39;123&#39;.isdigit()返回True，&#39;123a&#39;.isdigit()返回False。\n\n表达式\n生成器表达式是一种简洁的创建生成器的方式，它的语法和列表推导式类似，但是用圆括号括起来，比如(x for x in range(5))。\n\n队列\ndeque（发音：deck），它是 Python 标准库 collections 中的「双端队列」，实现了在队列两端高效插入和删除元素的功能。相比于列表，deque 在头尾操作时具有更好的性能表现，时间复杂度为 O(1)。\n\ndeque 提供了 append()、appendleft()、pop()、popleft() 等方法，分别用于在队列的右端插入元素、左端插入元素、从右端删除元素、从左端删除元素。\n\ndeque 支持索引访问，比如deque[0]表示获取队列的队头元素，deque[-1]表示获取队列的队尾元素。\n\n\n无穷大和无穷小\npython中无穷大可以用float(&#39;inf&#39;)表示，无穷小可以用float(&#39;-inf&#39;)表示。\n可以用math.isinf()方法判断一个数是否为无穷大，比如math.isinf(float(&#39;inf&#39;))返回True，math.isinf(10)返回False。\n\n面向对象的编程\n在类的方法中，第一个参数通常是self，表示类的实例本身，可以通过self访问类的属性和方法。\n在一个函数中用self.变量可以使这个变量成为类的属性，从而可以在类的其他方法中使用。\n\n逆向遍历\n逆向遍历可以用for i in range(len(strn)-1, -1, -1):实现，比如for i in range(len(&#39;hello&#39;)-1, -1, -1):会遍历&#39;hello&#39;中的每个字符。\n逆向遍历可以用在需要从后往前处理字符串或列表的场景，比如判断回文数、反转字符串等。但是i-&gt;i+1并非向左，实际上只是先取i&#x3D;len(strn)-1，再取i&#x3D;len(strn)-2，以此类推。（下标仍是向右变大的）\n\n","tags":["笔记"]},{"title":"代码随想录-day13","url":"/2025/12/29/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day13/","content":"树的基本知识这个部分我暂时先空着，明天要考计算机组成原理与系统结构。\n树的遍历（前中后序）二叉树的前序遍历二叉树的中序遍历二叉树的后序遍历给你二叉树的根节点 root ，返回它节点值的 前序、中序、后序 遍历。\n树的遍历（前中后序）-递归# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        def dfs(node):            if node == None:                return            res.append(node.val)            dfs(node.left)            dfs(node.right)        dfs(root)        return res\n这个是前序\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        def dfs(node):            if node == None:                return            dfs(node.left)            res.append(node.val)            dfs(node.right)        dfs(root)        return res\n这个是中序\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        def dfs(node):            if node is None:                return             dfs(node.left)            dfs(node.right)            res.append(node.val)        dfs(root)        return res\n这个是后序\n树的遍历（前中后序）-迭代# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        if not root:            return []        result = []        stack = [root]        while stack:            node = stack.pop()            result.append(node.val)            if node.right:                stack.append(node.right)            if node.left:                stack.append(node.left)        return result  \n这是前序的迭代\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        if not root:            return []        res = []        stack = [root]        while stack:            node = stack.pop()            res.append(node.val)            if node.left:                stack.append(node.left)            if node.right:                stack.append(node.right)        return res[::-1]\n这是后序的迭代 \n二叉树的层序遍历102. 二叉树的层序遍历\n\n给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\n\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:        if not root :            return []        result = []        que = collections.deque([root])        while que:            in_ = []            for i in range(len(que)):                cur = que.popleft()                in_.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                        que.append(cur.right)            result.append(in_)        return result\n这是二叉树的层序遍历代码，使用队列实现。每一层记录个数，然后遍历这个个数，将当前层的节点值加入到结果中，并且将当前层的子节点加入到队列中，在下一次遍历的时候，就可以遍历到下一层的节点了。\n二叉树的层序遍历 II107. 二叉树的层序遍历 II\n\n给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def levelOrderBottom(self, root: Optional[TreeNode]) -&gt; List[List[int]]:        if not root:            return []        result = []        que = collections.deque([root])        while que:            in_ = []            for i in range(len(que)):                cur = que.popleft()                in_.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)            result.append(in_)        return result[::-1]\n这是二叉树的层序遍历 II 代码，和层序遍历的代码只有一行不同，就是在返回结果的时候，将结果反转一下即可。(就多了个反转)\n二叉树的右视图199. 二叉树的右视图\n\n给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:        if not root:            return []        result=[]        que = collections.deque([root])        while que:            n=len(que)            for i in range(n):                cur = que.popleft()                if i == n-1:                    result.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)        return result\n就是在每一层遍历的时候，只记录当前层的最后一个节点，将其加入到结果中即可。\n二叉树的层平均值637. 二叉树的层平均值\n\n给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。\n\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def averageOfLevels(self, root: Optional[TreeNode]) -&gt; List[float]:        if not root:            return []        result = []        que = collections.deque([root])        while que:            n=len(que)            in_ = 0            for i in range(n):                cur = que.popleft()                in_ += cur.val                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)            result.append(in_/n)        return result\n就是在每一层遍历的时候，记录当前层的节点值的和，然后除以当前层的节点个数，即可得到当前层的平均值。暂时到这里，明天开始就没课了，确实一旦松懈了一点就很麻烦了\n","categories":["算法学习——树"],"tags":["代码随想录"]},{"title":"代码随想录_day1","url":"/2025/12/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day1/","content":"可恶，今天有点拖拖拉拉的，博客只能水一点了\n二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n示例 1: 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2:\n\n 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间\nright=len(nums)        left=0        while left &lt; right:            middle = (left + right) // 2            if target &lt; nums[middle]:                right = middle            elif target &gt; nums[middle]:                left  = middle + 1            else :                return middle        return -1\n二分查找有点类似数学的二分法，来简化查找的次数，一个是左闭右闭，right就是指向真实的下标，然后更新的左右都不取到中间值，另一个是左闭右开，right指向数组的数量（实际加一），更新的右边都取到中间值。\n移除数组给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。\n\n示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n你不需要考虑数组中超出新长度后面的元素。\nclass Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        length=len(nums)        i = 0        while i &lt; length:            if nums[i]  == val:                for j in range(i,length-1):                    nums[j]=nums[j+1]                length -= 1            else:                i += 1        return length\n这个是暴力解法，双层循环\nslow = 0        for fast in range(len(nums)):            if  nums[fast] != val:                nums[slow]=nums[fast]                slow += 1        return slow\n这个是快慢指针讲一下思路，简单来说就是，设置两个指针，快的指针用来遍历原来的数组，慢的就用来表示新的数组的下标，然后比较快指针对应的和val一不一样，留下不一样的，一样的就跳过，最后返回慢指针的下标就是新数组的长度\n有序数组的平方给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n示例 1： 输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]\n\n 示例 2： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]\nclass Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        s1 = 0        k= s2 = len(nums)-1        nums_list=[0]*len(nums)        while s1 &lt;= s2:            if nums[s1]**2 &gt; nums[s2]**2:                nums_list[k] = nums[s1]**2                s1 += 1            else :                nums_list[k] = nums[s2]**2                 s2 -= 1            k -= 1        return nums_list\n这个是双指针的方法，设置两个指针，一个指向数组的头，一个指向数组的尾，然后比较两个指针指向的元素的平方，把大的那个放到新数组的最后面，然后相应的指针向中间移动，最后返回新数组\nreturn sorted(x*x for x in nums)\n无需多言，排序加推导式\n来不及了，要回宿舍了，下次不能拖拖拉拉了\n","categories":["算法学习——数组"],"tags":["代码随想录"]},{"title":"代码随想录-day14","url":"/2025/12/31/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day14/","content":"翻转二叉树翻转二叉树给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n翻转二叉树-递归class Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        def dfs(root):            if not root:                return None            root.left,root.right = root.right,root.left            dfs(root.left)            dfs(root.right)        dfs(root)        return root\n就是在前序遍历前交换左右子树\n对称二叉树对称二叉树给你一个二叉树的根节点 root ， 检查它是否轴对称。\n对称二叉树-递归class Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:        if not root:            return True        return self.compare(root.left,root.right)            def compare(self,left,right):        if left != None and right == None:            return False        elif left == None and right != None:            return False        elif left == None and right == None:            return True        elif left.val != right.val:            return False        outside = self.compare(left.left,right.right)        inside = self.compare(left.right,right.left)        return inside and outside\n在后续遍历的基础上，判断以 left 为根的子树和以 right 为根的子树，是否互为镜像，为了让两棵子树互为镜像，必须满足以下三个条件：它们的根节点值必须相同。\n\nleft 子树的左孩子，必须和 right 子树的右孩子互为镜像。\nleft 子树的右孩子，必须和 right 子树的左孩子互为镜像。\n\n二叉树的最大深度二叉树的最大深度给你一个二叉树的根节点 root ，返回它的 最大深度 。\n二叉树的最大深度-递归class Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        return self.getdeepth(root)    def getdeepth(self,node):        if not node:            return 0        leftdeepth = self.getdeepth(node.left)        rightdeepth = self.getdeepth(node.right)        deepth = max(leftdeepth,rightdeepth) + 1        return deepth \n首先区分高度和深度\n\n高度：指的是从根节点到叶子节点的最长路径上的节点数。\n深度：指的是从根节点到当前节点的路径上的节点数。所以这里可以用根节点的高度来表示二叉树的最大深度，而求根节点的高度可以用后序遍历。并且初始深度为0，当前节点的深度，等于其左右子树中较深的那一个的深度，再加上当前节点自己这一层\n\n二叉树的最小深度二叉树的最小深度给你一个二叉树的根节点 root ，返回它的 最小深度 。\n二叉树的最小深度-递归class Solution:    def minDepth(self, root: Optional[TreeNode]) -&gt; int:        return self.getdep(root)    def getdep(self,node):        if not node:            return 0        leftdpt = self.getdep(node.left)        rightdpt = self.getdep(node.right)        if leftdpt == 0 and rightdpt:            return 1 + rightdpt        if leftdpt and rightdpt == 0:            return 1 + leftdpt        return min(rightdpt,leftdpt)+1\n这里和最大深度的区别在于，当一个节点只有左子树或右子树时，最小深度是右子树或左子树的深度加1。因此要判断一下左右子树是否为空，为空则返回另一个子树的深度加1。然后将max替换为min即可。\n","categories":["算法学习——树"],"tags":["代码随想录"]},{"title":"代码随想录-day15","url":"/2026/01/01/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day15/","content":"平衡二叉树平衡二叉树给你一个二叉树的根节点 root ，判断它是否是平衡二叉树。\n平衡二叉树-递归class Solution:    def isBalanced(self, root: Optional[TreeNode]) -&gt; bool:        if self.get_h(root) == -1:            return False        else:            return True    def get_h(self,node):        if not node:            return 0        left_h = self.get_h(node.left)        if left_h == -1:            return -1        elif (right_h := self.get_h(node.right)) == -1: #海象运算符            return -1        elif abs(left_h - right_h)&gt;1:            return -1        else:            return max(left_h,right_h)+1\n通过后序遍历的方式计算每个节点的高度，并判断其左右子树的高度差是否超过1，若超过则返回-1表示不平衡，否则返回节点的高度。其中可以用海象运算符（:&#x3D;）来简化代码，避免重复计算。\n二叉树的所有路径二叉树的所有路径给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。\n二叉树的所有路径-递归class Solution:    def dfs(self,cur,path,result):        path.append(cur.val)        if not cur.left and not cur.right:            result.append(&quot;-&gt;&quot;.join(map(str,path)))            return        if cur.left:            self.dfs(cur.left,path,result)            path.pop()        if cur.right:            self.dfs(cur.right,path,result)            path.pop()    def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]:        result = []        if not root:            return result        path = []        self.dfs(root,path,result)        return result\n因为是从根节点出发查找路径，很容易想到用前序遍历的方式来实现。在递归中其实是包含了回溯的过程，每次递归结束后，都需要将当前节点从路径中弹出，以确保路径的正确性。\n左叶子之和左叶子之和给你二叉树的根节点 root ，返回所有左叶子节点的和。\n左叶子之和-递归class Solution:    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -&gt; int:        if not root :            return 0        if not root.left and not root.right:            return 0        leftnum = self.sumOfLeftLeaves(root.left)        if root.left and not root.left.left and not root.left.right:            leftnum = root.left.val        rightnum = self.sumOfLeftLeaves(root.right)        sum_val = leftnum + rightnum        return sum_val\n采用后序遍历的方式，先计算左子树的左叶子节点之和，再计算右子树的左叶子节点之和，最后将它们相加即可。判断当前节点的左子节点是否为左叶子节点（即左子节点没有左右子节点），若为左叶子节点，则将其值加入左子树的左叶子节点之和中。\n完全二叉树的节点个数完全二叉树的节点个数给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。\n完全二叉树的节点个数-递归class Solution:    def countNodes(self, root: Optional[TreeNode]) -&gt; int:        if not root:            return 0        left = root.left        right= root.right        ld = 0        rd = 0        while left:            left = left.left            ld += 1        while right:            right = right.right            rd += 1        if ld==rd:            return 2**(ld+1)-1        leftnum = self.countNodes(root.left)        rightnum = self.countNodes(root.right)        result = leftnum + rightnum + 1        return result\n通过计算左子树和右子树的深度，判断当前节点是否为满二叉树的根节点。如果是，则直接计算节点数（2^（ld+1）-1）；否则递归计算左右子树的节点数并相加。这个方法其实是找满二叉树的根节点，满二叉树的节点数为2^（ld+1）-1。从而减少时间复杂度。也可以用普通后序遍历的方式来实现，但是时间复杂度会高一些。\n","categories":["算法学习——树"],"tags":["代码随想录"]},{"title":"代码随想录-day17","url":"/2026/01/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day17/","content":"找二叉树的左下角的值513. 找树左下角的值\n\n给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。假设二叉树中至少有一个节点。\n\n找二叉树的左下角的值-递归# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def findBottomLeftValue(self, root: Optional[TreeNode]) -&gt; int:        self.max_ = float(&#x27;-inf&#x27;)        self.result = []        self.dfs(root,0)        return self.result    def dfs(self,node,depth):        if not node.left and not node.right:            if depth &gt; self.max_:                self.max_ = depth                self.result = node.val            return         if node.left:            depth += 1            self.dfs(node.left,depth)            depth -= 1        if node.right:            depth += 1            self.dfs(node.right,depth)            depth -= 1\n递归法，并且结合了回溯的思想。这里递归三部曲：\n\n确定递归函数的参数和返回值（node,depth）\n确定递归的终止条件（到达叶子节点）\n确定单层递归的逻辑（更新最大深度和结果值，递归左右子树）我原本一直在想为啥–完不会回去循环，因为递归是一种自顶向下的过程，每次递归调用都进入到下一层，而不是回到上一层。（栈？）\n\n路径总和112. 路径总和\n\n给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。叶子节点 是指没有子节点的节点。\n\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; bool:        if not root:            return False        return self.dfs(root,targetSum-root.val)    def dfs(self,node,targetSum):        if not node.left and not node.right and targetSum == 0:            return True        if not node.left and not node.right and targetSum != 0:            return False        if node.left:            targetSum -= node.left.val            if self.dfs(node.left,targetSum):                return True            targetSum += node.left.val        if node.right:            targetSum -= node.right.val            if self.dfs(node.right,targetSum):                return True            targetSum += node.right.val        return False\n递归法，回溯，判断是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和。这里递归三部曲：\n\n确定递归函数的参数和返回值（node,targetSum）（bool,并且一直向上返回）\n确定递归的终止条件（到达叶子节点）(目标和为0则返回True，否则返回False)\n确定单层递归的逻辑（判断是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和）\n\n路径总和-路径113. 路径总和 II\n\n给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点 是指没有子节点的节点。\n\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; List[List[int]]:        self.result = []        self.path = []        if not root:            return self.result        self.path.append(root.val)        self.dfs(root,targetSum-root.val)        return self.result    def dfs(self,node,targetSum):        if not node.left and not node.right and targetSum == 0:            self.result.append(self.path[:])            return         if not node.left and not node.right:            return         if node.left:            self.path.append(node.left.val)            targetSum -= node.left.val            self.dfs(node.left,targetSum)            targetSum += node.left.val            self.path.pop()         if node.right:            self.path.append(node.right.val)            targetSum -= node.right.val            self.dfs(node.right,targetSum)            targetSum += node.right.val            self.path.pop()        return \n递归法，回溯，判断是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和。这里递归三部曲：\n\n确定递归函数的参数和返回值（node,targetSum）\n确定递归的终止条件（到达叶子节点）\n确定单层递归的逻辑（判断是否存在根节点到叶子节点的路径，路径上所有节点值相加等于目标和）\n如果存在左子树，递归左子树，路径上添加左子节点值，目标和减去左子节点值。\n如果存在右子树，递归右子树，路径上添加右子节点值，目标和减去右子节点值。\n如果到达叶子节点且目标和为0，将当前路径添加到结果中。\n如果到达叶子节点且目标和不为0，返回False。\n\n\n\n\n\n这里我遇到了一个有意思的问题self.result.append(self.path[:])我写成了self.result.append(self.path)，然后path只有一个返回值,如果是self.result.append(self.path[])则直接报错，为啥呢\n\nself.result.append(self.path) (错误)这是添加引用。self.result 里保存的是指向self.path的指针。后续对 self.path 的任何修改（比如 pop()）都会影响到 self.result 里的内容。\nself.result.append(self.path[]) (完全错误)只写了方括号，但没有告诉 Python 你要索引哪个位置，或者要切片哪个范围。这就像你对别人说 “请把书从书架上拿下来”，但没说拿哪一本，对方无法执行你的指令。\nself.result.append(self.path[:]) (正确)这会创建一个 self.path 的副本，然后将这个副本添加到 self.result 中。这个副本是一个独立的新列表，它的内容在被添加时就固定了。后续对 self.path 的回溯修改（pop()）不会影响到已经存入 self.result 的这个副本。我的理解是，[:]是拷贝一份，然后修改原列表不会影响到拷贝的列表，而直接self.path是(类似指针)会修改原列表，会影响到self.result里的内容。\n\n从中序和后序遍历构造二叉树106. 从中序与后序遍历序列构造二叉树\n\n给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。\n\nclass Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:        if not postorder:            return None        root_val = postorder[-1]        root = TreeNode(root_val)        mid_index = inorder.index(root_val)        left_in = inorder[:mid_index]        right_in = inorder[mid_index+1:]        left_po = postorder[:mid_index]        right_po = postorder[mid_index:-1]        root.left = self.buildTree(left_in,left_po)        root.right = self.buildTree(right_in,right_po)        return root\nright_po &#x3D; postorder[mid_index:-1]最开始我记错了，写成right_po &#x3D; postorder[mid_index:-2]，因为我以为-1是最后也取，但实际上-1表示最后一个不取，因为后序遍历的最后一个是根节点。\n从前序和中序遍历构造二叉树105. 从前序与中序遍历序列构造二叉树\n\n给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造并返回这颗 二叉树 。\n\nclass Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:        if not preorder:            return None        root_val = preorder[0]        root = TreeNode(root_val)        mid_index = inorder.index(root_val)        left_in = inorder[:mid_index]         right_in = inorder[mid_index+1:]        left_pr = preorder[1:mid_index+1]        right_pr = preorder[mid_index+1:]        root.left = self.buildTree(left_pr,left_in)        root.right = self.buildTree(right_pr,right_in)        return root\n暂时先这样，吃个饭去\n","categories":["算法学习——树"],"tags":["代码随想录"]},{"title":"代码随想录-day2","url":"/2025/12/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day2/","content":"长度最小的子数组\n给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n\n示例：\n\n输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n\n提示：\n\n1 &lt;&#x3D; target &lt;&#x3D; 10^9\n1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5\n1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5\n\nclass Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        length = len(nums)        left = 0        right = 0  #左闭右闭        min_nums = length + 1        sum_n = 0        while right &lt; length:            sum_n += nums[right]            while sum_n &gt;= target:                min_nums = min(right - left + 1,min_nums)                sum_n -= nums[left]                left += 1            right += 1        return min_nums if min_nums != length + 1 else 0\n这道题可以用滑动窗口的方式来实现设置两个指针left和right，分别指向子数组的左右边界。初始的时候设置两个指针都是0，即指向数组的第一个元素。然后通过移动右指针来扩大子数组的大小直到子数组的和大于等于target。这个时候我们得到的就是在起点为0条件下获得的最小子数组长度。因此我们可以移动左指针的位置，一方面可以缩小子数组的长度，另一方面也是调整子数组的起点。如果减去初始的左指针指向的元素后子数组的和仍然大于等于target，那么我们就可以继续移动左指针，直到子数组的和小于target，当然在这过程中要更新最小数组长度。如果子数组的和小于target了那我们就继续移动右指针，扩大子数组的大小。重复这个过程到循环结束\nclass Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        length = len(nums)        min_nums = length + 1        for i in range(length):            sum_n = 0            for j in range(i,length):                sum_n += nums[j]                if sum_n &gt;= target:                    min_nums = min(min_nums,j-i+1)                    break        return min_nums if min_nums != length + 1 else 0\n暴力解法就是用两个for循环，一个for循环遍历数组的每个元素，另一个for循环遍历从当前元素开始的所有子数组，计算子数组的和是否大于等于target。超时了就是了\n螺旋矩阵II\n给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\n\n示例:\n\n输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]\n\nclass Solution:    def generateMatrix(self, n: int) -&gt; List[List[int]]:        nums=[[0]*n for _ in range(n)] # 创建一个n*n的空列表        start_x,start_y = 0,0 #每一圈的起始位置，注意是每一圈的，因此转完一圈后起始位置的x、y都要加一 ,x表示行数，y表示列数        count = 1 #表示转到哪个数字        offset = 1 #偏移量，其实我觉得也是圈数        while n // 2 &gt; offset-1: #转一圈消耗两层啦            for j in range(start_y,n-offset):                nums[start_x][j] = count                count += 1            for i in range(start_x,n-offset):                nums[i][n-offset] = count                count += 1            for j in range(n-offset,start_y,-1):                nums[n-offset][j] = count                count += 1            for i in range(n-offset,start_x,-1):                nums[i][start_y] = count                count += 1            start_x += 1            start_y += 1            offset += 1        if n %2 == 1:            nums[n//2][n//2] = count        return nums\n这道题目的核心在处理边界问题，特别在顶点的取否上，这里我们采用左闭右开的方式，然后明白转一圈消耗两层，然后每一圈更新起始位置和偏移量。\n扩展题看了思路，但是我自己还没憋出来，等晚上再试试\n","categories":["算法学习——数组"],"tags":["代码随想录"]},{"title":"代码随想录-day20","url":"/2026/01/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day20/","content":"二叉搜索树的最小绝对差530. 二叉搜索树的最小绝对差\n\n给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。\n\nclass Solution:    def __init__(self):        self.result = float(&quot;inf&quot;)        self.pre = None    def dfs(self,cur):        if cur is None:            return         self.dfs(cur.left)        if self.pre is not None:            self.result = min(self.result,cur.val-self.pre.val)        self.pre = cur        self.dfs(cur.right)    def getMinimumDifference(self, root: Optional[TreeNode]) -&gt; int:        self.dfs(root)        return self.result\n采用递归（中序遍历）加双指针的方法，遍历二叉搜索树，记录前一个节点，每次遍历到当前节点时，计算当前节点和前一个节点的差值，取最小值即可。\n二叉搜索树中的众数501. 二叉搜索树中的众数\n\n给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。如果树中有不止一个众数，可以按 任意顺序 返回。假定 BST 满足如下定义：结点左子树中所含节点的值 小于等于 当前节点的值结点右子树中所含节点的值 大于等于 当前节点的值左子树和右子树都是二叉搜索树\n\n递归（中序遍历）+ 哈希表 + 双指针class Solution:    def __init__(self):        self.count = 1        self.pre = None        self.result = &#123;&#125;         return     def dfs(self,cur):        if cur is None:            return         self.dfs(cur.left)        if self.pre is not None:            if self.pre.val == cur.val:                self.count += 1            else:                self.count = 1        self.result[cur.val] = self.count        self.pre = cur        self.dfs(cur.right)    def findMode(self, root: Optional[TreeNode]) -&gt; List[int]:        if not root:            return []        self.dfs(root)        target_count = max(self.result.values())        num = [k for k,v in self.result.items() if v == target_count]        return num\n这是我没看视频前做的，额，最开始我想的是，相等就count+1，然后用flag来区分到底是哪个节点重复，额，然后写着写着就成了哈希表，然后感觉flag用cur.val替代更好\n双指针+数组+递归（中序遍历）class Solution:    def __init__(self):        self.Maxc = 0        self.count = 1        self.pre = None        self.result = []        return     def dfs(self,cur):        if cur is None:            return         self.dfs(cur.left)        if self.pre is None:            self.count = 1        elif self.pre.val == cur.val:            self.count += 1        else:            self.count = 1        self.pre = cur        if self.count ==self. Maxc:            self.result.append(cur.val)        if self.count &gt; self.Maxc:            self.Maxc = self.count            self.result = [cur.val]        self.dfs(cur.right)        return     def findMode(self, root: Optional[TreeNode]) -&gt; List[int]:        if not root:            return []        self.dfs(root)        return self.result\n\n二叉树的最近公共祖先236. 二叉树的最近公共祖先\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\nclass Solution:    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        if root == q or root ==p or root == None:            return root        left_ = self.lowestCommonAncestor(root.left,p,q)        right_ = self.lowestCommonAncestor(root.right,p,q)        if left_ and right_:            return root        elif left_ and not right_:            return left_        elif not left_ and right_:            return right_        else:            return None\n在递归中包含回溯的思想，这里的特例包括：\n\n根节点是p或q\np或q在根节点的左子树或右子树中递归三部曲：\n确定递归函数的参数和返回值（root,p,q）\n确定终止条件（root &#x3D;&#x3D; p or root &#x3D;&#x3D; q or root &#x3D;&#x3D; None）\n确定单层递归的逻辑（左子树和右子树的遍历）\n\n","categories":["算法学习——树"],"tags":["代码随想录"]},{"title":"代码随想录-day18","url":"/2026/01/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day18/","content":"最大二叉树654. 最大二叉树\n\n给定一个不含重复元素的整数数组 nums 。 你需要从 nums 中找出最大的数，将其作为二叉树的根节点，然后递归地构建左子树和右子树。左子树的构建过程是从数组中 最大值左边 的 子数组中 构建出最大二叉树 。右子树的构建过程是从数组中 最大值右边 的 子数组中 构建出最大二叉树 。\n\nclass Solution:    def constructMaximumBinaryTree(self, nums: List[int]) -&gt; Optional[TreeNode]:        if len(nums) == 1:     #只有一个点就创建以这个为点的树            return TreeNode(nums[0])        node = TreeNode(0) #创建节点设置值为零        max_n = 0        index_n = 0        for i in range(len(nums)):            if nums[i] &gt; max_n:                max_n =nums[i]                index_n = i        node.val = max_n        if index_n &gt; 0:            left_num = nums[0:index_n]            node.left = self.constructMaximumBinaryTree(left_num)        if index_n &lt; len(nums)-1:            right_num = nums[index_n+1:]            node.right = self.constructMaximumBinaryTree(right_num)        return node\n递归法，递归三部曲：\n\n确定递归函数的参数和返回值（nums）\n确定递归的终止条件（数组长度为1）\n确定单层递归的逻辑（找到最大值和索引，创建节点，递归左子树和右子树）\n\n合并二叉树617. 合并二叉树\n\n给你两棵二叉树： root1 和 root2 。想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。\n\nclass Solution:    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if root1 == None:            return root2        if root2 == None:            return root1        root1.val += root2.val        root1.left = self.mergeTrees(root1.left,root2.left)        root1.right = self.mergeTrees(root1.right,root2.right)        return root1\n递归法，递归三部曲：\n\n确定递归函数的参数和返回值（root1,root2）\n确定递归的终止条件（root1为空返回root2，root2为空返回root1）(包含都为空的情况)\n确定单层递归的逻辑（将root2的值加到root1上，递归左子树和右子树）\n\n搜索二叉树递归法700. 二叉搜索树中的搜索\n\n给定二叉搜索树（BST）的根节点 root 和一个整数值 val。你需要在 BST 中找到节点值等于 val 的节点。返回以该节点为根的子树。如果节点不存在，则返回 null 。\n\nclass Solution:    def searchBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:        if not root or root.val == val:            return root        if val &lt; root.val:            return self.searchBST(root.left,val)        if val &gt; root.val:            return self.searchBST(root.right,val)\n递归法，递归三部曲：\n\n确定递归函数的参数和返回值（root,val）(注意题目要求的返回值是节点（值为val的节点）)\n确定递归的终止条件（root为空返回None，root值等于val返回root）\n确定单层递归的逻辑（如果val小于root值，递归左子树，否则递归右子树）\n\n迭代法class Solution:    def searchBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:        while root:            if val &lt; root.val:                root=root.left            elif val &gt; root.val:                root = root.right            else :                return root        return None\n迭代法，循环遍历二叉搜索树，找到值为val的节点，返回该节点。如果遍历完整个树都没有找到，返回None。\n验证二叉搜索树98. 验证二叉搜索树\n\n给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。有效 二叉搜索树定义如下：节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。\n\nclass Solution:    def __init__(self):        self.pre = None    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:                if root is None:            return True        left = self.isValidBST(root.left)        if  self.pre is not None and self.pre.val &gt;= root.val:            return False        self.pre = root        right = self.isValidBST(root.right)        return left and right\n递归法，递归三部曲：\n\n确定递归函数的参数和返回值（root）(注意题目要求的返回值是布尔值)\n确定递归的终止条件（root为空返回True）\n确定单层递归的逻辑（中序遍历，判断当前节点是否大于前一个节点，递归左子树和右子树）在这道题我遇到了个很有意思的错误，就是我把self.pre &#x3D; None放在isValidBST里面，欸，产生了一直返回True的情况，按照以前ai教我的，把这个放在里面按道理是防止污染，是好的，我仔细思考了一下，因为在这道题pre是不可以被重新初始化的，放在isValidBST里面会导致每次递归都重新初始化pre，所以会一直返回True。所以再__init__里面创建一次最好\n\n","categories":["算法学习——树"],"tags":["代码随想录"]},{"title":"代码随想录-day21","url":"/2026/01/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day21/","content":"二叉搜索树的最近公共祖先235. 二叉搜索树的最近公共祖先\n\n给定一个二叉搜索树, \n\n递归class Solution:    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        if not root:            return None        if root.val &gt; p.val and root.val &gt; q.val:            left = self.lowestCommonAncestor(root.left,p,q)            return left         if root.val &lt; p.val and root.val &lt; q.val:            right = self.lowestCommonAncestor(root.right,p,q)            return right        return root\n只要val在p和q之间，那么root就是最近公共祖先\n迭代class Solution:    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        while root:            if root.val &gt; p.val and root.val &gt; q.val:                root = root.left            elif root.val &lt; p.val and root.val &lt; q.val:                root = root.right                else:                return root        return None\n\n二叉搜索树中的插入操作701. 二叉搜索树中的插入操作\n\n给定二叉搜索树（BST）的根节点 root 和一个整数值 val ，\n\nclass Solution:    def insertIntoBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:        if not root:            return TreeNode(val)        if root.val &gt; val:            root.left = self.insertIntoBST(root.left,val)        else:            root.right = self.insertIntoBST(root.right,val)        return root\n方法二\nclass Solution:    def insertIntoBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:        if not root or root.val == val:            return TreeNode(val)        if val &lt; root.val:            if not root.left :                root.left = TreeNode(val)            else:                self.insertIntoBST(root.left,val)        if val &gt; root.val:            if not root.right:                root.right = TreeNode(val)            else:                self.insertIntoBST(root.right,val)        return root\n\n删除二叉搜索树中的节点450. 删除二叉搜索树中的节点\n\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\nclass Solution:    def deleteNode(self, root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:        if not root:            return root        if root.val == key:            if not root.left and not root.right:                return None            elif not root.left:                return root.right            elif not root.right:                return root.left            else :                cur = root.right                while cur.left:                    cur = cur.left                cur.left = root.left                return root.right        if root.val &gt; key:            root.left= self.deleteNode(root.left,key)        if root.val &lt; key:            root.right= self.deleteNode(root.right,key)        return root\n当找到要删除的节点时，分四种情况讨论：\n\n该节点没有子节点，直接删除，返回 None。\n该节点只有右子节点，返回右子节点，替代该节点。\n该节点只有左子节点，返回左子节点，替代该节点。\n该节点有左右子节点，将左子树挂到右子树的最左节点的左子树上，返回右子节点，替代该节点。挺难的\n\n","categories":["算法学习——树"],"tags":["代码随想录"]},{"title":"代码随想录-day22","url":"/2026/01/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day22/","content":"修剪二叉搜索树669. 修剪二叉搜索树\n\n给你二叉搜索树的根节点 root ，同时给定最小边界 low 和最大边界 high 。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 之间。修剪树 不应该 改变保留在树中的节点的相对结构（即，如果没有被移除，原有的父子关系都应当保留）。可以证明，存在 唯一的答案 。\n\nclass Solution:    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -&gt; Optional[TreeNode]:        if not root:            return None        elif root.val &lt; low:            right = self.trimBST(root.right,low,high)            return right        elif root.val &gt; high:            left = self.trimBST(root.left,low,high)            return left        root.left = self.trimBST(root.left,low,high)        root.right = self.trimBST(root.right,low,high)        return root\n如果访问节点的值在[low,high]之间，那么就递归访问左右子树。如果节点值小于low，那么就去访问右子树，因为左子树的值一定更小。（返回右子树的根节点，并且右子树也要进行修剪）如果节点值大于high，那么就去访问左子树，因为右子树的值一定更大。（返回左子树的根节点，并且左子树也要进行修剪）\n将有序数组转换为二叉搜索树108. 将有序数组转换为二叉搜索树\n\n给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。\n\nclass Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:        def tra(nums,left,right):            if left &gt; right:                return None            mid = (left + right)//2            root = TreeNode(nums[mid])            root.left =  tra(nums,left,mid-1)            root.right = tra(nums,mid+1,right)            return root        return tra(nums,0,len(nums)-1)\n有点类似二分法，每次取中间值作为根节点，然后递归构造左右子树。（左闭右闭）\n把二叉搜索树转换为累加树538. 把二叉搜索树转换为累加树\n\n给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n\nclass Solution:    def __init__(self):        self.pre = 0    def convertBST(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if not root:            return         self.convertBST(root.right)        root.val += self.pre         self.pre = root.val        self.convertBST(root.left)        return root\n采用右中左的遍历顺序，先遍历右子树，然后遍历根节点，最后遍历左子树。\n","categories":["算法学习——树"],"tags":["代码随想录"]},{"title":"代码随想录-day11","url":"/2025/12/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day11/","content":"逆波兰表达式求值题目链接根据 逆波兰表示法，求表达式的值。有效的运算符包括 + ,  - ,  * ,  &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。说明：整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\n\n示例 1：输入: [“2”, “1”, “+”, “3”, “ * “]输出: 9解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9\n示例 2：输入: [“4”, “13”, “5”, “&#x2F;“, “+”]输出: 6解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6\n示例 3：输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “ * “, “&#x2F;“, “ * “, “17”, “+”, “5”, “+”]输出: 22解释:该算式转化为常见的中缀算术表达式为：\n\n((10 * (6 / ((9 + 3) * -11))) + 17) + 5       = ((10 * (6 / (12 * -11))) + 17) + 5       = ((10 * (6 / -132)) + 17) + 5     = ((10 * 0) + 17) + 5     = (0 + 17) + 5    = 17 + 5    = 22    \n\n逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。（是一种二叉数树的后续遍历） 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。\n\nclass Solution:    def evalRPN(self, tokens: List[str]) -&gt; int:        stack = []        for i in tokens:            if i == &quot;+&quot; or i == &#x27;-&#x27; or i == &#x27;*&#x27; or i == &quot;/&quot;:                a = stack.pop()                b = stack.pop()                if i == &quot;+&quot;:                    stack.append(a+b)                elif i == &quot;-&quot;:                    stack.append(b-a)                elif i == &quot;*&quot;:                    stack.append(a*b)                elif i == &quot;/&quot;:                    stack.append(int(b/a)) # 向零取整用int（b/a）直接截断小数部分            else :                stack.append(int(i))        return stack.pop()\n使用栈来保存数字，遇到运算符就弹出栈顶的两个数字进行计算，然后把结果压回栈中。最后栈中剩下的数字就是结果。\n滑动窗口最大值题目链接给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。\n\n示例 1：\n\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7\n\n\n示例 2：\n\n输入：nums = [1], k = 1输出：[1]\nfrom collections import dequeclass Queue :    def __init__ (self):        self.que = deque()        def pop(self,value): #这里啥时候队列可能为空呢        if self.que and value == self.que[0]:#队列不为空且遍历的值等于队口            self.que.popleft()   #弹的是最大（对头在左）    def push(self,value):        while self.que and value &gt; self.que[-1]:            self.que.pop()        self.que.append(value)    def get(self):        return self.que[0]class Solution:    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:        que = Queue()        result = []        for i in range(k):            que.push(nums[i])        result.append(que.get())        for i in range(k,len(nums)):            que.pop(nums[i-k]) #例如加入第四个元素前要移除第一个            que.push(nums[i])            result.append(que.get())        return result\n下面是ai的带注释的\nfrom collections import dequeclass MonotonicQueue:  # 改名：明确是单调递减队列，避免语义混淆    def __init__(self):        self.que = deque()  # 存储 nums 的元素（也可存索引，更灵活）        def remove_left(self, value):        &quot;&quot;&quot;        滑动窗口移动时，移除窗口左边界的元素（仅当该元素是队首时，因为队首是最大值）        此时队列可能为空：必须先判断 self.que 非空        &quot;&quot;&quot;        if self.que and value == self.que[0]:  # 队列非空 + 左边界元素是队首（最大值）            self.que.popleft()  # 弹出队首（移除窗口外的最大值）        def push(self, value):        &quot;&quot;&quot;        加入当前元素，维持队列单调递减：        移除队列中所有比当前元素小的元素（这些元素不可能成为后续窗口的最大值）        此时队列可能为空：空队列直接 append 即可        &quot;&quot;&quot;        while self.que and self.que[-1] &lt; value:  # 队列非空 + 队尾元素 &lt; 当前元素            self.que.pop()  # 移除队尾（从右弹出，deque.pop() 是O(1)）        self.que.append(value)  # 加入当前元素，队列仍保持递减        def get_max(self):        &quot;&quot;&quot;获取当前窗口最大值（队首），必须保证调用前队列非空&quot;&quot;&quot;        return self.que[0]class Solution:    def maxSlidingWindow(self, nums, k):        # 边界情况处理（避免队列空时调用 get_max）        if not nums or k == 0 or k &gt; len(nums):            return []                que = MonotonicQueue()        result = []                # 第一步：初始化第一个窗口（前 k 个元素）        for i in range(k):            que.push(nums[i])        # 第一个窗口的最大值加入结果（此时队列非空，因为 k&lt;=len(nums) 且 nums 非空）        result.append(que.get_max())                # 第二步：滑动窗口（从第 k 个元素开始，到最后一个元素）        for i in range(k, len(nums)):            # 1. 移除窗口左边界的元素（i-k 是当前窗口的左边界索引）            left_value = nums[i - k]  # 窗口要移除的左边界元素            que.remove_left(left_value)                        # 2. 加入当前窗口的右边界元素（第 i 个元素）            que.push(nums[i])                        # 3. 记录当前窗口的最大值（队列非空）            result.append(que.get_max())                return result# 测试案例if __name__ == &quot;__main__&quot;:    s = Solution()    print(s.maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3))  # 输出 [3,3,5,5,6,7]（正确）    print(s.maxSlidingWindow([], 3))  # 输出 []（边界处理）    print(s.maxSlidingWindow([1], 1))  # 输出 [1]（边界处理）    print(s.maxSlidingWindow([1,-1], 2))  # 输出 [1]（边界处理）\n这道题是用单调队列来解决的，单调队列是指队列中的元素是单调递增或递减的。那如何保证队列中的元素是单调递减的呢？当有新元素加入时，我们将队列中所有比新元素小的元素都弹出，直到队列为空或者队列尾部的元素大于等于新元素为止。这样就保证了队列中的元素是单调递减的。\n\n关于我在视频弹幕上遇到的一个情况5231，其实解决这个的方式是在push方法中加入一个判断，当队列非空且队尾元素小于等于新元素时，弹出队尾元素，直到队列为空或者队列尾部的元素大于等于新元素为止。（这样3进去的之前2就被弹出了）\n为啥要判断队列非空？初始阶段：刚实例化 Queue 时（init 后），self.que &#x3D; deque() 是空的，此时调用 pop&#x2F;get 都会操作空队列。窗口滑动时移除元素后：比如窗口内所有元素都被 pop 方法移除（例如滑动窗口移动时，队首元素是前一个窗口的最大值，被弹出后队列无其他元素）。nums 数组本身为空或 k&#x3D;0：当输入 nums &#x3D; [] 或 k&#x3D;0 时，循环不执行 push，队列始终为空。\n\n前 K 个高频元素题目链接\n\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n\n示例 1:\n\n输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2\n输出: [1,2]\n\n示例 2:\n\n输入: nums &#x3D; [1], k &#x3D; 1\n输出: [1]\n\n提示：\n\n你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。\n你的算法的时间复杂度必须优于 $O(n \\log n)$ , n 是数组的大小。\n题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。\n你可以按任意顺序返回答案。\n\nclass Solution:    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:        dir = &#123;&#125;        for i in range(len(nums)):            dir[nums[i]] = dir.get(nums[i],0) + 1 #key不存在就设为0，存在就加1        que = []        for key,value in dir.items():            heapq.heappush(que,(value,key)) #注意value在前，因为按照value排序的            if len(que) &gt; k:                heapq.heappop(que)        result = [0] * k        for i in range(k-1,-1,-1): #第一个-1取不到所以就是0开始            result[i] = heapq.heappop(que)[1]        return result\n使用哈希表统计每个元素的频率，然后使用小顶堆维护前 k 个高频元素。小顶堆的大小为 k，每次加入一个元素后，如果堆的大小超过 k，就弹出堆顶元素。解释一下堆，就是完全二叉树，每个节点的左右子树都是堆，且根节点是堆顶。小顶堆的性质是，堆顶元素是堆中最小的元素。大顶堆的性质是，堆顶元素是堆中最大的元素。\n","categories":["算法学习——栈和队列"],"tags":["代码随想录"]},{"title":"代码随想录-day24","url":"/2026/01/10/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day24/","content":"组合总和原始版本39. 组合总和\n\n给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\n\nclass Solution:    def backtracking(self,candidates,target,sums,index,path,result):        if sums &gt; target:            return        if sums == target:            result.append(path[:])            return #空返回，改变result就行        for i in range(index,len(candidates)):            sums += candidates[i]            path.append(candidates[i])            self.backtracking(candidates,target,sums,i,path,result)            sums -= candidates[i]             path.pop()            def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:        result = []        self.backtracking(candidates,target,0,0,[],result)        return result\n总的来说，就是回溯的模板，只是在递归的过程中，需要判断一下是否超过了目标值，如果超过了，就直接返回。如果等于目标值，就将当前路径加入结果集中。然后因为可以重复使用元素，所以递归的索引从当前索引开始（不用i+1）。\n排序加剪枝class Solution:    def backtracking(self,candidates,target,sums,index,path,result):        if sums == target:            result.append(path[:])            return #空返回，改变result就行        for i in range(index,len(candidates)):            sums += candidates[i]            if sums &gt; target:                break            path.append(candidates[i])            self.backtracking(candidates,target,sums,i,path,result)            sums -= candidates[i]             path.pop()            def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:        result = []        candidates.sort()        self.backtracking(candidates,target,0,0,[],result)        return result\n     \n\n组合总和II40. 组合总和 II\n\n给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\n\nclass Solution:    def backtracking(self,candidates,target,sums,index,used,path,result):        if sums == target:            result.append(path[:])            return         for i in range(index,len(candidates)): #用循环让数组的每个变成一棵树的根节点，同时一棵树比一颗更窄，目的就是不要重复（指的是（1，2）（2，1）这种）            #下面的去重是数组里面本身元素的重复导致的（但是又不能简单的把数组元素去重）            if i&gt;index and candidates[i] == candidates[i-1] and not used[i-1]: #进行层剪枝的操作                continue            sums += candidates[i]            if sums &gt; target:                break            path.append(candidates[i])            used[i] = True            self.backtracking(candidates,target,sums,i+1,used,path,result)            used[i] = False            sums -= candidates[i]            path.pop()    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:        result = []        used = [False] * len(candidates)        candidates.sort()        self.backtracking(candidates,target,0,0,used,[],result)        return result\n这道题关键在于区分树枝重复和树层重复，叶子可以和父节点相同，但是不能跟兄弟相同（包括每一个根节点）\n分割回文串131. 分割回文串\n\n给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。\n\nclass Solution:    def backtracking(self,s,index,path,result):        if index == len(s):            result.append(path[:])            return         for i in range(index,len(s)):            if s[index:i+1] == s[index:i+1][::-1] :                path.append(s[index:i+1])                self.backtracking(s,i+1,path,result)                path.pop()    def partition(self, s: str) -&gt; List[List[str]]:        result = []        self.backtracking(s,0,[],result)        return result\n就是用递归加回溯把所有切割方式列出来返回是回文的内容\n","categories":["算法学习——回溯"],"tags":["代码随想录"]},{"title":"代码随想录-day23","url":"/2026/01/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day23/","content":"只能说越到后面越难坚持，加油\n组合77. 组合\n\n给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n\n未剪枝class Solution:    def combine(self, n: int, k: int) -&gt; List[List[int]]:        result = []        self.backtracking(n,k,1,[],result)        return result    def backtracking(self,n,k,index,path,result):        if len(path) == k:            result.append(path[:]) # 注意path的拷贝方式            return        for i in range(index,n+1):            path.append(i)            self.backtracking(n,k,i+1,path,result) #这里改成index+1会返回所有组合（包括重复的）            path.pop()\n剪枝class Solution:    def combine(self, n: int, k: int) -&gt; List[List[int]]:        result = []        self.backtracking(n,k,1,[],result)        return result    def backtracking(self,n,k,index,path,result):        if len(path) == k:            result.append(path[:]) # 注意path的拷贝方式            return        for i in range(index,n-(k-len(path))+2): # 这里的n-(k-len(path))+2是为了剪枝，因为如果n-(k-len(path))+2还小于k，那么就没有必要继续遍历了            path.append(i)            self.backtracking(n,k,i+1,path,result) #这里改成index+1会返回所有组合（包括重复的）            path.pop()\n解释一下这个剪枝的地方：need &#x3D; k - len(path)，i一直到n，共有n-i+1个元素，剩余元素至少要大于等于need才行，因此n-i+1 &gt;&#x3D; need，即n-i+1 &gt;&#x3D; k - len(path)，即n-(k-len(path))+1 &lt;&#x3D; n，但是python的range是左闭右开的，右边取不到，所以要+1变成n-(k-len(path))+2\n组合总和III216. 组合总和 III\n\n找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：只使用数字1到9每个数字 最多使用一次\n\nclass Solution:    def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]:        result = []        self.backtracking(n,k,0,1,[],result)        return result    def backtracking(self,targetsum,k,cursum,index,path,result):        if cursum &gt; targetsum:            return         if len(path) == k :            if targetsum == cursum:                result.append(path[:])            return         for i in range(index,9-(k-len(path))+2):            cursum += i            path.append(i)            self.backtracking(targetsum,k,cursum,i+1,path,result)            cursum -= i            path.pop()\n\n这道题比上一道题多的剪枝的内容是当前和大于目标和时，直接返回\n以及在回溯的时候别忘了更新当前和\n\n电话号码的字母组合17. 电话号码的字母组合\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\nclass Solution:    def __init__(self):        self.lettermap=[            &#x27;&#x27;,            &#x27;&#x27;,            &#x27;abc&#x27;,            &#x27;def&#x27;,            &#x27;ghi&#x27;,            &#x27;jkl&#x27;,            &#x27;mno&#x27;,            &#x27;pqrs&#x27;,            &#x27;tuv&#x27;,            &#x27;wxyz&#x27;        ]        self.result = []        self.s = &#x27;&#x27;    def backtracking(self,digits,index):        if index == len(digits): #终止条件深度等于位数            self.result.append(self.s)            return         digit = int(digits[index]) #字符形式转化，便于查字典        letter = self.lettermap[digit] #对应层的字符串        for i in letter: #实现分叉            self.s += i            self.backtracking(digits,index + 1) #深度探索            self.s = self.s[:-1] #回溯，删掉最后一个    def letterCombinations(self, digits: str) -&gt; List[str]:        if len(digits) == 0:            return self.result        self.backtracking(digits,0)        return self.result\n咱就是说明天别个人休息我再努力一下就可以按时完成了，每天的任务一定要完成，欠了就永远赶不上了，一天做两个就很辛苦了，加油          \n","categories":["算法学习——回溯"],"tags":["代码随想录"]},{"title":"代码随想录-day25","url":"/2026/01/11/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day25/","content":"复原IP地址93. 复原 IP 地址\n\n有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。\n\n\n例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1“ 是 无效 IP 地址。\n\n\n给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。\n\nclass Solution:    def isok(self,s,s_index,e_index):        if s_index &gt; e_index:            return False        if s[s_index] == &#x27;0&#x27; and s_index != e_index:            return False        if int(s[s_index:e_index+1]) &gt; 255:            return False        return True    def backtracking(self,s,index,count,cur,result):        if count == 3 and self.isok(s,index,len(s)-1):            cur += s[index:]            result.append(cur)        for i in range(index,len(s)):            if self.isok(s,index,i):                temp = s[index:i+1]                count += 1                self.backtracking(s,i+1,count,cur+temp+&#x27;.&#x27;,result) #隐式回溯，cur本身不变                count -=1    def restoreIpAddresses(self, s: str) -&gt; List[str]:        result = []        self.backtracking(s,0,0,&#x27;&#x27;,result)        return result\n不能直接用s，字符串不可变还是要设置个变量接住\n子集78. 子集\n\n给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n\n\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n\nclass Solution:    def backtracking(self,nums,index,path,result):        for i in range(index,len(nums)):            path.append(nums[i])            result.append(path[:])            self.backtracking(nums,i+1,path,result)            path.pop()    def subsets(self, nums: List[int]) -&gt; List[List[int]]:        result = [[]]        self.backtracking(nums,0,[],result)        return result\n真别说，连剪枝都不要，但是这道题每个节点都要记录一下\n子集II90. 子集 II\n\n给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n\n\n解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。\n\n示例 1：\n\n\n输入：nums &#x3D; [1,2,2]\n\n输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]\n\n示例 2：\n\n\n输入：nums &#x3D; [0]\n\n输出：[[],[0]]\n\n\nclass Solution:    def backtracking(self,nums,index,path,result,used):        for i in range(index,len(nums)):            if i&gt;index and nums[i]==nums[i-1] and not used[i-1]:                continue             path.append(nums[i])            used[i] = True            result.append(path[:])            self.backtracking(nums,i+1,path,result,used)            path.pop()            used[i] = False    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:        result = [[]]        nums.sort()        used = [False]*len(nums)        self.backtracking(nums,0,[],result,used)        return result\n就是在上道题的基础上，加一个去重的操作，用昨天的树层去重的方法，添加一个uesd来表示是否被使用\n怎么说，终于赶上来，之前每天都要在截止前，现在也可以按时完成了，感觉回溯学的不如之前的，可能是在期末考，总是把这个当负担，希望后面考完状态可以调整过来。\n","categories":["算法学习——回溯"],"tags":["代码随想录"]},{"title":"代码随想录-day27","url":"/2026/01/12/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day27/","content":"非递减子序列491. 非递减子序列\n\n给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况    \n\n\n数组的子序列是由数组删除一些元素（也可能不删除）而不改变剩余元素顺序形成的序列。\n例如，[4,6,7] 是数组 [4,5,6,7] 的一个子序列。\n题目数据保证答案中至少有一个非递减子序列。\n\nclass Solution:    def backtracking(self,nums,index,path,result):        if len(path) &gt; 1:            result.append(path[:])        set_ = set()    #!!!!!!进入下一层前重置集合，相当于只在同层里面使用set实现层去重        for i in range(index,len(nums)):            if (path and nums[i] &lt; path[-1]) or nums[i] in set_:                continue            path.append(nums[i])            set_.add(nums[i]) #但是往下探索返回的set不会设置成最底下的元素吗            #不会，我的理解是for循环是分树枝，回溯函数是生长枝条，哦，used在每个函数里被创建，就属于这个函数的局部变量，所以每一层都有自己的used            self.backtracking(nums,i+1,path,result)            path.pop()    def findSubsequences(self, nums: List[int]) -&gt; List[List[int]]:        result = []        self.backtracking(nums,0,[],result)        return result\n主要是加了一个set来实现树层去重，注意set是在每一层递归开始时创建的不能直接排序nums,因为排序会改变元素的相对顺序，导致错误的结果,因此这里想实现返回的是非递减子序列就要在path加元素的时候判断是否比path[-1]大然后还有个有意思的就是实现树层去重（就是在分层的时候根节点相同的树枝就不要了），结合这几天的学习我对这种题目的理解就是————for循环是分树枝，回溯函数是生长枝条，所以在for循环里面判断是否去重，而不是在回溯函数里面判断是否去重。那如何实现树层去重呢？那就是用set_这个集合来实现，并且这是个局部变量（作用域在当前层，也就是在每个回溯函数中），每一层递归都会创建当层的集合，用来记录当层已经使用过的元素，从而实现树层去重。\n全排列46. 全排列(题目链接)给定一个不含重复数字的数组 nums ，返回其所有可能的全排列。你可以按 任意顺序 返回答案。\n示例 1：\n\n输入：nums &#x3D; [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n示例 2：\n\n输入：nums &#x3D; [0,1]输出：[[0,1],[1,0]]\n\n示例 3：\n\n输入：nums &#x3D; [1]输出：[[1]]\n\nclass Solution:    def backtracking(self,nums,used,path,result):        if len(path) == len(nums):            result.append(path[:])        for i in range (len(nums)):            if used[i]:                continue            path.append(nums[i])            used[i] = True            self.backtracking(nums,used,path,result)            path.pop()            used[i] = False    def permute(self, nums: List[int]) -&gt; List[List[int]]:        result = []        used = [False]*len(nums)        self.backtracking(nums,used,[],result)        return result\n在排列问题上就不再需要startIndex了，因为排列是有序的，所以每次都从0开始遍历但是选过的元素就不能再选了，所以需要一个used数组来记录哪些元素已经被选过了（类似组合问题的剪枝，每调用回溯函数就剪一条边）\n全排列 II47. 全排列 II(题目链接)给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。示例 1：\n\n输入：nums &#x3D; [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]]\n\n示例 2：\n\n输入：nums &#x3D; [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\nclass Solution:    def backtracking(self,nums,used,path,result):        if len(path) == len(nums):            result.append(path[:])        set_ = set()        for i in range(len(nums)):            if nums[i] in set_ or used[i]:                continue            path.append(nums[i])            used[i] = True            set_.add(nums[i])            self.backtracking(nums,used,path,result)            used[i] = False            path.pop()    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:        result = []        used = [False] * len(nums)        self.backtracking(nums,used,[],result)        return result\n主要是在排列的基础上加了一个set来实现树层去重，注意set是在每一层递归开始时创建的,就是结合上道题的排列，和上上道题的去重。实际上一个uesd也行，用之前的排序加used[i]和used[i-1]判断是否相同来实现树层去重\n\n感觉先自己做再看视频就激情四射了","categories":["算法学习——回溯"],"tags":["代码随想录"]},{"title":"代码随想录-day-28","url":"/2026/01/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day28/","content":"分发饼干分发饼干\n\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。\n\n\n示例 1:\n\n\n输入: g &#x3D; [1,2,3], s &#x3D; [1,1]\n输出: 1\n解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。\n\n示例 2:\n\n输入: g &#x3D; [1,2], s &#x3D; [1,2,3]\n输出: 2\n解释:你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2。\n\nclass Solution:    def findContentChildren(self, g: List[int], s: List[int]) -&gt; int:        g.sort()        s.sort()        index = 0        result = 0        for i in range(len(s)):            if index &gt;= len(g):                break            if g[index] &lt;= s[i]:                index += 1        return index\n感觉掌握的很差，不是很理解云里雾里的过的\n摆动序列摆动序列如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。\n\n例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。\n相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n\n子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。示例 1：\n\n输入：nums &#x3D; [1,7,4,9,2,5]输出：6解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。\n\n示例 2：\n\n输入：nums &#x3D; [1,17,5,10,13,15,10,5,16,8]输出：7 解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。\n\n示例 3：\n\n输入：nums &#x3D; [1,2,3,4,5,6,7,8,9]输出：2\n\nclass Solution:    def wiggleMaxLength(self, nums: List[int]) -&gt; int:        if len(nums) &lt;= 1:            return len(nums)        curdif = 0        predif = 0        result = 1        for i in range(len(nums)-1):            curdif = nums[i+1] - nums[i]            if (predif &lt;= 0 and curdif &gt; 0) or (predif &gt;= 0 and curdif &lt; 0):                result += 1                predif = curdif        return result\n主要是找那个尖尖的数量（也可以是圆润的），然后最后一个默认添加\n最大子数组和最大子数组和\n\n给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组 是数组中的一个连续部分。\n\n示例 1：\n\n输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n示例 2：\n\n输入：nums &#x3D; [1]\n输出：1\n\n示例 3：\n\n输入：nums &#x3D; [5,4,-1,7,8]\n输出：23\n\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        result = float(&#x27;-inf&#x27;)        count = 0        for i in nums:            count += i            if count &gt; result:                result = count            if count &lt; 0:                count = 0        return result\n局部最大，如果局部最大为负数，那么就从下一个数开始计算（用置零来实现）把昨天的补了，今天的暂时不行，明天考英语\n","categories":["算法学习——贪心"],"tags":["代码随想录"]},{"title":"代码随想录-day29","url":"/2026/01/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day29/","content":"买卖股票的最佳时机 II买卖股票的最佳时机 II给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的 最大 利润 。\n示例 1：\n\n输入：prices &#x3D; [7,1,5,3,6,4] 输出：7 解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4。随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3。最大总利润为 4 + 3 &#x3D; 7 。\n\n示例 2：\n\n输入：prices &#x3D; [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4。最大总利润为 4 。\n\n示例 3：\n\n输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。\n\nclass Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        result = []        for i in range(1,len(prices)):            if prices[i] -prices[i-1] &gt; 0:                result.append(prices[i] -prices[i-1])        return sum(result)\n贪心算法，局部最优：收集每天的正利润，全局最优：求得最大利润。\n跳跃游戏跳跃游戏给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。   \n示例 1：\n\n输入：nums &#x3D; [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n示例 2：\n\n输入：nums &#x3D; [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\n\nclass Solution:    def canJump(self, nums: List[int]) -&gt; bool:        cover = 0        if len(nums) == 1:            return True        i = 0        while i &lt;= cover:            cover = max(nums[i]+i,cover)            if cover &gt;= len(nums)-1:                return True            i += 1        return False \n\ni 只能在覆盖范围内移动，所以i &lt;&#x3D; cover\n每次更新覆盖范围cover &#x3D; max(nums[i]+i,cover)\n\n跳跃游戏 II跳跃游戏 II给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个下标。假设你总是可以到达数组的最后一个下标。\n示例 1：\n\n输入：nums &#x3D; [2,3,1,1,4]输出：2解释：跳到最后一个下标需要 2 步。第一步，从下标 0 跳到下标 1, 跳 1 步。第二步，从下标 1 跳到下标 4, 跳 3 步。\n\n示例 2：\n\n输入：nums &#x3D; [2,3,0,1,4]输出：2\n\nclass Solution:    def jump(self, nums: List[int]) -&gt; int:        cur = 0        next = 0        result = 0        for i in range(len(nums)-1):            next = max(i+nums[i],next)            if i == cur:                result+=1                cur = next                if next &gt;= len(nums)-1 :                    break        return result\n\ncur表示当前覆盖范围的边界\nnext表示下一次跳跃能到达的最远位置\n当i到达cur时，说明需要进行下一次跳跃，更新cur为next\n遍历时只需要遍历到len(nums)-2，因为到达最后一个位置不需要跳跃\n\nk次取反后最大化的数组和K 次取反后最大化的数组和给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。重复这个过程恰好 k 次。可以多次选择同一个下标 i 。以这种方式修改数组后，返回数组 可能的最大和 。\n示例 1：\n\n输入：nums &#x3D; [4,2,3], k &#x3D; 1输出：5解释：选择下标 1 ，nums 变为 [4,-2,3] 。\n\n示例 2：\n\n输入：nums &#x3D; [3,-1,0,2], k &#x3D; 3输出：6解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。\n\nclass Solution:    def largestSumAfterKNegations(self, nums: List[int], k: int) -&gt; int:        nums.sort(key = lambda x:abs(x),reverse=True)        for i in range(len(nums)):            if k &gt; 0 and nums[i] &lt; 0:                nums[i] *= -1                k -=  1        if k % 2 == 1:            nums[-1] *= -1        return sum(nums)\n\n先将数组按绝对值从大到小排序，这样可以优先处理绝对值大的负数\n遍历数组，将负数变为正数，直到k用完或者没有负数为止\n如果k还有剩余且为奇数，则将绝对值最小的数变为负数\n\n","categories":["算法学习——贪心"],"tags":["代码随想录"]},{"title":"代码随想录-day3","url":"/2025/12/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day3/","content":"移除链表元素\n题意：删除链表中等于给定值 val 的所有节点。\n\n\n示例 1： 输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6 输出：[1,2,3,4,5]\n示例 2： 输入：head &#x3D; [], val &#x3D; 1 输出：[]\n示例 3： 输入：head &#x3D; [7,7,7,7], val &#x3D; 7 输出：[]\n\n解法一：虚拟头节点\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        dummy_head = ListNode(next = head)        cur_node = dummy_head        while cur_node.next:            if cur_node.next.val == val:                cur_node.next = cur_node.next.next            else :                cur_node = cur_node.next        return dummy_head.next #关于为啥要.next,因为这个节点是我们创建的虚拟的，它指向的才是头节点\n首先，在删除值为val的节点的时候我们要考虑头节点的情况，而且如果连续的多个节点等于val且在头节点的后面的时候，我们要用循环删去，总而言之，这种分类讨论的方法比较麻烦，为了解决这个问题我们可以采用虚拟头结点的方式。创建虚拟头节点dummy_head，指向头节点head。然后设置一个指针current，指向dummy_head。遍历链表，当current.next的值等于val时，删除current.next节点，否则current指针后移。（循环条件用current.next，到达尾端的时候指向None，循环结束）最后返回dummy_head.next，因为dummy_head本身是我们创造的虚拟的，而dummy_head.next才是真正的头节点。解法二：不使用虚拟头节点\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        while head and head.val == val :            head = head.next        current = head        while current and current.next:            while current.next and current.next.val == val:                current.next = current.next.next            current = current.next        return head\n我只说我最开始没考虑的情况，例如111123，假设val&#x3D;1，连续的1，当时我是用if的情况，条件满足头节点指向下一个，但是如果连续的val在头节点的后面，就会出错。后面1233244441111232，我又用if，还是没删干净，我粘一下我的错误的代码，大家以此为戒，也可以看看我的错误代码思考我的问题。\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        current = head        while current and current.next:            if current.val == val:                head = current.next            if current.next.val == val:                current.next = current.next.next            else :                current = current.next        return head     \n\n设计链表\n题意：  在链表类中实现这些功能：\n\n\nget(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\naddAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\naddAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\naddAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\ndeleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\n\nclass ListNode:    def __init__(self,val=0,next=None):        self.val = val        self.next = nextclass MyLinkedList:    def __init__(self):           self.dummy_node = ListNode()        self.size = 0    def get(self, index: int) -&gt; int:        if index &gt;= self.size or index &lt; 0:   #为啥不能取等，类似数组下标从零开始            return -1        current = self.dummy_node.next # 有效节点从虚拟节点下一个开始        for i in range(index):#这里循环用来找目标，链表的查找是要遍历的，不像数组用下标就行            current = current.next        return current.val    def addAtHead(self, val: int) -&gt; None:        self.dummy_node.next = ListNode(val,self.dummy_node.next) #从右往左，先创建新的节点，且新节点的下个节点指向原来虚拟头的next，然后再让虚拟头指向新节点        self.size += 1    def addAtTail(self, val: int) -&gt; None:        current = self.dummy_node        while current.next:            current = current.next        current.next = ListNode(val)        self.size += 1    def addAtIndex(self, index: int, val: int) -&gt; None:        if index &lt; 0 or index &gt; self.size:            return -1         current = self.dummy_node        for i in range(index):            current = current.next        current.next = ListNode(val,current.next)        self.size += 1    def deleteAtIndex(self, index: int) -&gt; None:        if index &lt; 0 or index &gt;= self.size:            return        current = self.dummy_node        for i in range(index):            current = current.next        current.next = current.next.next        self.size -= 1\n我做过卡码网的链表的基本操作，期末考完我把卡码网我做过的题也记录到这个blog里额，就是index合法性检查，然后增加删除的基本操作\n反转链表题意：反转一个单链表。\n\n示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL方法一：双指针法\n\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        pre = None        current = head        while current:            temp = current.next            current.next = pre            pre = current            current = temp        return pre\n通过设置当前指针，pre指针来实现，每次循环都让当前指针指向前一个节点，然后pre指针移动到当前指针，当前指针移动到下一个节点，直到当前指针为空，返回pre指针。但是只是这样会丢失current.next的节点，因此需要temp指针来暂存current.next的节点，然后让current指针指向前一个节点，pre指针移动到current指针，current指针移动到temp指针，直到current指针为空，返回pre指针。\n方法二：递归法\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        return self.reverse(head,None)        def reverse(self,current,pre) :        if current == None:            return pre        temp = current.next        current.next = pre        return self.reverse(temp,current)\n实话实话，让我再写一遍我写不出递归，我再捣鼓捣鼓吧，视频看懂了但又好像没看懂\n","categories":["算法学习——链表"],"tags":["代码随想录"]},{"title":"代码随想录-day30","url":"/2026/01/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day30/","content":"加油站加油站在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。\n示例 1:\n\n输入: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。\n\n示例 2:\n\n输入: gas &#x3D; [2,3,4], cost &#x3D; [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。\n\nclass Solution:    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int:        total = 0        cur = 0        start = 0        for i in range(len(gas)):            dle = gas[i] - cost[i]            total += dle            cur += dle            if cur &lt; 0:                start = i + 1                cur = 0        if total &lt; 0:            return -1        return start\n\n分发糖果分发糖果n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：每个孩子至少分配到 1 个糖果。相邻两个孩子中，评分更高的那个会获得更多的糖果。请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。示例 1：\n\n输入：ratings &#x3D; [1,0,2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。\n\n示例 2：\n\n输入：ratings &#x3D; [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。\n\nclass Solution:    def candy(self, ratings: List[int]) -&gt; int:        n = len(ratings)        candies = n * [1]        for i in range(1,n):            if ratings[i] &gt; ratings[i-1]:                candies[i] = candies[i-1]+1        for i in range(n-2,-1,-1):            if ratings[i] &gt; ratings[i+1]:                candies[i] = max(candies[i+1]+1,candies[i])        return sum(candies)\n\n先从左到右遍历一遍，如果当前孩子评分比前一个孩子高，则当前孩子糖果数为前一个孩子糖果数加一。\n然后从右到左遍历一遍，如果当前孩子评分比后一个孩子高，则当前孩子糖果数为后一个孩子糖果数加一。(注意要取当前孩子糖果数和后一个孩子糖果数加一的较大值)\n最后将所有孩子的糖果数相加即为所需的最少糖果数目。\n\n柠檬水找零柠檬水找零在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。\n示例 1：\n\n输入：bills &#x3D; [5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。\n\n示例 2：\n\n输入：bills &#x3D; [5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。\n\nclass Solution:    def lemonadeChange(self, bills: List[int]) -&gt; bool:        change1 = 0        change2 = 0        if bills[0] != 5:            return False        for i in range(len(bills)):            if bills[i] == 5:                change1 += 1            elif bills[i] == 10 :                if change1 &gt;= 1:                    change1 -= 1                    change2 += 1                else:                    return False             if bills[i] == 20 :                if change1 &gt;= 1 and change2 &gt;= 1:                    change1 -= 1                    change2 -= 1                elif change1 &gt;= 3:                    change1 -= 3                else :                    return False         return True\n\n用change1记录5美元的数量，change2记录10美元的数量。\n遍历账单数组，对于每个账单：\n如果是5美元，change1加一。\n如果是10美元，若change1大于等于1，则change1减一，change2加一；否则返回False。\n如果是20美元，若change1大于等于1且change2大于等于1，则change1减一，change2减一；若change1大于等于3，则change1减三；否则返回False。\n\n\n最后返回True。\n\n按照身高重建队列按照身高重建队列假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\n示例 1：\n\n输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：队列重新构造如下：\n\n\n第 1 个人，[5,0]，没有身高更高或相等的人在他前面。\n第 2 个人，[7,0]，没有身高更高或相等的人在他前面。\n第 3 个人，[5,2]，有 2 个身高更高或相等的人在他前面，即 [7,0] 和 [7,1]。\n第 4 个人，[6,1]，有 1 个身高更高或相等的人在他前面，即 [7,0]。\n第 5 个人，[4,4]，有 4 个身高更高或相等的人在他前面，即 [7,0]、[7,1]、[5,0] 和 [5,2]。\n第 6 个人，[7,1]，有 1 个身高更高或相等的人在他前面，即 [7,0]。\n\n示例 2：\n\n输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]解释：队列重新构造如下：\n\n\n第 1 个人，[4,0]，没有身高更高或相等的人在他前面。\n第 2 个人，[5,0]，没有身高更高或相等的人在他前面。\n第 3 个人，[2,2]，有 2 个身高更高或相等的人在他前面，即 [6,0] 和 [5,0]。\n第 4 个人，[3,2]，有 2 个身高更高或相等的人在他前面，即 [6,0] 和 [5,0]。\n第 5 个人，[1,4]，有 4 个身高更高或相等的人在他前面，即 [6,0]、[5,0]、[4,0] 和 [3,2]。\n第 6 个人，[6,0]，没有身高更高或相等的人在他前面。\n\nclass Solution:    def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]:        people.sort(key = lambda x:(-x[0],x[1])) #第一个元素从大到小，第二个元素从小到大        que = []        for i in people:            que.insert(i[1],i) #把排好的元组按照元素2的值插入        return que\n\nclass Solution:    def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]:    \t# 先按照h维度的身高顺序从高到低排序。确定第一个维度        # lambda返回的是一个元组：当-x[0](维度h）相同时，再根据x[1]（维度k）从小到大排序        people.sort(key=lambda x: (-x[0], x[1]))        que = []\t\t# 根据每个元素的第二个维度k，贪心算法，进行插入        # people已经排序过了：同一高度时k值小的排前面。        for p in people:            que.insert(p[1], p)        return que\n思路上类似分糖果，一项一项的完成，先按照身高h从高到低排序，若身高相同则按照k值从小到大排序，再根据k值插入到队列中。\n\n先按照身高h从高到低排序，若身高相同则按照k值从小到大排序。\n遍历排序后的数组，对于每个元素p：\n插入到队列que的第p[1]个位置。\n\n\n最后返回que。\n\n","categories":["算法学习——贪心"],"tags":["代码随想录"]},{"title":"代码随想录-day-32","url":"/2026/01/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day32/","content":"合并区间合并区间以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。\n示例 1：\n\n输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]输出：[[1,6],[8,10],[15,18]]解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n\n示例 2：\n\n输入：intervals &#x3D; [[1,4],[4,5]]输出：[[1,5]]解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。\n\n示例 3：\n\n输入：intervals &#x3D; [[4,7],[1,4]]输出：[[1,7]]解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。\n\nclass Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        if len(intervals) &lt;= 1 :            return intervals        result = []        intervals.sort(key = lambda x:x[0])        result.append(intervals[0])        for i in range(1,len(intervals)):            if intervals[i][0] &lt;= result[-1][1]:                result[-1][1] = max(result[-1][1],intervals[i][1])            else :                result.append(intervals[i])        return result\n首先设置初始数组为第一个区间(作为结果数组)再判断重叠区间，重叠区间的判断条件是当前区间的起始位置小于等于结果数组中最后一个区间的结束位置。如果重叠，则更新结果数组中最后一个区间的结束位置为两者的最大值。如果不重叠，则将当前区间添加到结果数组中。\n单调递增的数字单调递增的数字当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。\n示例 1:\n\n输入: n &#x3D; 10输出: 9\n\n示例 2:\n\n输入: n &#x3D; 1234输出: 1234\n\n示例 3:\n\n输入: n &#x3D; 332输出: 299\n\nclass Solution:    def monotoneIncreasingDigits(self, n: int) -&gt; int:        strn = str(n)        flag = len(strn)        for i in range(len(strn)-1,0,-1): #因为后续用i-1和i比较，不包含第一个来防止越界访问            if strn[i-1] &gt; strn[i]:                flag = i                strn = strn[0:i-1]+str(int(strn[i-1])-1)+strn[i:]        for i in range(flag,len(strn)):            strn = strn[:i] + &quot;9&quot; + strn[i+1:]        return int(strn)\n首先将整数转换为字符串以便逐位处理。从右向左遍历字符串，找到第一个不满足单调递增条件的位置i。将该位置的数字减1，并将该位置后面的所有数字都设为9。将处理后的字符串转换为整数并返回。\n监控二叉树监控二叉树给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    # 0：未覆盖 1：有摄像头 2：有覆盖    def minCameraCover(self, root: Optional[TreeNode]) -&gt; int:        self.result = 0        if self.dfs(root,self.result) == 0:            self.result += 1        return self.result    def dfs(self,cur,result):        if cur == None:            return 2        left = self.dfs(cur.left,self.result)        right = self.dfs(cur.right,self.result)        if left == 2 and right == 2:           return 0        if left == 0 or right == 0 :            self.result += 1             return 1        if left == 1 or right == 1 :            return 2 \n首先要给每个节点设置状态，0：未覆盖 1：有摄像头 2：有覆盖并让叶子节点的子节点设置为2（有覆盖），因为叶子节点没有子节点，所以设置为0（未覆盖）。如果一个节点的左右子节点都是2（有覆盖），那么该节点就是0（未覆盖）。如果一个节点的左右子节点有一个是0（未覆盖），那么该节点就是1（有摄像头）（）优先级比下面的高。如果一个节点的左右子节点都是1（有摄像头），那么该节点就是2（有覆盖）。还有第四种情况就是到根节点了，并设置为未覆盖，但是根节点可没有父节点，因此要改为1（有摄像头）。\n","categories":["算法学习——贪心"],"tags":["代码随想录"]},{"title":"代码随想录-day31","url":"/2026/01/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day31/","content":"用最少数量的箭引爆气球用最少数量的箭引爆气球有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。\n示例 1：\n\n输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]输出：2解释：气球可以用2支箭来爆破:\n\n\n在x &#x3D; 6处射出箭，击破气球[2,8]和[1,6]。\n在x &#x3D; 11处发射箭，击破气球[10,16]和[7,12]。\n\n示例 2：\n\n输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]输出：4解释：每个气球需要射出一支箭，总共需要4支箭。\n\n示例 3：\n\n输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]输出：2解释：气球可以用2支箭来爆破:\n\n\n在x &#x3D; 2处发射箭，击破气球[1,2]和[2,3]。\n在x &#x3D; 4处射出箭，击破气球[3,4]和[4,5]。\n\nclass Solution:    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:        if not points:            return 0        result = 1        points.sort(key =lambda x:x[0])        for i in range(1,len(points)):            if points[i][0] &gt; points[i-1][1]:                result += 1            else:                points[i][1] = min(points[i-1][1],points[i][1])        return result\n无重叠区间无重叠区间给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。注意 只在一点上接触的区间是 不重叠的。例如 [1, 2] 和 [2, 3] 是不重叠的。\n示例 1:\n\n输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。\n\n示例 2:\n\n输入: intervals &#x3D; [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n\n示例 3:\n\n输入: intervals &#x3D; [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。\n\nclass Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        if not intervals:            return 0        result = 1        intervals.sort(key = lambda x:x[0])        for i in range(1,len(intervals)):            if intervals[i][0] &gt;= intervals[i-1][1]:                result += 1            else:                intervals[i][1] = min(intervals[i][1],intervals[i-1][1])        return len(intervals) - result\n这一题就是在上一题的基础上，合并重叠的区域并计算数量，总的减去数量就是重叠的数量（注意：只在一点上接触的区间是不重叠的，多个取等）。\n划分字母区间划分字母区间给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 “ababcc” 能够被分为 [“abab”, “cc”]，但类似 [“aba”, “bcc”] 或 [“ab”, “ab”, “cc”] 的划分是非法的。注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。返回一个表示每个字符串片段的长度的列表。\n示例 1：\n\n输入：s &#x3D; “ababcbacadefegdehijhklij”输出：[9,7,8]解释：划分结果为 “ababcbaca”、”defegde”、”hijhklij” 。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 这样的划分是错误的，因为划分的片段数较少。 \n\n示例 2：\n\n输入：s &#x3D; “eccbbbbdec”输出：[10]\n\nclass Solution:    def partitionLabels(self, s: str) -&gt; List[int]:        has = &#123;&#125;        for i in range(len(s)):            has[s[i]] = i        result = []        end = 0        start = 0        for i,c in enumerate(s):            end = max(end,has[c])            if i == end:                result.append(end-start+1)                start = i+1        return result\n用哈希表记录每个字符最后出现的位置，然后遍历字符串，记录当前字符最后出现的位置，当遍历到的位置等于当前字符最后出现的位置时（实际上片段中的结束是在更新的），说明当前片段结束，将当前片段的长度加入结果列表中。\n","categories":["算法学习——贪心"],"tags":["代码随想录"]},{"title":"代码随想录-day34","url":"/2026/01/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day34/","content":""},{"title":"代码随想录day-4","url":"/2025/12/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day4/","content":"两两交换链表中的节点给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\nclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        dummy_head = ListNode(next=head)        current = dummy_head        while current.next and current.next.next: #注意先后顺序防止空指针异常            temp1 = current.next            temp2 = temp1.next.next            current.next = current.next.next            current.next.next = temp1            temp1.next = temp2            current = current.next.next        return dummy_head.next\n有点像昨天的反转列表，也采用了temp指针来保存数据，这道题核心在与两两交换前需要先找到前置节点，并且在循环判断的条件中要注意先后顺序防止空指针异常，当然指针确实有点绕，画个图还是很有帮助的。\n删除链表的倒数第N个节点给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。进阶：你能尝试使用一趟扫描实现吗？\n\n输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2 输出：[1,2,3,5]  示例 2：  输入：head &#x3D; [1], n &#x3D; 1 输出：[]  示例 3：  输入：head &#x3D; [1,2], n &#x3D; 1 输出：[1]\n\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        dummy_head = ListNode(next=head)        slow = dummy_head        fast = dummy_head        n += 1        while n and fast :            n -= 1            fast = fast.next         while fast:            fast = fast.next            slow = slow.next        slow.next = slow.next.next        return dummy_head.next\n这道题就是快慢指针，要想找到倒数第二个n，那就先让fast指针移动n+1步，然后再让slow指针和fast指针同时移动，直到fast指针指向None，这时候slow指针就指向了倒数第二个n前一个的位置。只有找到倒二的前一个位置，才能进行删除操作。\n链表相交给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。图示两个链表在节点 c1 开始相交：题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        count1 = 0        count2 = 0        cur1 = headA        cur2 = headB        while cur1 :            count1 += 1            cur1 = cur1.next        cur1 = headA        while cur2:            count2 += 1            cur2 = cur2.next        cur2 = headB        less = count1 - count2        if less &gt; 0:            for i in range(less):                cur1 = cur1.next            while cur1 != cur2:                cur1 = cur1.next                cur2 = cur2.next            return cur1        else :            less = -less            for i in range(less):                cur2 = cur2.next            while cur1 != cur2:                cur1 = cur1.next                cur2 = cur2.next            return cur2\n这是我一开始的想法，先找到两个链表的长度，然后让长的链表先移动长度差的步数，然后再让两个链表同时移动，直到找到相交的节点。实际上我找了非常有意思的解法，就是让两个链表同时移动，当其中一个链表到达末尾时，让它指向另一个链表的头节点，然后继续移动，当两个链表相交时，它们会在相交点相遇。\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:        if not headA or not headB:            return None        cura = headA        curb = headB        while cura != curb:            cura = cura.next if cura else headB            curb = curb.next if curb else headA        return cura\n一种类似算梯形面积的方法，把短的和长的拼在一起，简单来说，就是我让两条链表同时移动，当其中一个链表到达末尾时，让它指向另一个链表的头节点，然后继续移动，当两个链表相交时，它们会在相交点相遇。（感觉这么说有点抽象），那就假设相同部分长度c，不相同部分长的a，短的b。第一条先走a+c，第二条走b+c，此时让一再走b，二再走a，这时候两条都是a+b+c，欸刚好到相同长度，并且接下来走的是相同的部分\n环形链表II题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        fast = head        slow = head        while fast and fast.next:            fast = fast.next.next            slow = slow.next            if slow == fast:                index = slow                index_s = head                while index != index_s:                    index = index.next                    index_s = index_s.next                return index        return None\n还是快慢指针，快指针每次移动两步，慢指针每次移动一步，当它们相遇时，说明链表有环。（因为不是环肯定不会相遇，快指针早就跑远了）这时候就是判断环的入口了，让一个指针从相遇点开始移动，另一个指针从链表头开始移动，当它们相遇时，就是环的入口。（数学：假设head到环入口是a，环入口到相遇点是b，相遇点到环入口是c，那么快指针走的距离是a+b+n（b+c），慢指针走的距离是a+b，因为快指针每次移动两步，慢指针每次移动一步，所以快指针走的距离是慢指针的两倍，即2(a+b) &#x3D; a+b+n（b+c），所以a &#x3D; （n-1）（b+c）+c，b+c就是一圈，转一圈也会回到起点，所以两个指针再次出发就会在入口相遇）但，实际上不需要index，在python里面直接让慢指针回到起点，然后快指针再相遇的位置继续走，速度和慢指针相同，当它们再次相遇时，就是环的入口。\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        fast = head        slow = head        while fast and fast.next:            fast = fast.next.next            slow = slow.next            if slow == fast:                fast = head                while slow != fast:                    slow = slow.next                    fast = fast.next                return fast        return None","categories":["算法学习——链表"],"tags":["代码随想录"]},{"title":"代码随想录-day6","url":"/2025/12/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day6/","content":"有效的字母异位词\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。-示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true-示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false说明: 你可以假设字符串只包含小写字母。\n\nclass Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        hash = [0] * 26        for i in s:            hash[ord(i) - ord(&#x27;a&#x27;)] += 1        for t_ in t:            hash[ord(t_) - ord(&#x27;a&#x27;)] -= 1        for h in hash:            if h != 0:                return False        return True\n这道题的思路是：用一个长度为26的数组来存储每个字母出现的次数，遍历字符串s时，对应字母的位置加1，遍历字符串t时，对应字母的位置减1。最后遍历数组，如果数组里面的元素都为0，说明两个字符串是字母异位词，返回True，否则返回False。讲一下我觉得比较有意思的地方就是这个下标转化的方式，通过减去a的ascll值得到一个在0-25之间的下标，对应数组的位置，这样就可以统计每个字母出现的次数。（有点像凯撒密码，也算是一种哈希函数的实现）\n两个数组的交集题意：给定两个数组，编写一个函数来计算它们的交集。说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。\nclass Solution:    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        hash_set = set()        hash_list = set()        for i in nums1:            hash_set.add(i)        for i in nums2:            if i in hash_set:                hash_list.add(i)        return list(hash_list)\n也是用哈希表来存储数组里面的元素，然后存放在集合里面，因为集合里面要求元素是唯一的，再把数组1里集合元素和数组2里元素进行对比，如果存在就放到另一个集合里面，最后返回集合转换为列表即可。\n快乐数\n编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。\n\n\n示例：输入：19输出：true解释：1^2 + 9^2 &#x3D; 828^2 + 2^2 &#x3D; 686^2 + 8^2 &#x3D; 1001^2 + 0^2 + 0^2 &#x3D; 1\n\nclass Solution:    def isHappy(self, n: int) -&gt; bool:        set_=set()        while True:            if n == 1:                return True            n = self.self_sum(n)            if n in set_:                return False            else :                set_.add(n)             def self_sum(self,n):           new_n = 0        while n :            n1 = n % 10            n = n // 10            new_n += n1 ** 2         return new_n\n这道题的思路是：用一个集合来存储每次计算得到的结果，如果结果重复出现，说明进入了循环，不是快乐数。如果结果为1，说明是快乐数。利用哈希表来存储每次计算的结果，一旦出现重复的结果，说明进入了循环，不是快乐数。\n两数之和\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n\n示例:给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1]\n\ndir=&#123;&#125;      for i in range(len(nums)): #遍历数组          if target-nums[i] not in dir: #如果目标值减去当前值不在字典中              dir[nums[i]] = i          else :              return [dir[target-nums[i]],i]\n这道题在我的第一篇blog有，感兴趣的可以去看看，这道题是哈希表里面map的应用\n","categories":["算法学习——哈希表"],"tags":["代码随想录"]},{"title":"代码随想录-day8","url":"/2025/12/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day8/","content":"反转字符串\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n\n\n示例 1：输入：[“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”]\n示例 2：输入：[“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”]\n\nclass Solution:    def reverseString(self, s: List[str]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify s in-place instead.        &quot;&quot;&quot;        j=len(s)-1        for i in range(len(s)//2):            s[i],s[j] = s[j],s[i]            j -= 1\n这道题的思路是用双指针的方式，分别指向头尾，然后交换位置，循环判断条件就到中间位置（比长度的一半小）。\n反转字符串IIleetcode链接\n\n给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n\n\n示例:输入: s &#x3D; “abcdefg”, k &#x3D; 2输出: “bacdfeg”\n\nclass Solution:    def reverseStr(self, s: str, k: int) -&gt; str:        def c_r(s_):            left,right = 0,len(s_)-1            while left &lt; right:                s_[left],s_[right]=s_[right],s_[left]                left += 1                right -= 1            return s_        i=0        s_list=list(s)        while i &lt; len(s):            s_list[i:i+k] = c_r(s_list[i:i+k])            i += 2 * k        return &quot;&quot;.join(s_list)\nclass Solution:    def reverseStr(self, s: str, k: int) -&gt; str:        s = list(s)        for i in range(0, len(s), 2*k):            s[i:i+k] = s[i:i+k][::-1]        return &#x27;&#x27;.join(s)\n这道题的主要特点是切片的方式是以2k为步长，每次取k个字符进行反转。并且python的切片操作是可以超出索引范围的，会自动截断为有效范围。（Python 切片的容错特性：无需判断剩余字符长度，i:i+k 自动截断为有效范围，让 “反转前 k 个 &#x2F; 反转全部剩余” 的要求自然满足），i相当于一个指针，每次移动2k个位置，只要能移动在下一次循环就进行切片。\n替换数字\n给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。\n\n\n例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。对于输入字符串 “a5b”，函数应该将其转换为 “anumberb”输入：一个字符串 s,s 仅包含小写字母和数字字符。输出：打印一个新的字符串，其中每个数字字符都被替换为了number样例输入：a1b2c3样例输出：anumberbnumbercnumber数据范围：1 &lt;&#x3D; s.length &lt; 10000。\n\nn = input()count_num = sum(1 for i in n if i.isdigit())count = count_num * 5 + len(n) #记得count_num是数字字符的个数，每个数字字符替换为number后会增加5个字符，所以是*5n_list = [&#x27;&#x27;] * counto_p = len(n)- 1n_p = count - 1while o_p &gt;= 0:    if n[o_p].isdigit():        n_list[n_p-5:n_p+1] = &quot;number&quot; #注意切片是位置到位置，不能直接[n_p-5:6]这种操作        n_p -= 6    else :        n_list[n_p]=n[o_p]        n_p -= 1    o_p -= 1print(&quot;&quot;.join(n_list))\n这道题还是用双指针的方式，一个指向原字符串的尾，一个指向新字符串的尾，根据是否为数字字符来判断是否需要替换。如果是c语言从后向前可以避免每次替换后需要移动后面的字符的问题。python因为字符串是不可变的，所以需要先将字符串转换为列表，修改后再转换为字符串。然后就是要两个指针一一对应，一个指向原字符串的当前字符，一个指向新字符串的当前位置。\n","categories":["算法学习——字符串"],"tags":["代码随想录"]},{"title":"代码随想录-day9","url":"/2025/12/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day9/","content":"翻转字符串里的单词\n给定一个字符串，逐个翻转字符串中的每个单词。\n\n\n示例 1：输入: “the sky is blue”输出: “blue is sky the”\n示例 2：输入: “  hello world!  “输出: “world! hello”解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n示例 3：输入: “a good   example”输出: “example good a”解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。方法一：split()分割加列表反转\n\nclass Solution:    def reverseWords(self, s: str) -&gt; str:        s_list = s.split()        s_list = s_list[::-1]        return &quot; &quot;.join(s_list)\n方法二：双指针法\nclass Solution:    def reverseWords(self, s: str) -&gt; str:        class Solution:    def reverseWords(self, s: str) -&gt; str:        s = s.split()        left,right = 0,len(s)-1        while left &lt; right:            s[left],s[right]=s[right],s[left]            left += 1            right -= 1        return &quot; &quot;.join(s)\n视频的方法今天有点来不及\n右旋字符串\n字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。输出：输出共一行，为进行了右旋转操作后的字符串。\n\n\n样例输入：2abcdefg样例输出：fgabcde\n\n数据范围：1 &lt;&#x3D; k &lt; 10000, 1 &lt;&#x3D; s.length &lt; 10000\nn=int(input())s=input()print(s[-n:]+s[:-n])\n额，今天考马原上午都在看马原，额，但是不得不说，python真的太刁了，字符串切片操作真的是太方便了，但是我还是要提醒一下，字符串是不可变的，所以切片操作不会改变原字符串，而是返回一个新的字符串。\n日记感觉马原要挂科。明明我背那么久了，结果全背错了，张冠李戴给我玩明白了，我服了。一想到考研要考政治我就绝望\n","categories":["算法学习——字符串"],"tags":["代码随想录"]},{"title":"代码随想录-day7","url":"/2025/12/23/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-day7/","content":"四数相加II\n给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。\n\n\n例如:输入:A &#x3D; [ 1, 2]B &#x3D; [-2,-1]C &#x3D; [-1, 2]D &#x3D; [ 0, 2]输出:2解释:两个元组如下:(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0\n\nclass Solution:    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:        t_set = &#123;&#125;        count = 0        for i in nums1:            for j in nums2:                t_set[i+j] = t_set.get(i+j,0) + 1        for i in nums3:            for j in nums4:                if 0-(i+j) in t_set.keys():                    count += t_set[0-(i+j)]        return count\n这道题就是将四个数分成两组前两个数一组，并把他们的和作为key，出现的次数作为value，存到一个哈希表中。然后遍历后两个数的组合，判断0-(i+j)是否在哈希表中，如果在，就把出现的次数加到count中（注意加的是value的值不是一，原因是不用去重）。\n赎金信\n给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\n\n\n例如:输入: ransomNote &#x3D; “a”, magazine &#x3D; “b”输出: false输入: ransomNote &#x3D; “aa”, magazine &#x3D; “ab”输出: false输入: ransomNote &#x3D; “aa”, magazine &#x3D; “aab”输出: true\n\nclass Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        a_hash = [0] * 26        for i in magazine:            a_hash[ord(i)-ord(&#x27;a&#x27;)] += 1        for i in ransomNote:            if a_hash[ord(i)-ord(&#x27;a&#x27;)] == 0:                return False            else :                a_hash[ord(i)-ord(&#x27;a&#x27;)] -= 1        return True\n这道题就是用一个哈希表来记录 magazine 中的字符出现的次数，然后遍历 ransomNote 中的字符，判断是否在哈希表中，如果在，就把哈希表中对应的值减一。直到遇到了0，就说明 magazine 中的字符不能构成 ransomNote 中的字符，返回 False。跟昨天第一题很像\n三数之和\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。注意： 答案中不可以包含重复的三元组。\n\n\n示例：给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]\n\nclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        result = []        nums.sort()        for i in range(len(nums)):            if nums[i] &gt; 0 :                return result            if i &gt; 0 and nums[i] == nums[i-1]:                continue            left = i + 1            right = len(nums) - 1            while left &lt; right:                if nums[i] + nums[left] + nums[right] &gt; 0:                    right -= 1                elif nums[i] + nums[left] + nums[right] &lt; 0:                    left += 1                else:                    result.append([nums[i],nums[left],nums[right]])                    while left &lt; right and nums[left] == nums[left + 1]:                        left += 1                    while left &lt; right and right &lt; len(nums)-1 and nums[right] == nums[right - 1]:                        right -= 1                    right -= 1                    left += 1        return result\n用了双指针的思路首先先对数组排序，然后for循环用i作为第一个数，left作为第二个数，right作为第三个数，三个数求和判断是否等于0，如果等于0，就把这三个数加入到结果中。如果大于0，就把right减一，如果小于0，就把left加一。直到left大于等于right，就说明这个数组合完了，就可以继续下一个数了。注意点去重操作是i和i-1比较，left和left+1比较，right和right-1比较，为啥这样的，因为i是基准，如果i和i+1判断，把下一个i跳了，i就像边界一样，left就指不到被跳的i的那个位置了，比如-2 -1 -1 0 2，但是i继续加一以后，发现和之前的i一样，这个i就可去掉了，这里不会重复是上一组的i已经用过这个顺序了，例如-1 -1 0 0 1 2，然后left和right就是和自己的下一个数比较即可，而且不会遗漏，哪怕有连续的left挑掉，right也会移动过去，不像i是基准\n四数之和\n题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。\n\n\n示例： 给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]\n\nclass Solution:    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:        result = []        nums.sort()        for i in range(len(nums)):            if nums[i]&gt;0 and nums[i] &gt; target//4 :                break #这里不能return result            if i&gt;0 and nums[i] == nums[i-1]:                continue            for j in range(i+1,len(nums)):                if nums[i] + nums[j] &gt; target and target &gt; 0:                     break                if j &gt; i+1 and nums[j] == nums[j-1]:                    continue                left,right = j+1,len(nums)-1                while left &lt; right:                    sum_=nums[i]+nums[j]+nums[left]+nums[right]                    if sum_ == target:                        result.append([nums[i],nums[j],nums[left],nums[right]])                        while left &lt; right and nums[left] == nums[left+1]:                            left += 1                        while right &gt; left and nums[right] == nums[right-1]:                            right -= 1                        left += 1                        right -= 1                    elif sum_ &gt; target    :                        right -= 1                    else :                        left += 1        return result\n就是在i的基础上加了一个j也作为基准，然后在i和j的基础上用双指针的思路，left和right作为第三个数和第四个数，判断是否等于target，如果等于0，就把这四个数加入到结果中。我再思考一下\n","categories":["算法学习——哈希表"],"tags":["代码随想录"]}]